<!DOCTYPE html>
<html lang='en'>

<head>
  <meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='description' content='The programming exercise is from TAoCP, Vol3, 5.1.1-6:
 Design an algorithm that computes the inversion table $b_1, b_2 \cdots b_n$ corresponding to a given permutation $a_1a_2 \cdots a_n$ of ${1, 2, \cdots , n}$, where the running time is essentially proportional to $n\ log n$ on typical computers.
 I was really stuck on the solution Knuth given in the book. The author also mentioned another approach which actually is a modifination of merge sort.'>
<meta name='theme-color' content='#ffcd00'>

<meta property='og:title' content='Generate the inversion table from an integer sequence • Dang-Khoa'>
<meta property='og:description' content='The programming exercise is from TAoCP, Vol3, 5.1.1-6:
 Design an algorithm that computes the inversion table $b_1, b_2 \cdots b_n$ corresponding to a given permutation $a_1a_2 \cdots a_n$ of ${1, 2, \cdots , n}$, where the running time is essentially proportional to $n\ log n$ on typical computers.
 I was really stuck on the solution Knuth given in the book. The author also mentioned another approach which actually is a modifination of merge sort.'>
<meta property='og:url' content='http://dangkhoasdc.github.io/docs/gen_inversion_table/'>
<meta property='og:site_name' content='Dang-Khoa&#39;s blog '>
<meta property='og:type' content='article'><meta property='og:image' content='https://www.gravatar.com/avatar/ff98eba7ca4592a175b13bd623f28f0c?s=256'><meta property='article:author' content='https://facebook.com/dangkhoasdc'><meta property='article:section' content='Docs'><meta property='article:tag' content='algorithms'><meta property='article:tag' content='taocp'><meta property='article:published_time' content='2018-01-16T00:00:00Z'/><meta property='article:modified_time' content='2018-01-16T00:00:00Z'/><meta name='twitter:card' content='summary'><meta name='twitter:creator' content='@dksdc'>

<meta name="generator" content="Hugo 0.53" />

  <title>Generate the inversion table from an integer sequence • Dang-Khoa</title>
  <link rel='canonical' href='http://dangkhoasdc.github.io/docs/gen_inversion_table/'>
  
  
  <link rel='icon' href='/favicon.ico'>
<link rel='stylesheet' href='/assets/css/main.809149b6.css'><style>
:root{--color-accent:#ffcd00;}
</style>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-2381283-3', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  

</head>


<body class='page type-docs'>

  <div class='site'>

    <a class='screen-reader-text' href='#content'>Skip to Content</a>

    <div class='main'>

      <nav id='main-menu' class='menu main-menu' aria-label='Main Menu'>
  <div class='container'>
    
    <ul><li class='item'>
        <a href='/docs/' class="">
          <span>Docs</span>
        </a>
      </li><li class='item'>
        <a href='/page/about/' class="">
          <span>About Me</span>
        </a>
      </li><li class='item'>
        <a href='#posts' class="">
          <span>Posts</span>
        </a>
      </li><li class='item'>
        <a href='#about' class="">
          <span>Home</span>
        </a>
      </li><li class='item'>
        <a href='#projects' class="">
          <span>Projects</span>
        </a>
      </li><li class='item'>
        <a href='#publications_selected' class="">
          <span>Publications</span>
        </a>
      </li><li class='item'>
        <a href='/about/' class="">
          <span>About</span>
        </a>
      </li><li class='item'>
        <a href='/tags/notes/' class="">
          <span>Notes</span>
        </a>
      </li></ul>
  </div>
</nav>

      <header id='header' class='header site-header'>
        <div class='container sep-after'>
          <div class='header-info'><p class='site-title title'>Dang-Khoa&#39;s blog </p><p class='desc site-desc'></p>
          </div>
        </div>
      </header>

      <main id='content'>


<article lang='en' class='entry'>
  <header class='header entry-header'>
  <div class='container sep-after'>
    <div class='header-info'>
      <h1 class='title'>Generate the inversion table from an integer sequence</h1>
      

    </div>
    
<div class='entry-meta'>
  <span class='posted-on'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
  <line x1="16" y1="2" x2="16" y2="6"/>
  <line x1="8" y1="2" x2="8" y2="6"/>
  <line x1="3" y1="10" x2="21" y2="10"/>
  
</svg>
<span class='screen-reader-text'>Posted on </span>
  <time class='entry-date' datetime='2018-01-16T00:00:00Z'>2018, Jan 16</time>
</span>

  <span class='byline'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M21,21V20c0-2.76-4-5-9-5s-9,2.24-9,5v1"/>
  <path d="M16,6.37A4,4,0,1,1,12.63,3,4,4,0,0,1,16,6.37Z"/>
  
</svg>
<span class='screen-reader-text'> by </span><a href='/authors/khoa'>Dang-Khoa</a></span>
  

  
  
</div>


  </div>
</header>

  
  

  <div class='container entry-content'>
  

<p>The programming exercise is from TAoCP, Vol3, 5.1.1-6:</p>

<blockquote>
<p>Design an algorithm that computes the inversion table $b_1, b_2 \cdots b_n$
corresponding to a given permutation $a_1a_2 \cdots a_n$ of ${1, 2, \cdots , n}$,
where the running time is essentially proportional to $n\ log n$ on typical
computers.</p>
</blockquote>

<p>I was really stuck on the solution Knuth given in the book. The author also
mentioned another approach which actually is a modifination of merge sort. But
let first understand the algorithm using bitwise.</p>

<h1 id="implementation">Implementation</h1>

<p>The C++ implementation has a bit different from the original one. I used 0-index
array instead of 1-index array as Knuth&rsquo;s version. Frankly, it is not the best
version, I just want to convert the pseudo code to an executable one.</p>

<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main(int argc, char const* argv[])
{
    // input
    int n; cin &gt;&gt; n;
    vector&lt;int&gt; v(n, 0);
    for (auto&amp; vi: v) cin &gt;&gt; vi;

    // algorithm: TAoCP vol 3. 5.1.1-6
    // init
    vector&lt;int&gt; b(n, 0);
    vector&lt;int&gt; x((n&gt;&gt;1)+1, 0);
    int k = 0, r, s;
    for (int nn=n; nn&gt;1; nn &gt;&gt;= 1) k++; // compute floor(lg(n))

    for (; k &gt;= 0; k--) { // traversal through bits 0 -&gt; \floor(\lg N)
        for (int s = 0; s &lt;= n&gt;&gt;(k+1); s++) // init array x = 0 \forall elements
            x[s] = 0;

        for (int j = 0; j &lt; n; ++j) {
            r = (v[j] &gt;&gt; k) &amp; 1;
            s = v[j] &gt;&gt; (k+1);

            if (r) x[s] += 1;
            else b[v[j]-1] += x[s];
        }
    }

    // output
    for (auto bi: b) cout &lt;&lt; bi &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;

    return 0;
}

</code></pre>

<h1 id="analysis">Analysis</h1>

<p>About the running time, it is discernible since the outer loop of $k$ costs
$\lfloor\lg N\rfloor$ and two inner cost $k+2$ and $N$, respectively.</p>

<p>But how on earth does the algorithm work? It is too subtle to be understand
at the first time we saw the solution.</p>

<p>Given the index of bitstring $k$, we consider 2 strings having the forms
$\overline{s1T}$ and $\overline{s0T}$. Given a fixed $\overline{s}$, $T$ and
any $T&rsquo;$, we always know that $\overline{s1T&rsquo;}$ &gt; $\overline{s0T}$. <code>x[]</code> plays
a role as a counter which checks how many elements of $\overline{s1T&rsquo;}$ we have
browsed and the inversion $b[\overline{s0T}]$ updates
its value by $x[\overline{s}]$.</p>

<p>For example, let input be $5, 9, 1, 8, 2, 6, 4, 7, 3$, we have the following
binary codes:</p>

<pre><code>5: 0101
9: 1001
1: 0001
8: 1000
2: 0010
6: 0110
4: 0100
7: 0111
3: 0011
</code></pre>

<p>Let run the algorithm step by step:</p>

<ol>
<li><code>k=3</code>. $\overline{s} = \overline{0}$, <code>x[0] = 2</code>. <code>b = 1 2 2 2 0 2 2 0 0</code>.</li>
<li><code>k=2</code>. Array <code>x</code> have two items $x[\overline{0}]$, and $x[\overline{1}]$ whose
values are 4, 0, respectively. <code>b = 2 3 6 2 0 2 2 0 0</code>.</li>
<li><code>k=1</code>. There are 3 posibilities of $x[s]$, namely $x[\overline{00}]$,
$x[\overline{01}]$, $x[\overline{10}]$ whose values are 2, 2, 0, respectively.
Eventually, b is <code>2 3 6 3 0 2 2 0 0</code>.</li>
<li><code>k=0</code>, There are 5 items in <code>x</code>: $x[\overline{000}] = 1$,
$x[\overline{001}]=1$, $x[\overline{010}]=1$ ,$x[\overline{011}]=1$, $x[\overline{100}]=1$,
we get the final output <code>b = 2 3 6 4 0 2 2 1 0</code>.</li>
</ol>

<!--
The main idea is based on the current index $k$, the algorithm divides the set
of $n$ elements into many subsets based the binary prefix of each number. Later,
it updates the inversion value from the total number of candidates of subsets whose
element is larger than the value that we are currently considering.

For example, given the sequence from the book: $5, 9, 1, 8, 2, 6, 4, 7, 3$.

Firstly, we divide the input into 2 sets: $1, 2, 3, 4, 5, 6, 7$ and $8, 9$.
`x[s]` only counts the candidates of the set whose `r=1`, namely the larger
set. Specifically, when `k=3`, `x = [2]`. `b` is updated based on contemporary
`x`.

Next when `k=2`, we categorize the input into 3 subsets: $1, 2, 3$, $4, 5, 6, 7$ and
$8. 9$. Since we already count the set $8, 9$, we know only check the size
of $4, 5, 6,7 $ and update the inversion of $1, 2, 3$.

When `k=1`, we have 4 subsets: $1$, $2, 3$,

Finally, `k=0` we get $\{1\}$; $\\{2, 3\\}$; $\\{4, 5\\}$, $\\{6, 7\\}$, and $\\{8, 9\\}$.
The algorithms will count candidates on set elements $1, 3, 5, 7, 9$
-->

<h1 id="the-mergesort-based-algorithm">The mergesort-based algorithm</h1>

<p>Instead of constructing an inversion table, this algorithm count the total
number of inversions in a permutation which utilize merging procedures from
the renowned mergesort.</p>

<pre><code class="language-cpp">class inversion {
    private:
        vector&lt;int&gt; x, aux;
        long long int cnt;
    public:
        inversion(const vector&lt;int&gt;&amp; x_): x(x_), aux(x_.size()), cnt(0) {
            merge_sort(x, 0, x.size());
        } //ctor

        void merge_sort(vector&lt;int&gt;&amp; a, int low, int high) {
            if (low &gt;= high-1) return ;

            int mid = low + (high-low)/2;

            merge_sort(a, low, mid);
            merge_sort(a, mid, high);

            merge(a, low, mid, high);

        }

        void merge(vector&lt;int&gt;&amp; a, int low, int mid, int high) {
            int subidx_1  = low;
            int subidx_2  = mid;

            for (int j = low; j &lt; high; ++j) {
                if       (subidx_1 &gt;= subidx_2)       aux[j] = a[subidx_2++];
                else if  (subidx_2 &gt;= high)           aux[j] = a[subidx_1++];
                else if  (a[subidx_1] &lt;= a[subidx_2]) aux[j] = a[subidx_1++];
                else {
                    cnt += (mid-subidx_1); // (1)
                    aux[j] = a[subidx_2++];
                }
            }

            // copy back to a
            copy(aux.begin()+low, aux.begin()+high, a.begin()+low);
        }

        inline long long int count() const { return cnt;}
};
</code></pre>

<p>This is the exercise 5.2.5-21 in TAoCP. Unfortunately, Knuth did not mention
the solution. The only modification is to add <code>(1)</code> to the merging step which
counts the number of inversions of <code>a[subidx_2]</code>, the item in the second
array we consider while merging two arrays. Since from <code>mid</code> to <code>subidx_2</code>, all
items are lesser or equals to <code>a[subidx_2]</code>, so there is 0 inversions. However,
since <code>a[subidx_1] &gt; a[subidx_2]</code> it means that all items from <code>subidx_1</code> to <code>mid</code>
are greater than <code>a[subidx_2]</code> given the invariant that two arrays are already
sorted. Therefore, there are <code>mid-subidx_1</code> inversions of <code>a[subidx_2]</code>.</p>

<h1 id="reference">Reference</h1>

<ul>
<li><a href="http://gywangmtl.blogspot.sg/2013/03/n-log-n.html" target="_blank">gywangmtl&rsquo;s post</a>: the
post trully helps me understand the algorithm. Also, thank you, Google Translates.</li>
</ul>

</div>

  
<footer class='entry-footer'>
  <div class='container sep-before'>
  <div class='tags'>
  <span class='taxonomy-icon'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M20.59,13.41l-7.17,7.17a2,2,0,0,1-2.83,0L2,12V2H12l8.59,8.59A2,2,0,0,1,20.59,13.41Z"/>
  <line x1="7" y1="7" x2="7" y2="7"/>
  
</svg>
</span>
  <span class='screen-reader-text'>Tags: </span><a class='tag' href='/tags/algorithms'>algorithms</a>, <a class='tag' href='/tags/taocp'>taocp</a></div>

  </div>
</footer>


</article>

<nav class='entry-nav'>
  <div class='container'><div class='prev-entry sep-before'>
      <a href='/docs/selectedpapers_cs/'>
        <span aria-hidden='true'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <line x1="20" y1="12" x2="4" y2="12"/>
  <polyline points="10 18 4 12 10 6"/>
  
</svg>
 Previous</span>
        <span class='screen-reader-text'>Previous post: </span>Selected Papers on Computer Science (Don Knuth) and the current state of Deep Learning</a>
    </div><div class='next-entry sep-before'>
      <a href='/docs/compvision_hist/'>
        <span class='screen-reader-text'>Next post: </span>History of Computer Vision - Part 1<span aria-hidden='true'>Next <svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <line x1="4" y1="12" x2="20" y2="12"/>
  <polyline points="14 6 20 12 14 18"/>
  
</svg>
</span>
      </a>
    </div></div>
</nav>




      </main>

      <footer id='footer' class='footer'>
        <div class='container sep-before'><div class='copyright'>
  <p>&amp;copy; 2017 Dang-Khoa</p>
</div>

        </div>
      </footer>

    </div>
  </div><script>window.__public_path__='http:\/\/dangkhoasdc.github.io\/assets\/js\/'</script>

<script src='http://dangkhoasdc.github.io/assets/js/main.68cb493a.js'></script><script type='text/x-mathjax-config'>
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"processEscapes":true}})
</script>

<script type='text/javascript' async src='//unpkg.com/mathjax/MathJax.js?config=TeX-MML-AM_CHTML'></script>





</body>

</html>






















