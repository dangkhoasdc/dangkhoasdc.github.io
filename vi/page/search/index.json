[{"content":"","href":"/vi/","title":"Trang chủ"},{"content":"","href":"/vi/docs/","title":"Documentation"},{"content":"","href":"/vi/page/about/","title":"dangkhoasdc"},{"content":" Trong bài viết này mình sẽ chia sẻ một số kỹ thuật cũng như ý tưởng có thể trong cuộc thi Zalo AI Challenge - Landmark data do team mình - VietAI - thực hiện.\nDữ Liệu Dưới đây là phân phối số lượng ảnh trên mỗi label.\n  Phân phối mẫu trên mỗi lớp, Landmark data. Có khoảng 8 lớp có dưới 250 mẫu/class.   Một số class có số sample tương đối thấp, ta có thể cần 1 số technique để khắc phục vấn đề này.\n![]()\n  Một số hình lấy từ tập train, mỗi dòng là các mẫu thuộc 1 địa danh.    Kỹ thuật Team mình đã sử dụng 9 models khác nhau để train và sau đó stack/blend lại. Bao gồm:\n Denset121, DenseNet161 Resnet50, Resnet152 ResNext50, ResNext101 Wide-resnet. Inception_v4, Inceptionresnet_v2.  [Mình đã finetune 34 models khác nhau với kiến trúc và optimizer scheme khác nhau (learning rate/ weight decay/ data augmentation không tính)]\nĐể tăng độ chính xác model, tụi mình có sử dụng và thử 1 số phương pháp sau [phần bôi đen là những kỹ thuật rất quan trọng để tăng hiệu quả của model]:\n Freeze network rồi finetune, sau đó unfreeze toàn bộ và train. [Thực sự hiệu quả]. Tuy nhiên lưu ý một điều: sau khi unfreeze toàn bộ các layer thì quá trình train sẽ rất chậm, ta cần phải điều chỉnh số lượng epoch ở bước này cho hợp lý. Sử dụng Cyclic Learning Rates [Thực sự hiệu quả]. Tham số mà mình thấy ổn nhất, cũng như có thời gian train tương đối chấp nhận được (tầm 20h/ 1 model): cycle_length = 2, cycle_multiplier = 2, num_cycles = 4 Adam Optimizer + Weight Decay [Improve 1 cách tương đối]. Adam giúp loss giảm nhanh hơn SGD. Differential Weigh Decay tuy vậy không thấy cải thiện được gì. Stochastic Gradient Descent with Warm Restarts: khá tốt. Stochastic Weight Averaging: Không hiệu quả + khiến thời gian train tăng.. Differential Learning Rate: improve tương đối. Data Augmentation/ Test Time Augmentation: Thực sự hiệu quả. Đây là cách hiệu quả nhất để tránh overfitting. Tăng kích thước ảnh: Thực sự hiệu quả. Tuy nhiên phụ thuộc vào Memory của GPUs và kiến trúc mạng. Bộ ba thần thánh của mình là: 224, 256, 299. Sử dụng fully connected layers kết hợp với kNN làm thành 1 classifier: đây là ý tưởng của team 4th Google Landmark Recognition - thực sự không hiệu quả trong case này [, hoặc là mình implement bậy rồi] . Để handle imblance data: ta có thể dùng upsampling, downsampling hoặc sử dụng distribution khác cho sampler (mình đã implement multinomial distribution thay cho uniform của pytorch) cũng như sử dụng weighted loss (thêm weight dựa trên số lượng sample/class). Một số kỹ thuật có thể tham khảo ở đây [Link]. Khá tiếc khi phần này đã bị leader reject, trong khi top 1 Landmark đã dùng kỹ thuật này để đạt kết quả tốt ở private test. Để có thể chọn learning rate hợp lí và nhanh, kỹ thuật trong bài [Cyclical Learning Rates for Training Neural Networks] được sử dụng phổ biến, ta có thể plot nhiều setting của một model trên cùng 1 figure để chọn learning phù hợp. Nếu bạn lười, cứ set learning rate là 3e-4. Thánh Karpathy đã verify điều đó (Twitter).    Một số bài viết hỗ trợ trong quá trình finetune:\n Playing around with SGDR [Link] Differential Learning Rates [Link] Optimization techniques comparison in Julia: SGD, Momentum, Adagrad, Adadelta, Adam [Link]  Về phần stack/blend, mình nhường lại cho leader Khả Ái (Phát); hầu như các solution trên Forum Machine Learning Cơ Bản mà các bạn top 3 post đều nằm trong plan thực hiện của Khả Ái. Nên mình tin nếu lúc đó mình làm đúng plan thì kết quả bên Landmark lẫn Music đã rất khác rồi.\n[Nhân đây: Noi theo tấm gương sáng ngời cùng đường lối sáng suốt của leader , mình phát động phong trào đẩy mạnh học tập và làm theo tư tưởng, đạo đức Hoàng Quý Phát]\n  T-SNE của ResNet50 features 1 subset của train data (feature:Resnet50)jq    Other  Mình dùng 1 Titan X, 2 1080 Ti, 1 P100 để train. Trước deadline vài ngày có dùng 1 máy Google Cloud. Rất nhiều hình gif bị save thành jpg, ta có thể dùng trick để avoid lỗi những ảnh này. Đừng sa lầy bởi code đểu, đừng nghe dân mạng chém gió và cố gắng bám sát vào plan của mình. Chỉ nên tin những nguồn đáng tin cậy. Sử dụng notion.so để quản lý ghi chú, kết quả thí nghiệm và lên kế hoạch.  Các ý tưởng khác Image Retrieval - KNN Để sử dụng kỹ thuật image retrieval hiệu quả [tức là image retrieval thực sự outperform classification] thì dataset cần hội đủ các yếu tố:\n Dataset có số lượng label rất lớn. Phân phối training samples không đều và chênh lệch lớn. Mối tương quan giữa các ảnh trong cùng 1 class thấp.  Ví dụ điển hình là tập Google Landmark với 1.5 triệu ảnh, và 15K label (landmark) khác nhau. Hình dưới cho thấy rất nhiều label có số lượng trainng ít.\n  Trong 3 điều kiện trên thì tập Landmark của Zalo thỏa được (2) và (3) phần nào đó. Ví dụ ở class 0 và 1, độ tương quan khá thấp, và nếu không biết trước được rằng các hình nằm chung 1 class thì mình nghĩ đến cả human còn nhầm đây là các địa điểm khác nhau:\nỞ các kỹ thuật trong retrieval có thể đơn giản hóa như sau:\n Tận dụng local features làm representation và search dựa trên Euclidean distance. Dùng k-NN kết với với kd tree (exact search) hoặc PQ (approximate search) để giảm thời gian search (lưu ý ràng buộc 6 tiếng inference) [dĩ nhiên với dataset nhỏ thì cứ dùng k-NN]. Dùng các kỹ thuật Pooling hoặc Masking [2] thay vì dùng trực tiếp feature tầng cuối của network. Và như vậy, ta sẽ pooling ở tầng conv thay vì tầng fully connected.  Local features như RootSIFT+BoW hoặc RootSIFT+Triemb hoạt động rất tốt trong case này:\n  Nguồn: slide - Ranked 3rd Google Landmark Recognition Challenge   Với kỹ thuật này, ta có thể apply 1 số technique hay ho như:\n Query Expansion [3]. Regional Diffusion [4].  Image Retrieval cùng với các kỹ thuật này đã đạt kết quả rất tốt ở hai cuộc thi là Landmark Retrieval và Landmark Recognition của Google [Link]. Mình nghĩ ít nhiều nó sẽ giúp improve performance, đặc biệt là với với class có intra-class correlation thấp.\nFine-grained Classification Nếu ta xem xét các labels và thứ tự của nó, ta nhận ra rằng các lớp chung 1 category sẽ nằm cạnh nhau. Ví dụ:\n Từ label 17 → 23: các thể loại cầu; bao gồm: Cầu Chương Dương, Cầu Tràng Tiền, Cầu Rồng, Cầu Tình Yêu, Cầu Tay Vàng Bà Nà. Label từ 25 → 28: các thể loại cột cờ: Cột cờ Hà Nội, Cột cờ Hà Giang, Cột cờ Đảo Trường Sa và Cột cờ Cà Mau. Label 9 → 11: các chợ: Chợ Bến Thành, chợ Nổi và chợ Đồng Xuân. Label 71 → 79: các nhà thờ Công Giáo: Nhà Thờ Đức Bà, Nhà Thờ Nha Trang, Nhà Thờ ở Phú Yên, \u0026hellip;  Một ý tưởng đơn giản đó là ta gom hết các data trong các nhóm đó lại với nhau thành 1 label lớn: ví dụ \u0026ldquo;chợ\u0026rdquo;, \u0026ldquo;cầu\u0026rdquo;, \u0026ldquo;cột cờ\u0026rdquo; và xây dựng bộ classifier trên đó (tạm gọi là Classifier-A). Kết quả có thể đem làm trọng số cho classifier chính với 103 classes. Ngoài ra, ta có thể \u0026ldquo;random\u0026rdquo; trong trường hợp kết quả ra thấp: Nếu bộ classifier 103 lớp không classify được, nhưng bộ Classifier-A ra kết quả là \u0026ldquo;cầu\u0026rdquo; với confidence cao, ta có thể random trong đó [Dĩ nhiên, có nhưng phương pháp fancy hơn để inference ra kết quả]; ngay cả với random, giả sử groundtruth là 1 trong 7 loại cầu: thì ta có xác suất 1-6C3/7C3 = 42.8571 %. Theo bản thân mình, đây cũng là cách mà con người nhận biết landmark. Fancy hơn, bạn có thể dùng Maximum Spanning Tree Clustering [Link]\nĐồng thời, với quan sát như trên, ta có thể sử dụng 1 số phương pháp fine-grained classification để cải thiện độ chính xác. Bởi theo như quan sát, các kiến trúc cầu, nhà thờ, hay cột cờ có độ tương đồng hình ảnh khá giống nhau, thậm chí nếu chụp ở 1 góc nào đó thì kể cả con người cũng khó phân biệt được. Nên data như vậy rất phù hợp với kỹ thuật fine-grained classification.\nFun stuff  Với query là ảnh con cá này:  Model predict ra cơ sở nước mắm Phú Quốc.\nmodel của team mình predict ra label 70 - Cơ sở chế biến nước mắm Phú Quốc. Mặc dù sau khi kiểm tra 497 hình của class 70 này bằng mắt, không hình nào trong training data có hình con cá. Mình gọi đây là: The next level of AI.\n Hình tượng chúa ở Brazil được cho làm query, trong khi đây là cuộc thi Landmark ở Việt Nam, hình này còn xuất hiện vài lần trong tập test.   Mình rất muốn đi DisneyLand ở Việt Nam :(   Rất nhiều hình trong training data sử dụng ảnh của các site khác, mình tò mò là bên Zalo đã xin phép bản quyền chưa.  P.s: I love Vietnam\nMình không biết 3 hình này thuộc địa danh nào ở Việt Nam, nhưng rất đẹp.\nReferences [a] Cyclical Learning Rates for Training Neural Networks 2015, Leslie N. Smith.\n[1] Fine-tuning CNN Image Retrieval with No Human Annotation,\n[2] Selective Deep Convolutional Features for Image Retrieval\n[3] Total recall: Automatic query expansion with a generative feature model for object retrieval\n[4] A. Iscen, G. Tolias, Y. Avrithis, T. Furon, O. Chum. \u0026ldquo;Efficient Diffusion on Region Manifolds: Recovering Small Objects with Compact CNN Representations\u0026rdquo;, CVPR 2017\nXin chân thành cảm ơn sự giúp đỡ và hỗ trợ của VietAI trong quá trình mình tham gia cuộc thi. Dù không được vào Top 3 nhưng cũng là 1 trải nghiệm thú vị với nhiều điều đáng học hỏi.\n","href":"/vi/docs/zalo_landmark/","title":"AI Challenge - Landmark: Kỹ thuật và ý tưởng"},{"content":" Một vài kinh nghiệm cá nhân sau 1 chuyến đi du lịch Nha Trang tự túc từ HCM.\nPhương tiện đi lại Từ Hồ Chí Minh ta có nhiều lựa chọn để đi Nha Trang:\n Đi xe khách: 400K/ 1 vé xe chất lượng cao, xuất phát từ 9h40pm đến 6h sáng hôm sau sẽ tới bến. Đi trong đêm và sáng sớm tới Nha Trang để có thể tiết kiệm được nửa ngày. Đi xe giường nằm truyền thống thì hơi mệt nhưng rẻ hơn, có nhiều chuyến hơn và nhiều hãng xe để lựa chọn. Có hãng Xe Nhà với giá 400K/vé cũng khá ok. Vé giường nằm phổ thông thì là 200k/ 1 vé. Đi tàu: cũng được nhưng phải book vé từ rất sớm vì rất dễ hết vé. Phải lựa tàu đi vì nếu đi tàu chợ sẽ ghé nhiều trạm và dừng lâu. Vì vậy nếu đi tàu thì lựa chọn tốt nhất là tàu chất lượng cao (CLC) SNT2. Tuy nhiên các vé tàu CLC thường hay bị các đại lý mua trước nên nếu ra ga mua trực tiếp hay book online thì sẽ hơi khó, nên nếu chọn loại phương tiện này thì bạn nên mua sớm. Vé cơ bản dao động từ 400-600K/vé, nếu mua trễ hoặc không còn nhiều vé thì giá vé còn cao hơn nhiều (khoảng 900K). Đi máy bay: sẽ phải mất tầm 30 phút từ sân bay Cam Ranh tới về thành phố Nha Trang. Giá vé rẻ nhất tầm 900K lượt đi về, thông thường phải đặt trước tầm 1 tháng. Các hãng phục vụ gồm có Vietnam Airlines, Jetstar và Vietjetair.  Ăn uống  Bún chả cá Cô Ba trên đường Yersin, 35K/ tô đặc biệt không sứa, tô đặc biệt có sứa thì 40K.   Với đồ khô và hải sản: đường Ngô Gia Tự gần Chợ Xóm Mới. Ở đây có nhiều tiệm bán với đủ loại đồ khô khác nhau. Theo như mình hỏi bạn bè ở Nha Trang thì khi mua đồ khô nên mua ở đây thay vì ở chợ Đầm. Cafe Runam Bistro: không gian ấm cúng và đẹp, thức uống ngon và giá cả vừa phải. Theo lời bạn gái: \u0026ldquo;trai phục vụ đẹp\u0026rdquo;. Đồ uống thì bình thường, là chỗ checkin khá là đẹp và ấm cúng. Địa chỉ: trong khách sạn InterContinental. Bò nướng Lạc Cảnh: quán này được cu nhóc Nha Trang giới thiệu mình, mặc dù đúng là đồ ăn có ngon, mặc dù không quá xuất sắc, tuy nhiên phục vụ rất chán. Nếu bạn đang có 1 chuyến đi vui vẻ và không muốn gây lộn thì đừng nên vô quán này. Bonus review từ facebook. P.s: Review từ bạn gái mình [Link Facebook] Các món hải sản nên ăn ở phía bờ kè bên cạnh cầu Trần Phú, đường ngay sát gần bờ kè có nhiều nhà hàng, có lẽ nổi tiếng là Cây Me, giá cả giống với ở Sài Gòn Review từ Google, Review từ TripAdvisor]. Ở trên đường phía trong, đường Tháp Bà thì có nhiều chỗ ăn uống bình dân hơn.   Buổi trưa mình ăn bánh canh chả cá ở trên đầu đường Trần Văn Ơn, đây là quán ven đường, khá là ngon và nhiều món [Link Foody].\n  Bánh canh chả cá    Điểm chung mình nhận ra là phục vụ bình dân ở Nha Trang rất chán, đôi khi khiến mình khá bực bội.\n Một số điểm địa mình chưa kịp review:\n Nem nướng Ninh Hòa - Đặng Văn Quyên [Link Foody]. Cháo Óc \u0026amp; Gân Bò - 35 Lê Thành Phương [Link Foody]. Ốc Nhưng Lương Sơn [Link Foody]. Bánh Xèo Chảo - Tô Hiến Thành [Link Foody] Bún Sứa Chợ Đầm, mặc dù 2 đứa đã lết tới cái chợ nhưng cuối cùng không ăn. [Link Foody] Bánh canh Trần Thị Tín [Link Foody]   Các địa điểm tham quan và chụp hình  Tham quan Viện Hải Dương Học: giá 40K/vé người lớn, gần chỗ đi cáp treo VinPearl Land. Theo lời bạn gái mình: \u0026ldquo;dành cho những người không biết con cá là con gì thì nên vô trong đó\u0026rdquo;. Còn theo mình thì không hiểu sao Viện có vẻ nhỏ hơn so với hồi đầu mình đi tầm 12 năm về trước. Nhà thờ Chánh Tòa Kitô Vua, nên đi vào ngày thường để chụp hình [Link Wiki]. Tháp Po Nagar [Link Wiki]. Hòn Chồng [Link Tripadvisor]  Tắm bùn và suối khoáng ở Tháp Bà.  Đường đi đến chỗ tắm bùn không quá xa, tuy nhiên theo kinh nghiệm cá nhân là nên đổ xăng trước khi đi, vì ở Nha Trang ít trạm xăng, và cũng tương đối xa so với chỗ Tháp Bà. Đường cũng rất dễ đi, chỉ cần Google hoặc hỏi người dân địa phương là ra, ngoài ra còn có biển chỉ dẫn đi đến khu này. Về dịch vụ, nếu có thể đánh giá thì mình nghĩ nó 4/5, là một trong những địa điểm độc đáo của Nha Trang, giá cả thì mình thấy cũng hợp lý. Dịch vụ cơ bản bao gồm tắm bùn, tắm khoáng và tắm ở hồ. Một kinh nghiệm \u0026ldquo;xương máu\u0026rdquo;: đó là nên mang theo dép để đi trong khu vực tắm, nếu đi chân trần mà vào buổi trưa thì khá nóng. Review của chỗ này khá tốt, kể cả từ người dân địa phương, TripAdvisor, Google Maps  Vinpearl Land  Giá vé: nguyên ngày 880K/ 1 vé từ 8h sáng tới 9h tối; vé nửa ngày 450K/ 1 vé từ 4h chiều đến 9h tối. Giá vé bao gồm vé đi cáp treo và vé của tất cả trò chơi tham quan. Buổi chiều 4h mình và bạn gái đến Vinpearl và mua vé đi nửa ngày. Nếu đi buổi chiều thì sẽ không tham gia được công viên nước và một số hoạt động, tuy nhiên với mục đích tới chụp hình và tham gia 1 số trò mạo hiểm thì đi nửa ngày cũng là khá đủ. Điểm mình không thích lắm là sở thú ở Vinpearl, không hiểu sao những con vật nhìn rất tội nghiệp, không giống như những con vật đầy sức sống như ở Singapore Zoo. Nguyên nhân là do điều kiện chăm sóc, thời tiết hay không gian sinh hoạt quá nhỏ nên những con thú ở không có chút sức sống, nhìn xót hơn là thích thú. Chương trình nhạc nước khá hoành tráng và công phu, tuy nhiên mình không đánh giá cao nội dung trình bày lắm. Nếu được thì mình cho 3/5.   Chương trình nhạc nước ở Vinpearl Land    Buổi tối gần chỗ trạm cáp treo có 1 nhóm nhạc chơi gần đó, chị ca sĩ rất nhiệt tình và rất hay. Kinh nghiệm xương máu đó là chịu khó đứng quẩy với ban nhạc khoảng 30p, bởi lúc tối tầm 7h30 thì chỗ trạm kẹt cứng và đầy các đoàn du lịch trở về Nha Trang.\n  Ban nhạc ban đêm     Một số địa điểm/hoạt động khác mà mình không có dịp được review đợt này:\n Scuba \u0026amp; Snorkeling. Skylight Nha Trang. Bar: Hanava A-Z: Hoa Đà [Tự Hiểu]  ","href":"/vi/docs/nha_trang_summer18/","title":"Kinh nghiệm du lịch Nha Trang"},{"content":" Tình hình đến cuối tháng 4, 2019 mới hết hạn passport của mình, tuy nhiên vào đầu tháng 10 mình có đi Châu Âu và dự là trong tháng 6 này mình sẽ xin visa nên để không bị lỡ cỡ mình quyết định sẽ làm passport lúc này.\nTheo tham khảo ban đầu của mình thì có vẻ như làm ở Việt Nam tiện hơn rất nhiều so với làm ở Sing bởi vài lý do:\n Tiện hơn: ở Việt Nam chỉ cần mang CMND và passport cũ lên làm giấy tờ là xong. Ở Sing thì phải chuẩn bị thêm ảnh thẻ, pass. Chi Phí: Phí ở Việt Nam là 200K, còn ở Sing là 105 SGD [Nếu passport cũ làm ở nơi khác thì tốn thêm 80 sgd để xác minh]. Nếu cần gấp thì theo kinh nghiệm \u0026ldquo;xương máu\u0026rdquo; của bản thân, bạn nên về Việt Nam và làm dịch vụ, tốn tầm 3tr, tuy nhiên là trong 3-4 ngày đã có. Còn nếu là ở đại sứ quán Việt Nam thì số ngày chờ dao động từ 15-30 ngày.  Thông tin  Địa chỉ: 10 Leedon Park. Nếu đi MRT thì đến Holland Village MRT rồi đi bộ đến. Ở 211 Holland, địa chỉ level 3-48 có tiệm chụp hình, làm việc chuyên nghiệp, nhanh và thân thiện.   Thời gian làm việc: 3PM - 5PM. Hồ sơ cần mang theo:  Pass (Student pass, Epass, \u0026hellip;) CMND. 2 Ảnh thẻ 4 cm x 6 cm. Passport cũ.  Mang theo tiền mặt (~ 200 SGD)  Mình lượm lặt trên mạng thì form điền sẽ như sau:\n  Nguồn: user Thuy Nguyen trong [nvquanghuy blog](http://nvquanghuy.com/renew-vietnamese-passport-singapore/)   Quy trình  Đến nơi thì bấm lấy số thứ tự, mình nghĩ là nên đi lúc 2h30, tới 3h vô làm ngay cho xong. Khi được gọi tên thì sẽ được đưa form điền [giống như trên, mình đã check ngày 05/06/2018]. Xong thì quay lại nộp và đóng phí. Thủ tục đơn giản và không có gì quá khó. Thời gian chờ 15-30 ngày.  Trong thời hạn chờ passport mới được cấp thì passport cũ vẫn còn sử dụng bình thường [nếu còn hạn]. Chỉ có trường hợp khi trang hộ chiếu bị bấm lỗ thì mới không sử dụng được nữa.\nP.s: Để liên lạc với đại sứ quán (6462 5994) thì nên gọi giờ làm việc, tầm 3pm-5pm. Tuy nhiên, mình đã phải gọi đến 5 cuộc mới liên lạc được, nên nếu bạn sử dụng phương án này để liên lạc thì rất nên kiên trì.\n","href":"/vi/docs/passport_renewal/","title":"Kinh nghiệm xin làm passport mới ở Singapore"},{"content":" Bài viết xoay quanh một số mẹo vặt về làm nghiên cứu trong Khoa Học Máy Tính (KHMT), đặc biệt là hướng Machine Learning của một thanh niên mới tập tành làm research.\nLên kế hoạch Không giống như PhD khi học có kha khá nhiều thời gian để tìm hiểu bài toán nghiên cứu, thông thường nhóm mình chỉ có 2-3 tháng để tập trung cho 1 nghiêu cứu và phải hoàn thành bằng 1, 2 submission và các hội nghị. Dĩ nhiên, sau đó các công trình này có thể được mở rộng và nộp cho các tạp chí, công đoạn này nếu làm liền mạch thì có thể mất thêm 1, 2 tháng nữa. Bởi vậy, điều quan trọng là phân phối thời gian giữa các công việc, theo mình việc làm nghiên cứu theo hướng machine learning gồm 3 công đoạn chính:\n Lên ý tưởng, đề xuất model và phương pháp giải. Cài đặt và chạy thí nghiệm. Viết bài báo, dọn dẹp code và đăng tải.  Nếu như theo phương pháp waterfall trong công nghệ phần mềm, thì mỗi công đoạn được thực hiện riêng lẽ và tách biệt nhau. Tuy nhiên điều đó chỉ xuât hiện khi ta đề xuất được một model \u0026ldquo;lý tưởng\u0026rdquo;: chạy tốt trên các tập dữ liệu và hầu như không có trở ngại gì khi cài đặt. Điều này không phải lúc nào cũng có thể đạt được. Ví dụ, đôi khi dữ liệu chạy rất tốt trên MNIST hay Cifar10, nhưng lại chạy rất tệ trên SUN397. Điều đó khiến ta phải quay lại bước đầu tiên để xem xét lại model, bởi có lẽ nguyên nhân là do model không chạy tốt cho tập dữ liệu lớn và ta cần xây dựng một model mới tốt hơn.\nVì vậy, đề xuất của mình đó là tận dụng Agile trong research, 3 công đoạn có thể thực hiện trong 5 ngày rồi sau đó lặp lại liên tục cho đến khi \u0026ldquo;hội tụ\u0026rdquo; (đến deadline, hết idea để làm model, \u0026hellip;):\n 1-2 ngày lên model. 1-2 ngày cài đặt. 1 ngày chạy thí nghiệm và finetune.    Đôi khi đời không như mơ (Nguồn: http://amid.fish/reproducing-deep-rl)   Việc lên model là team-work. Công cụ tốt nhất đó là bảng, 1 phòng họp và liên tục brainstorm. Trong trường hợp phải làm remote, thì Slack và Paper Dropbox là 2 phương tiện rất tốt để ghi chú và trao đổi. Trên Slack ta có thể chia thành các channel khác nhau với từng task, model, conference khác nhau. Điểm mạnh của Paper Dropbox ở chỗ hỗ trợ comment, minh họa trên hình, và render công thức bằng Latex rất tốt.\nĐiều mình nhấn mạnh đó là chỉ nên dành 1 ngày để finetune. Bởi theo quan điểm của mình, finetuning model là một việc siêu chán, rất mệt và dễ làm tụt cảm xúc của người làm nghiên cứu. Giới hạn bản thân 1 ngày để finetune giúp ta ko quá sa đà vào việc cắm mắt lên màn hình finetune, hoặc phải đặt nải chuối cúng ông địa để mong có kết quả tốt. Việc giới hạn về thời gian còn giúp ta đề xuất ra được nhiều phương pháp đánh giá model nhanh hơn, có bộ tham số chuẩn và không finetune nhưng tham số quá tào lao.\nTrong khoảng thời gian xen lẫn các công đoạn, ta có thể cập nhật các bài báo mới, học các kỹ thuật mới hoặc tìm hiểu kỹ hơn về bài toán mình đang làm. Công cụ tốt nhất cho giai đoạn này chính là textbooks, arxiv-sanity, Google Scholar [với chế độ recommendation], reddit (/r/MachineLearning, /r/compsci, /r/compvision), twitter [Follow các giáo sư đầu ngành, các conference hay mấy con bot trên reddit]).\nCông đoạn cuối: viết paper có thể đổi tên thành \u0026ldquo;ghi chú, nhật ký\u0026rdquo;. Bằng cách sử dụng overleaf, và liên tục cập nhật tiến độ, công thức, model thông qua Latex, ta hầu như có được nội dung cho cả paper. Trong khi Paper Dropbox phục vụ cho việc ghi chú tào lao [làm thế nào finetune model, những idea lạ hay những thứ mình không muốn đưa vào paper] thì overleaf là nơi ghi chú theo chính quy với các viết formal và được coi như mình đang viết 1 paper thực sự. Dĩ nhiên, một bước tiến hóa của phương pháp này Literate Programming, mà hiện nay Jupyter là một ví dụ tiêu biểu. Đến khi cần phải submit 1 conference nào thì hầu như toàn bộ nội dung đã có sẵn, chỉ cần việc apply style của conference đó, đồng thời revise, proofread lại nội dung paper.\nCài đặt môi trường Mỗi người có một môi trường cài đặt khác nhau, trong khi đó setup của mình bao gồm:\n Keyboard: Code Keyboard, thiết kế bởi Jeff Atwood, founder của StackOverflow. Mouse: MX Master. Màn hình và workstation của lab.  Về software:\n NeoVim: mình không thích dùng IDE. Và vim rất tiện khi phải edit file remote, dường như mình không gặp trở ngại khi ssh và edit file, trừ mỗi chuyện đường truyền chậm. Ngoài ra việc lưu các config hệ thống trên git/github giúp thống nhất cài đặt giữa các máy với nhau. Synergy: thống nhất input của hệ thống, mình có thể điều khiển 2 workstations và 1 laptop chỉ với 1 bộ keyboard và mouse. Mobaxterm: ssh trên Windows. LogMeIn: remote máy tính. Google Chrome Remote: remote máy tính có giao diện. Git: version control. Github để share code, tuy nhiên nếu muốn private thì GitLab có vẻ tiện hơn, tuy nhiên GitLab lại có nhiều tính năng hơi thừa.  [Một bài tạp nham sau khi nộp xong NIPS, tự hứa với lòng không viết thêm bài tạp nham như thế này nữa]\n","href":"/vi/docs/research_agile_method/","title":"Làm nghiên cứu theo phong cách Agile"},{"content":"Trong một ngày rảnh rỗi giữa hai đợt deadlines và trong cái không khí ảm đạm do mùa mưa sắp tới của Singapore, tôi đã quyết định ngồi chơi cái game mà hồi nhỏ mà không hiểu gì: Bioshock. Tuy nhiên lần này tôi lại chơi bản Bioshock Infinite. Để nói về game này, tôi không gọi đó là chơi game, đó là một trải nghiệm.\n  Với cốt truyện lôi cuốn cùng với những chủ đề lồng vào nhau nhuần nhuyễn, Bioshock Infinite mang đến người chơi một thành phố Columbia steampunk với bề ngoài hào nhoáng, sung túc, và hạnh phúc. Nhưng đằng sau đó là sự phân biệt chủ tộc, chủ nghĩa da trắng cực đoan, chủ nghĩa cộng sản và một xã hội bị thao tóm bởi sự cai trị tập trung lẫn về chính trị lẫn tôn giáo. Chưa dừng lại ở đó, Bioshock Infinite còn kết hợp với yếu tố khoa học viễn tưởng như vật lý lượng tử, du hành đa vũ trụ và du hành thời gian. Điều tạo nên Bioshock đặc biệt, mặc dù mang trong miình rất nhiều chủ đề khác nhau, là cùng với rất nhiều cao trào, thắt nút, lẫn những vấn đề xã hội phức tạp, các nhà làm game vẫn cho ra được một cốt truyện mạch lạc và đầy hấp dẫn. Nếu bạn yêu thích những bộ phim xoắn não như Memento, Inception, Donnie Darko, Mr.Nobody và đặc biệt là Predestination, thì Bioshock là một trải nghiệm hoàn toàn xứng đáng.\nTôi từng nhận định rằng, game không chỉ là phương tiện giải trí, mà đó còn là phương tiện nghệ thuật. Nếu ta theo dõi các nhà đạo diễn game như Hideo Kojima, Ken Levine, ta sẽ cảm nhận rõ ràng cảm hứng nghệ thuật, chủ đề lẫn cách tiếp cận người chơi để mang đến một câu chuyện lôi cuốn. Với cách nhìn nhận này, video game trở thành bước tiến của điện ảnh truyền thống. Đó chính xác là điều mà Hideo Kojima đã tạo ra với bộ Metal Gear. Và đồng thời, ta cũng thấy một xu hướng gần đây rằng rất nhiều game có sự tham gia của các đạo diễn, biên kịch nổi tiếng từ Hollywood.\nNhưng trái tim của cả Bioshock Infinite là Elizabeth, là cách xây dựng trí tuệ nhân tạo (AI) lồng vào trong một cốt truyện, là cách mà developer tạo ra sự tương tác giữa AI và người chơi và cách AI tương tác với môi trường. AI, đó cũng chính là một trong những yếu tố phân biệt video game với các loại hình nghệ thuật khác. Chỉ cần Irrational Games tạo ra 1 Elizabeth với 1 tương tác AI ngượng ngùng, và cứng ngắt, họ đơn giản là phá hỏng toàn bộ công sức với game của mình.\nTôi đánh giá rất cao AI của nhân vật trong Bioshock Infinite hơn hẳn những game có cốt truyện hấp dẫn tương đương. Ví dụ là Witcher, mặc dù Witcher có cốt truyện lôi cuốn, nhưng tương tác giữa người chơi và các nhân vật chính khá đơn điệu, tất cả bị đơn giản hóa thành các đoạn đối thoại. Trong khi đó nhân vật Elizabeth không chỉ đồng hành cùng người chơi, mà còn tạo ra các chiến lược hoàn toàn khác nhau, đồng thời hỗ trợ người chơi trong quá trình combat. Nhưng thực ra, ta không thể trách các game thế giới mở có tương tác AI nghèo nàn, vì có quá nhiều tác nhân [agent] mà AI cần phải tương tác, và developer không thể if else cho từng trường hợp. Đó là lúc ta cần reinforcement learning =]] LOL. Nghiêm túc nào,\nHọc tăng cường là gì?, Theo wiki tiếng Việt, ta có:\n \u0026ldquo;là một lĩnh vực con của học máy, nghiên cứu cách thức một agent trong một môi trường nên chọn thực hiện các hành động nào để cực đại hóa một khoản reward nào đó về lâu dài. Các thuật toán học tăng cường cố gắng tìm một chiến lược ánh xạ các trạng thái của thế giới tới các hành động mà agent nên chọn trong các trạng thái đó.\u0026rdquo;\n Vâng chính xác đó là điều ta cần làm để có thể có AI tốt trong game thế giới mở. Mỗi AI cho học 1 thuật toán reinforcement learning để có thể tương tác tốt hơn với môi trường.\nThực ra mấy đoạn xàm kia để cho khớp với cái tiêu đề đầy tính clickbait. Hết câu chuyện về reinforcement learning.\nTa quay trở lại với vấn đề làm thế nào để tạo sự liên kết giữa AI và người chơi lẫn môi trường. Một cách để giải quyết đó là định nghĩa các primitive elements trong game, và cho NPC tương tác thông qua yếu tố đó thay vì trực tiếp với từng agent trong game. Thay vì cho NPC tương tác trực tiếp với đơn vị X trong game, ta cho NPC tương tác khi NPC thấy có nổ súng, thấy có cháy, hoặc các yếu tố liên quan. [Dĩ nhiên, ta có thể làm chiều ngược lại, apply các kĩ thuật phát triển AI trong gaming sang machine learing, ví dụ như kỹ thuật Goal Oriented Action Planning hay Behaviour Trees chẳng hạn. Dù sau, những giới hạn AI trong game về data, tính toán xử lý nghiêm ngặt hơn nhiều trong machine learning]\nVideo của Mark Brown giải thích rõ về các tương tác AI trong game, và nếu xem kỹ, thì đó cũng chính là các vấn đề trong reinforcement learning\n  Nhưng còn một yếu tố còn quan trọng hơn, đó là tạo ra một AI với cốt truyện, có tính cách và có sự độc nhất. Nếu không có một cốt truyện, hay backstory liên kết với người chơi, cho dù AI có rất thông minh, thì người chơi cũng không đặt cảm xúc vào AI đó. Đó là lí do Elizabeth là một điển hình của AI xuất sắc. Cốt truyện được xây dựng để bạn càng ngày càng quan tâm đến hành trình của Elizabeth, đồng thời tìm hiểu mối quan hệ của cô với phần còn lại của câu chuyện. Tính độc đáo tạo nên kí ức về AI cho người chơi. Elizabeth có một sức mạnh phi thường: du hành giữa các vũ trụ, điều khiển thời gian [giống Ciri phết =]] ] nhưng cô cũng vô cùng ngây thơ và đầy cảm xúc [vì bị nhốt trong tòa tháp gần 20 năm và không biết gì ngoài đọc sách và học cách mở khóa, và một ước mơ được đến Paris]. Thông qua đó ta thấy các yếu tố có mối quan hệ hữu cơ với nhau: một nhân vật độc đáo tạo nên kí ức với người chơi, một cốt truyện đi kèm tạo nên mối quan tâm về AI, và tương tác AI tốt tạo sự gắng bó với người chơi. Thông qua các yếu tố trên người chơi lại càng ấn tượng với AI trong tựa game mình trải nghiệm.\nĐó là điều tạo nên AI. Game: 9/10. Điểm trừ ở mặt combat, mình phải config lại keyboard giống với Doom. Và đồng thời không có sự balance giữa các vũ khí. Cốt truyện, nhân vật, graphics optimization: 10/10.\n","href":"/vi/docs/bioshock_infinite/","title":"Bioshock: Elizabeth hay học tăng cường [Reinforcement Learning]"},{"content":"Đây là cuộc hành trình của mình tìm về bản chất của câu chuyện overfiting, underfitting và các khái niệm lung tung xung quanh như bias-variance tradeoff.\nTài liệu tham khảo chính được lấy từ 2 cuốn sách:\n Abu-Mostafa, Yaser S., Malik Magdon-Ismail, and Hsuan-Tien Lin. Learning from data. Vol. 4. New York, NY, USA:: AMLBook, 2012. Friedman, Jerome, Trevor Hastie, and Robert Tibshirani. The elements of statistical learning. Vol. 1. New York: Springer series in statistics, 2001.  Nếu ai đó nói về hiện tượng overfitting, người nào học machine learning nghiêm chỉnh sẽ nói overfitting là khi mô hình có low bias và high variance. Trong khi đó thì underfitting là khi mà mô hình có high bias và low variance. Tuy nhiên, 2 khái niệm quái quỷ này xuất phát từ đâu.\nTa quay trở lại với câu chuyện về machine learning, mà theo bản thân mình, đây chính là \u0026ldquo;thống kê hiện đại\u0026rdquo;. Nào bắt đầu.\nĐặt bối cảnh là học có giám sát (supervised learning), ta có một tập dữ liệu input và đồng thời thông tin được gán nhãn $(x, y)$. Trong đa số các thuật toán học giám sát, bản chất của các mô hình chính là việc tìm ta hàm $f(x)$ sao cho hàm này có thể xấp xỉ được y. Bởi ta không thể lấy toàn bộ mẫu của không gian x, nên ta không thể xây dựng chính xác được $f(x)$, đó là lí do ta gọi $f(x)$ là xấp xỉ.\nTuy nhiên, nếu giả sử vì 1 điều nhiệm màu nào đó, và với 1 mô hình huyền bí nào đó, ta thực sự có được $F(x)$, tức với mọi $x$, $F(x)$ tính chính xác được $y$. Tuy nhiên ta có 1 điều cần lưu ý, bởi sự gán nhãn, hay y, không phải luôn luôn đúng, nên thay vì $y = F(x)$, ta có:\n$$y = F(x) + eps$$\nVới eps là nhiễu với mean = 0, variance = $\\sigma^2$.\nVà giờ đây là lúc điều kì diệu bắt đầu xuất hiện. Trong đa số các mô hình giám sát, ta muốn tối thiểu độ lỗi của hàm xấp xỉ $f(x)$ và nhãn của dữ liệu. Một độ lỗi phổ biến chính là MSE, ta muốn tối ưu kỳ vọng của MSE này (lý do dùng kỳ vọng bởi ta tính MSE thông qua tập dữ liệu có trong tay):\n$MSE = E[ (y - f(x)) ^ 2]$ , giờ là lúc trò mèo khai triển bắt đầu, để cho gọn thì $f(x) = f$, và $F(x) = F$. Bởi $F$ xác định (bởi đây là hàm duy nhất và tính chính xác quan hệ của x, y), nên $E[F] = F$. Đồng thời ta có $E[y] = E[F(x) + eps] = E[F(x)] + E[eps] = F + 0 = F$.\nCông thức quan trọng nhất trong các khai triển sau: $Var[A] = E[A^2] - E[A]^2$. (*)\nTa cũng có biểu thức sau:\n$$ Var[y] = E[(y - E[y])^2] = E[(F + eps - F)^2] = E[eps^2] = Var[eps] +E[eps]^2 = Var[eps] = \\sigma^2 $$\n$$ MSE = E[ y^2 - 2yf + f^2] = E[y^2] + E[f^2] - E[2yf] $$\n$$ = Var[y] + E[y]^2 + Var[f] + E[f]^2 - 2yE[f]$$ (Công thức * và y deterministic). $$= \\sigma^2 + Var[f] + E[f]^2 - 2FE[f] + F^2$$ (bình tĩnh khai triển) $$= \\sigma^2 + Var[f] + (F - E[f])^2$$ $$= \\sigma^2 + Var[f] + Bias^2$$\nTạm thời bỏ qua nhiễu của nhãn, ta có 2 hạng tử:\n Variance: độ biến thiên của mô hình đề xuất, hay trực quan hơn là độ di chuyển của mô hình đề xuất xoay quanh kỳ vọng của nó. Nếu ta có rất nhiều data, và cố gắng fit toàn bộ data đó, một cách nào đó f của ta phải di chuyển rất nhiều dẫn đến variance cao.\n Bias: khoảng cách giữa kì vọng của mô hình đề xuất và mô hình \u0026ldquo;thật sự\u0026rdquo;. Đây chính là chi phí của việc ta đã \u0026ldquo;đơn giản hóa\u0026rdquo; mô hình thực sự F.\n  Và giờ ta có thể thực sự hình dung một cách \u0026ldquo;trực quan\u0026rdquo; mô hình của mình thực sự tốt thế nào.\nNếu ta cố gắng fit mọi điểm trong data đang có, ta sẽ khiến bias nó thực sự thấp (bởi dùng rất điểm ra kq chính xác, nó sẽ rất gần với F \u0026ldquo;thực sự\u0026rdquo;), nhưng đồng thời đây variance lên cao, hiện tượng overfitting xuất hiện. Điều ngược lại của sẽ dễ thấy, nếu ta dùng quá ít data, f sẽ di chuyển ít (variance thấp), tuy nhiên f ta ước tính sẽ rất xa F thực sự (bias cao).\nĐiều này giúp ta trực quan hơn về các mô hình học:\n Linear Regression: ta đã \u0026ldquo;giả sử\u0026rdquo; F thần bí là linear, 1 giả sử quá phiêu và đơn giản, và do đó \u0026ldquo;chi phí\u0026rdquo; nó sẽ rất cao dẫn đến bias của linear regression sẽ cao. Tuy nhiên, vì ta không cố fit chính xác toàn bộ data point dẫn đến variance sẽ thấp. KNN: kNN cố gắng fit toàn bộ data nó đang có (với k càng lớn) dẫn đến bias nó sẽ về 0, nhưng càng lấy nhiều k, độ biến động của f càng cao dẫn đến variance cao.  Biết được bản chất của bias và variance, ta có thể phân tích \u0026ldquo;trực quan\u0026rdquo; mô hình đề xuất, qua đó có cái nhìn chính xác hơn với mô hình.\n","href":"/vi/docs/overfitting/","title":"Overfitting là cái quái gì"},{"content":" Trong bài viết này, mình sẽ trình bày cách cấu hình thư viện OpenCV với IDE Android Studio phiên bản mới nhất (3.0.1). Phiên bản được biên dịch sẵn có hỗ trợ Android được cung cấp sẵn ở OpenCV Homepage. Tải và extract thư viện. Đồng thời, để có thể debug trên thiết bị thực thì điện thoại phải cài đặt ứng dụng OpenCV Manager.\nTrong bài viết khác, mình sẽ hướng dẫn cách biên dịch phiên bản OpenCV với các tùy chỉnh của riêng cho từng yêu cầu, ví dụ như sử dụng đặc trưng SIFT hoặc các thuật toán có bản quyền.\nTạo ứng dụng Android với hỗ trợ NDK Trong menu, File-\u0026gt;New-\u0026gt;New Project, và chọn Include C++ support trong cửa sổ Create New Project.\n  Step 1   Hai bước tiếp theo tương tự như cấu hình ứng dụng thông thường, nên mình sẽ bỏ qua phần này. Sau đó, IDE sẽ hỏi cấu hình C++ cho ứng dụng, thoe mình thì nên chọn C++14 và 2 tùy chọn Exception Support và Runtime Type Information Support.\n Từ cửa sổ Project Structure (File -\u0026gt; Project Structure), ta thêm OpenCV module bằng cách click vào dấu +, chọn Import Eclipse ADT Project và trỏ đến thư mục /path/to/OpenCV4Android/sdk/java.\n Chọn Modules -\u0026gt; app. Trong tab Dependencies , thêm OpenCV module bằng cách nhấn vào dấu +\n Module Dependency. Chọn :openCVLibrary340.     Add openCVLibrary340   Cấu hình CMAKE và NDK Để CMAKE có thể nhận ra được OpenCV, ta thêm đoạn code sau vào trong CMakeLists.txt\n Thêm thư viện:  include_directories(/path/to/OpenCV4Android/sdk/native/jni/include) add_library( lib_opencv SHARED IMPORTED ) set_target_properties(lib_opencv PROPERTIES IMPORTED_LOCATION /path/to/OpenCV4Android/sdk/native/libs/${ANDROID_ABI}/libopencv_java3.so)   Thêm lib_opencv vào tham số của target_link_libraries ( câu lệnh cuối cùng trong CMakeLists.txt).  Lưu ý rằng Cmake sử dụng / cho đường dẫn trong cả Windows và Linux.\nCấu hình Gradle  Thêm abiFilters 'x86', 'x86_64', 'armeabi', 'armeabi-v7a', 'arm64-v8a', 'mips', 'mips64' vào cmake.\n Đặt đoạn code sau vào bên trong phần android:\n  sourceSets { main { jni.srcDirs = ['src/main/cpp'] jniLibs.srcDirs = ['\\path\\to\\OpenCV-android-sdk\\\\sdk\\\\native\\\\libs'] } }  Build lại ứng dụng và coi như ta đã config xong. Trong các bài viết tới, mình sẽ giới thiệu một số kỹ thuật OpenCV với Android:\n Trao đổi đối tượng Mat giữa Java và NDK. Tổ chức dự án và mã nguồn.  ","href":"/vi/docs/opencv_android_studio_ndk/","title":"Cài đặt OpenCV trên Android Studio hỗ trợ lập trình NDK"},{"content":"Nhiều khi tôi chỉ muốn xem đi xem lại phân cảnh Geralt gặp lại Ciri. Ít có khi nào một video game lại khiến bản thân nhập tâm vào nhân vật đến vậy. Cách mà CDPR đã tiếp cận với thế giới của Witcher khiến người chơi cảm thông và đi sâu vào tâm lý nhân vật.\n  Không bàn đến việc yếu tố điện ảnh, kỹ thuật cắt cảnh đã giúp phân đoạn này đáng nhớ và xuất sắc, thì một yếu tố làm nên chi tiết Geralt và Ciri hội ngộ thêm phần xúc động đó là xây dựng nhân vật trong game.\nCách CDPR làm là gì? Họ xây dựng thế giới fantasy đẹp lộng lẫy với chủ đề xoay quanh quái vật với thế giới Trung Cổ nơi mà yếu tố đạo đức không phân định. Và rồi họ đặt Geralt vào trong đó. Khác với cách mà Fallout từng làm, Fallout 4 thì cốt truyện được xây dựng trước với thế giới của một lịch sử thay thế, điều đó khiến cho người chơi Fallout không có nhiều động lực để xây dựng cho họ \u0026ldquo;nhân vật\u0026rdquo; có cốt truyện mà thay vào đó là tìm hiểu thế giới xung quanh bởi hầu như cốt truyện bị cố định và không có nhiều không gian để khám phá nhân vật. Điều mà dòng Fallout, cùng với Skyrim làm cực kì tốt. Đội ngũ thiết kế Witcher đưa ra 1 câu hỏi rất cụ thể: \u0026ldquo;trong thế giới fantasy này, người chơi muốn họ trở thành một Geralt như thế nào?\u0026rdquo;. Một chi tiết thú vị là việc xây dựng Geralt không tới mức mạnh khủng khiếp và late game trở nên bất khả chiến bại muốn làm gì thì làm, rốt cuộc Geralt chỉ là 1 witcher - một kẻ săn quái vật, một ngành nghề như bao người khác, và vẫn bị lính trong thành chém không thương như những dân thường khác.\nHơn hết, nếu so sánh về độ \u0026ldquo;bá đạo\u0026rdquo; trong trong cốt truyện. Tôi đánh giá cao Witcher 2 hơn, khi mà nội dung có sự tham gia của các thế lực chính trị, thuyết âm mưu và sự can thiệp của Geralt ảnh hưởng đến kết cục của cuộc chiến. Đồng thời, ta cảm nhận sâu sắc hơn cái không khí chiến tranh Trung Cổ trong phần này.\nWitcher 3 đào sâu vào phát triển nhân vật, mà cụ thể hơn là cuộc hành trình để người chơi hiểu được mối quan hệ của Geralt và Ciri để sau đó cho người chơi sử dụng ngòi bút của chính mình để quyết định đoạn kết của câu chuyện.\nĐiều thú vị là quá trình phát triển nhân vật và cốt truyện người chơi lại được đúc kết thành tinh hoa bởi một nhân vật giả tưởng: tiến sĩ Robert Ford trong phim Westworld.\n “It’s not about giving the guests what you think they want. No that’s simple. The titillation, horror, elation—they’re parlor tricks. The guests don’t return for the obvious things we do, the garish things. They come back because of the subtleties, the details. They come back because they discover something they imagine no one had ever noticed before… something they’ve fallen in love with. They’re not looking for a story that tells them who they are. They already know who they are. They’re here because they want a glimpse of who they could be.\u0026rdquo; - Dr. Robert Ford\n   Người chơi cảm thấy hứng thú bởi vì bởi vì thông qua nhân vật Geralt và các mối quan hệ xung quanh, họ thấy được một con người khác mà họ có thể trở thành trong một thế giới huyền ảo. Đó là đỉnh cao của xây dựng một trò chơi open world. Người chơi không cần số lượng vô hạn các lựa chọn, cái họ cần đôi khi chỉ là 2 lựa chọn đủ để định hình một con người. Trong Witcher, ta thấy rõ nhất là sự lựa chọn tình cảm giữa Yennefer và Triss. Không có lựa chọn nào sai, và không có lựa chọn nào tốt hơn hay xấu hơn lựa chọn nào, chỉ đơn giản sự lựa chọn ánh xạ quan điểm của người chơi. Trong clip phân tích của Extra Credits cho ta thấy cái nhìn cụ thể hơn.\n  Nhân vật Geralt không chỉ phát triển thông qua cốt truyện chính hay phần romance mà còn được xây dựng thông qua việc tương tác với các vấn đề xung quanh: yếu tố chính trị (mặc dù không còn quá nhấn mạnh như trong Witcher 2), các quyết định với các nhân vật phụ xung quanh. Điểm thú vị trong 1 game open world nằm ở 2 điều:\n Cung cấp cho người chơi một thế giới giả tưởng. Cung cấp cho người chơi một tuyến nhân vật do họ tự xây dựng.  Điều 1, Bethesda làm rất tốt, điều 2, Bioware là tiên phong. Nhưng với CDPR, họ đã gây dựng nên yếu tố cốt truyện thú vị hòa quyện vào một thế giới mở. Họ chắc chắn không phải là tiên phong, nhưng lại là studio sử dụng hiệu quả nhất yếu tố xây dựng nhân vật.\nMột điểm thú vị trong Witcher 3 đó là, bản đồ trong phần này lớn gấp 40 lần so với bản Witcher 2 và đồng thời lớn hơn thế giới trong Skyrim 15%, làm sao họ có thể lấp đầy thế giới này với thiên hướng \u0026ldquo;kể truyện\u0026rdquo; hơn là \u0026ldquo;khám phá\u0026rdquo;. Ở đây Witcher có lợi thế hơn dòng Skyrim hay Fallout, họ đã có sẵn một thế giới do nhà văn Andrzej Sapkowski tạo ra, đồng thời, với bối cảnh trung cổ tại Scandinavian họ dư sức thả vào đó rất nhiều egg easter từ thần thoại Bắc Âu (trong đảo Skellige), Game Of Throne (rải rác khắp các maps), hay các biểu tượng văn học, văn hóa đại chúng.\n  Witcher 3 đối xử người chơi trưởng thành một cách \u0026ldquo;trưởng thành\u0026rdquo;. Họ không ngại cho các yếu tố gai góc, \u0026ldquo;người lớn\u0026rdquo; vào trong game, mà hơn hết là lồng ghép để người chơi được thể hiện quan điểm của họ thông qua nhân vật. Đó chính là quan hệ tình cảm, là phân biệt chủng tộc, là chính trị, là những giá trị đạo đức. Tôi đã rất trượng nghĩa khi cứu 1 she-elf không bị bắt nạt, và cuối cùng là sao, con nhỏ sang chửi tôi và nói rằng \u0026ldquo;chị éo cần mày\u0026rdquo; (dù chỉ là 1 quest tình cờ tôi chạm phải). Hay giữa việc cứu những đứa trở vô tội hay cứu gia đình Baron, hay giữa việc cứu hay không cứu Mirka. Có đến hàng chục tình huống được thể hiện trong game, dần dần xây dựng để cuối cùng, người chơi là người viết nên hồi kết.\nSự tinh tế làm nên tính thu hút của cốt truyện. Người chơi không cần phải trưng ra những điều rõ ràng để hiểu vấn đề trong cốt truyện. Nếu trong một game đã đề cập đến những thứ gai góc, thì người thiết kế hiểu rõ rằng người chơi có một trình độ, sự cảm nhận nhất định và họ tự tin đặt những chi tiết tinh tế đó trong game. Đó là lí do mà tôi luôn thẩn thờ khi nghe Priscilla hát Wolven Storm, bởi bài hát nói về Geralt và Yen. Trong từng lời ca, trong tiếng hát du dương nhưng đẫm buồn về mối tình mãnh liệt của hai người. Và đặc biệt hơn, đến quest \u0026ldquo;Last Wish\u0026rdquo;, ta càng hiểu thêm về tình cảm của hai người [Dù sao thì mình chọn Triss].\n  Tổng kết, phương pháp xây dựng nhân vật của CDPR xứng đáng cho các studio khác học hỏi và thực sự là một chuẩn mực mới cho dòng Action RPG, đồng thời cũng là một use-case thú vị cho thấy một video game có thể đạt chuẩn mực nào đó với văn học. Bởi rốt cuộc, cả hai đều là phương tiện để tác giả kể về câu chuyện của mình.\n","href":"/vi/docs/story_telling_witcher3/","title":"Witcher 3: xây dựng nhân vật và phương pháp phát triển cốt truyện"},{"content":"Programing Pearls - Jon Bentley\nXuất sắc.\nChưa có một cuốn sách nào về lập trình khi tôi mua về, khui thùng của Amazon ra và lượn 1, 2 trang để thốt lên 1 từ \u0026ldquo;xuất sắc\u0026rdquo; cả. Điểm qua một số sách về \u0026ldquo;Algorithms\u0026rdquo; mà tôi từng đọc và tìm hiểu:\n CLRS: về mặt lý thuyết, đây thực sự là \u0026ldquo;introduction\u0026rdquo; nhưng đầy đủ và chi tiết. Tôi không quá ấn tượng bởi cách viết và mã giả. Algorithms, Sedgewick: một trong những cuốn tôi rất thích, code sử dụng Java và hoàn toàn chạy được, cách chứng minh về correctness và complexity dễ tiếp cận, đồng thời minh họa trong sách phải nói là ấn tượng. ĐIều làm tôi không hài lòng là giấy quá mỏng, cách viết hơi đơn điệu và tuy có sử dụng OOP nhưng không đề cập nhiều. TAoCP: hoàn toàn hàn lâm. Elements of Interview Programming: một cuốn thuần túy để luyện đi interviews.  Programming Pearls hoàn toàn ngược lại, đây là cái nhìn của 1 engineer về sử dụng thuật toán trong công việc và giải quyết các vấn đề. Hay đúng hơn là cuộc hành trình của Jon Bentley. Dĩ nhiên Jon Bentley quá nổi tiếng là tác giả kd-tree, nhưng trước đây ông còn là \u0026ldquo;thánh review code\u0026rdquo; khi có khá nhiều người gửi code để ông đánh giá [có cả Knuth khi ông đi quảng cáo Literate Programming].\nSách tuy mỏng nhưng chứa đựng đầy \u0026ldquo;ngọc\u0026rdquo;, cách viết thú vị và hài hước, xen lẫn đó là cách tiếp cận đầy khoa học, tham khảo đầy đủ và toàn diện cùng những câu đố khá hay đáng làm tài liệu luyện programming cũng như cách nhìn nhận của 1 người làm industry vào các giải thuật và cách sử dụng hiệu quả, đặc biệt là cách mà tác giả tiếp cận vấn đề, sử dụng nhuần nhuyễn các kỹ thuật để giải quyết.\nVề mặt \u0026ldquo;học thuật\u0026rdquo;, tôi nghĩ khả năng của Bentley là không bàn, nhưng đứng về mặt \u0026ldquo;engineer\u0026rdquo; thì cuốn sách này thế nào? Xin trích dẫn từ lời của Steve McConnell [tác giả Code Complete]:\n \u0026hellip; Programming Pearls was one of the most influential books I read early in my career, and many of the insights I first encountered in that book stayed with me long after I read it. \u0026hellip;\n p.s: Ít có cuốn sách lập trình nào mà tác giả tự tin nói \u0026ldquo;tao đọc hết 3 volume của TAoCP và biết khi gặp vấn đề nào thì nên tra phần nào\u0026rdquo;, và cũng ít có cuốn nào vừa tham khảo CLRS, Algorithms in C, TAoCP, Ullman\u0026rsquo;s books vừa tham khảo Code Complete, The Mythical Man-Month\u0026hellip;\n","href":"/vi/docs/programming_pearls/","title":"Programming Pearls"},{"content":" Trong dự án dài hơi về TAoCP, những phần đầu của Vol 4A.\nĐịnh nghĩa Cho một ma trận vuông có kích thước M và các phần tử thuộc $\\{0, 1, \\cdots, M-1 \\}$, ta xây dựng ma trận sao cho mỗi phần tử $i$ trong tập $\\{0, 1, \\cdots, M-1\\}$ chỉ xuất hiện đúng 1 lần trong mỗi cột và mỗi dòng.\nVí dụ Cho 16 quân bài bao gồm tổ hợp của các quân J, K, Q, A và 4 loại $\\heartsuit, \\diamondsuit, \\clubsuit, \\spadesuit$, ta sắp xếp sao cho mỗi dòng/cột có đủ 4 chất và 4 quân (Jacques Ozaman, mathematiques et physiques, Paris 1725).\n  Cách sắp xếp quân bài. Source: TAoCP, Vol 4A.   Ứng dụng Thực ra trong toán học đôi khi ta không cần một ứng dụng thực tế của một vấn đề để có động lực nghiên cứu hay tìm hiểu. Tuy nhiên, mình lại là một thanh niên học khoa học máy tính với thiên hướng \u0026ldquo;engineer\u0026rdquo; hơn là các nhà toán học cao siêu, nên mình đòi hỏi cái mình học có tính ứng dụng ít nhiều. Về khối vuông Latin này có kha khá ứng dụng:\n Sudoku là một dạng của khối vuông Latin, và trò chơi này trở thành một trong những trò chơi giải đố nổi tiếng nhất thế giới. Trong cài đặt thí nghiệm. Mã sửa lỗi. Mã hóa.  Câu chuyện lịch sử Năm 1779, một câu đố tương tự như trong phần ví dụ đã thu hút nhà toán học vĩ đại: Leonhard Euler\n Thirty-six officers of six different ranks, taken from six different regiments, want to march in a $6 \\times 6$ formation so that each row and each column will contain one officer of each rank and one of each regiment. How can they do it?\n Dù đã gần như mù nhưng Euler vẫn quyết tâm giải bài toán này và tổng quát hóa cho các trường hợp $M = 1, 2, \\cdots$. Tuy nhiên, với $M\\mod 4 = 2$ khiến ông không giải được, Sau đó ông đã đưa ra một conjenture rằng không thể giải câu đố này với trường hợp tổng quát $M \\mod 4 = 2$.\nTuy nhiên phần định nghĩa về khối Latin hơi khác 1 chút so với phần ví dụ. Nếu ta đặt $\\heartsuit = 1, \\diamondsuit = 2, \\clubsuit = 3, \\spadesuit = 4$, và tách chất và quân bài ra 2 ma trận, ta được 2 ma trận Latin.\n$$ \\begin{bmatrix} J\u0026amp; A\u0026amp; K\u0026amp; Q\\newline Q\u0026amp; K\u0026amp; A\u0026amp; J\\newline A\u0026amp; J\u0026amp; Q\u0026amp; K\\newline K\u0026amp; Q\u0026amp; J\u0026amp; A \\end{bmatrix} $$\nvà\n$$ \\begin{bmatrix} 2\u0026amp; 1\u0026amp; 4\u0026amp; 3\\newline 4\u0026amp; 3\u0026amp; 2\u0026amp; 1\\newline 3\u0026amp; 4\u0026amp; 1\u0026amp; 2\\newline 1\u0026amp; 2\u0026amp; 3\u0026amp; 4 \\end{bmatrix} $$\nFigure 1 trở thành\n$$ \\begin{bmatrix} J2\u0026amp; A1\u0026amp; K4\u0026amp; Q3\\newline Q4\u0026amp; K3\u0026amp; A2\u0026amp; J1\\newline A3\u0026amp; J4\u0026amp; Q1\u0026amp; K2\\newline K1\u0026amp; Q2\u0026amp; J3\u0026amp; A4 \\end{bmatrix} $$\nHai ma trận được gọi là orthogonal khi chập các phần tử lại với nhau, mỗi phần tử trong ma trận mới là duy nhất. Bài toán lúc đó Euler phải giải là: cho 1 ma trận Latin, làm sao để tìm được một ma trận Latin khác orthogonal với nó. Ma trận sau khi được chập lại gọi là Graeco-Latin. Để chứng minh nhận định của Euler đúng hay sai, các nhà toán học đã mất gần 180 năm với sự giúp đỡ của máy tính.\nNăm 1957, Paige và Tompkins đã thử lập trình trên máy SWAC để tìm ví dụ phản chứng khi $M=10$ nhưng sau gần 5 giờ chạy liên tục không ra kết quả, họ đã tắt chương trình.\nNăm 1960, Parker và đồng sự đã chứng minh rằng có thể tìm được 1 ma trận orthogonal với $M \\geq 6$ và phản chứng nhận định của Euler. Đồng thời, ông cũng viết 1 chương trình trên máy UNIVAC 1206 để sinh ra ma trận đó. Chương trình chưa đến 1 giờ để có thể tìm ra lời giải với cùng input năm 1957:\n0 1 2 3 4 5 6 7 8 9 1 8 3 2 5 4 7 6 9 0 2 9 5 6 3 0 8 4 7 1 3 7 0 9 8 6 1 5 2 4 4 6 7 5 2 9 0 8 1 3 5 0 9 4 7 8 3 1 6 2 6 5 4 7 1 3 2 9 0 8 7 4 1 8 0 2 9 3 5 6 8 3 6 0 9 1 5 2 4 7 9 2 8 1 6 7 4 0 3 5  Một solution trong sách:\n0 2 8 5 9 4 7 3 6 1 1 7 4 9 3 6 5 0 2 8 2 5 6 4 8 7 0 1 9 3 3 6 9 0 4 5 8 2 1 7 4 8 1 7 5 3 6 9 0 2 5 1 7 8 0 2 9 4 3 6 6 9 0 2 7 1 3 8 4 5 7 3 5 1 2 0 4 6 8 9 8 0 2 3 6 9 1 7 5 4 9 4 3 6 1 8 2 5 7 0  Transvervals Parker sử dụng lại khái niệm transversal mà trước đây Euler từng định nghĩa, transversal là cách để chọn ra chuỗi $M$ phần tử sao cho chỉ có 1 phần tử duy nhất ở mỗi dòng, mỗi cột và duy nhất trong transversal.\nVí dụ: 0859734216, tức ta chọn 0 ở cột 1, 8 ở cột 2, 5 ở cột 3, \u0026hellip; 6 ở cột 10. Giả sử ta có $k$ là giá trị đầu tiên của transversal, dựa vào giá trị từng phần tử phía sau, ta thay bằng $k$. Chọn ra $M$ transversal của $k = 0, 1, \\cdots, M-1$ ta sẽ tạo thành 1 orthogonal matrix.\nThuật toán đếm số transversal của một ma trận vuông N.\ntypedef vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; mat; class transversal { private: int n; vector\u0026lt;bool\u0026gt; row; vector\u0026lt;bool\u0026gt; nums; mat input; int cnt; public: transversal(const mat\u0026amp; in_): n(in_.size()), input(in_), row(n, false), nums(n, false), cnt(0) { assert(in_.size() == in_[0].size()); } void print() { // debugging for (auto\u0026amp; rows: input) { for (auto\u0026amp; e: rows) cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; } } int compute(int idx) { cnt = 0; fill(row.begin(), row.end(), false); fill(nums.begin(), nums.end(), false); nums[input[idx][0]] = true; row[idx] = true; comp(1); return cnt; } private: void comp(int idx) { //idx = index of column if (idx == n) { cnt++; return; } for (int i = 0; i \u0026lt; n; ++i) { if (!row[i] \u0026amp;\u0026amp; !nums[input[i][idx]] ) { row[i] = true; nums[input[i][idx]] = true; comp(idx+1); row[i] = false; nums[input[i][idx]] = false; } } } };  Lấy input từ cuốn TAoCP ra được kết quả:\n79 96 76 87 70 84 83 75 95 63  Bem, đúng với kết quả trong sách. Chỉnh sửa một chút ta có thể có được toàn bộ các transversal cần tìm. Sau đó với mỗi transversal của $k$, ta chọn ra bộ nào không có phần tử trùng (trong index của orthogonal matrix), ta sẽ tìm được ma trận. Chi tiết về phần này sẽ được đề cập trong bài viết nói về Dancing Links.\nTài liệu tham khảo  Knuth, Donald E. The Art of Computer Programming, Volume 4A: Combinatorial Algorithms, Part 1. Pearson Education India, 2011. https://en.wikipedia.org/wiki/Latin_square http://elscorcho.50webs.com/latinsquares.pdf  ","href":"/vi/docs/latin_square/","title":"Khối Latin và câu chuyện toán học và lịch sử máy tính"},{"content":"Có lẽ bản thân tôi đã ảo tưởng về khả năng của mình, thời gian gần đây mọi chuyện trở nên tồi tệ, thêm một bài báo bị reject. Như thể có gì đó ở cuốn họng mà không thể nuốt trôi được.\nCó lẽ năng lực của tôi chỉ có vậy và không thể tiến xa hơn được nữa. Hoặc cũng có thể trước giờ mọi điều tôi đạt được hoàn toàn nhờ may mắn. Học hành chả đến nơi đến chốn, nhiều lúc nhét chữ vào đầu cũng không vô được. Trước đây, sau mỗi lần bị reject, sau mỗi lần gặp vấn đề tôi đều tự nhủ với bản thân là mình có thể vượt qua được, rằng mình đã có thêm chút kinh nghiệm. Nhờ giờ đây tôi chỉ là phiên bản xuống cấp trầm trọng.\nHọc tiếng Anh thì không vô được chữ nào, phát âm thì dở tệ. Nghe và đọc lại chẳng đâu vào đâu. Học thuật toán thì quên đầu quên đuôi, code không ra thể thống gì cả. Chả có chút tương lai, chả có chút động lực. Rốt cuộc tôi tự hỏi là mình đang làm gì, hay rốt cuộc chỉ đốt thời gian trong quãng thời gian gần đây, đi làm rồi đi về, chả được tích sự gì.\nLần đầu tiên trong đời tôi có cảm giác mất phương hướng như vậy. Mọi thứ xung quanh khiến tôi có cảm giác hoàn toàn chán nản, nhiều lúc tự hỏi rốt cuộc tại sao mình lại có thể vô dụng đến mức vậy. Giờ đây đến việc đi tìm việc cũng khiến tôi có cảm giác sợ.\nSợ bị thất bại.\nThật nực cười. Tôi tưởng bản thân không còn sợ bị thất bại nữa.\nHồi nhỏ, từ cấp 1 lên cấp 2, tôi luôn là một đứa giỏi toán, vì thi học sinh giỏi huyện thì điểm không nhất cũng nhỉ. Hầu như lúc đó tôi chưa biết \u0026ldquo;sợ thất bại\u0026rdquo; là gì. Rốt cuộc đến năm lớp 9, thi học sinh giỏi điểm của tôi lại thấp nhất trong số những đứa đi thi. Hồi đó, tôi khóc như mưa. Vì sợ, vì cảm thấy bản thân tổn thương bởi sự tự cao của mình.\nHồi đại học, chưa bao giờ tôi sợ mình thất bại điều gì. Thật ra mà nói, có quá nhiều học bổng nộp bị đánh rớt, có quá nhiều cuộc thi tham gia chả đạt giải gì cả, có những môn học đi học lại 2, 3 lần. Lúc nào, tôi cũng cố gắng tìm một yếu tố hài hước nào đó trong thất bại của mình để tự \u0026ldquo;mua vui\u0026rdquo; bản thân trước khi nghiêm túc nhìn nhận sự việc. Lúc đó với tôi, mọi thứ là một bài học.\nGiờ đây, tôi lại \u0026ldquo;sợ\u0026rdquo; và cảm nhận thấy bản thân không đủ khả năng làm bất cứ điều gì. Tôi nghe đồn có cái gọi là khủng hoảng tuổi 25. Chả biết có phải là khủng hoảng không, kệ thây nó đi.\nỪ thì kệ thây nó đi.\n","href":"/vi/docs/who_am_i/","title":"Tôi là ai"},{"content":" Edition: Pre-fascicle 1A (Revision -99).\n[Đã lâu rồi mình không viết blog, nhưng phải chờ đợi đến một thời điểm chính muồi thì mình mới có thể viết được một bài tâm huyết với chất lượng cao. Hi vọng thông qua bài viết này, các bạn có hứng thú với Thị Giác Máy Tính (TGMT - hoặc CV - Computer Vision) sẽ có thêm động lực và biết được thêm nhiều thông tin về một hướng nghiên cứu khá hấp dẫn này.]\nGiới thiệu Bởi TGMT là một hướng nghiên cứu liên quan đến khá nhiều lĩnh vực khác nhau, đặc biệt là sinh học, khoa học nhận thức, khoa học máy tính, toán học, vật lý; chính điều đó lịch sử của TGMT được xem xét bởi các mốc thời gian khác nhau tùy theo ý kiến của tác giả. Phần dưới được mình tổng hợp từ “timeline” của hai nhà nghiên cứu nổi tiếng là “cô cô” Fei-Fei Li và sư tổ Szeliski thông qua các bài giảng [1] và sách giáo trình [1]. Có thể hiểu ngành TGMT là một nhánh con của trí tuệ nhân tạo (Artificial Intelligence - AI) trong thời kì đầu - những năm 1950s, một trong những mục tiêu tối thượng của AI chính là có thể giả lập được trí tuệ của con người. Đó là đối với AI, CV cũng không phải ngoại lệ; các bài toán trong CV cũng nhằm giải quyết bài toán làm thế nào một hệ thống thị giác có khả năng hiểu và thao tác với hình ảnh giống như cách một hệ thống thị giác sinh học làm được.\nVậy làm thế nào một hệ thống thị giác sinh học có thể quan sát, hiểu được những hình ảnh mà cơ quan cảm thụ (mắt) thu nhận được? Câu hỏi đặt ta phải tìm hiểu về quá trình cơ chế này được phát triển trong tự nhiên và những nghiên cứu về não bộ nhằm hiểu được cơ chế hoạt động của một trong những giác quan quan trọng của cơ thể. Thông qua những tìm hiểu này, đã có nhiều bước tiến diễn ra trong các ngành khác nhau như Vật Lý, Sinh Học, Toán Học, và sau này Trí Tuệ Nhân Tạo.\nPre-computer vision 543 triệu năm trước Công Nguyên   Vụ nổ Cambrian, nguồn: Papermasters   Đây là thời kì “Big Bang của tiến hóa sinh học”, trước thời điểm này các sinh vật hiện diện trên Trái Đất rất hạn chế. Và đột nhiên, như vụ nổ Big Bang, bỗng xuất hiện sự bùng nổ các sinh vật hiện diện tràn ngập trên Trái Đất. Dựa trên các bằng chứng khảo cổ học, nhiều giả thuyết được đặt ra nhằm giải thích cho hiện tượng này. Có thể một thiên thạch chứa mầm sống ngoài vũ trụ đã mang đến các vi sinh vật, hay có chăng sự biến đổi thời tiết và môi trường dẫn đến sự bùng nổ các giống loài. [Những giả thuyết này về sau được đưa vào văn học, điện ảnh khá nhiều. Đồng thời cũng có nhiều nghiên cứu tập trung đến hướng này, đọc thêm: Cosmos - Carl Sagan]\nCác nhà sinh vật gọi đây là “vụ nổ kì Cambrian”, chỉ trong một thời gian ngắn, một loạt các sinh vật với cơ thể phức tạp và cấu trúc mới xuất hiện. Một giả thuyết quan trọng được đưa ra chính là sự xuất hiện của cơ quan thị giác, lần đầu tiên có một sinh vật có thể tương tác với môi trường xung quanh. Các sinh vật này không còn thụ động với môi trường nữa; cũng chính bởi điều đó thúc đầy loài săn mồi và con mồi thúc đẩy khả năng cảm nhận của mình, dẫn đến các sinh vật ở thời kì này phát triển cơ chế tương tác với môi trường. Một dẫn chứng quan trọng của giả thuyết này chính là đây là thời kì sớm nhất mà các nhà khoa học có thể tìm thấy cơ quan “thị giác” trong các hóa thạch.\nChính nhờ sự phát triển của cơ quan thị giác, mà sau tất cả bước tiến hóa đến tận bây giờ, hệ thống này đã giúp cho các sinh vật có thể tồn tại, điều hướng, thao tác với môi trường xunh quanh. Đó cũng chính là mục tiêu của các nhà nghiên cứu AI trong giai đoạn đầu hình TGMT: làm thế nào hệ thống AI có thể tồn tại, điều hướng, tao tác với môi trường tác nhân tác nhân (agent)1.\nThế kỉ 16 - Camera Obscura - Leonardo da Vinci   Camera Obscura and a painter. Nguồn: Không rõ.   Trong suốt lịch sử, loài người đã dần dần phát minh những thiết bị có thể nắm bắt được những gì trông thấy. Những phát kiến được phát minh ở Trung Quốc, Hi Lạp và các nền văn minh khác. Tuy nhiên đến tận thế kỉ 16, Leonardo da Vinci là người đầu tiên có những ghi chú cụ thể và chi tiết về công cụ này - mà sau này ta gọi là “camera”.\n  Ghi chép của Leonardo da Vince về mắt người.   Trong các tài liệu của mình, Leonardo đã sử dụng cơ chế “pin hole” để mô hình hóa cách camera ghi lại khoảnh khắc xung quanh. Đồng thời ông cũng dùng cơ chế này để tìm hiểu cách hoạt động của mắt người. [Chi tiết về cuộc đời và các công trình của Leonardo da Vinci, cuốn Leonardo da Vinci của Walter Isaacson rất đáng đọc.].\nCũng từ sau giai đoạn này, nhiều phát minh đã xuất hiện. Và ngày nay, “camera” trở thành một phần không thể thiếu trong cuộc sống hiện đại. Thống kê năm 2016 có thấy số lượng cảm biến hình ảnh còn nhiều hơn dân số Trái Đất. Tuy nhiên, việc phát minh ra camera, cũng như các ghi chú của Leonardo chỉ dừng lại mức sao chép thế giới thị giác. Lúc này một camera vẫn chưa hiểu được những gì mình thu nhận được.\n1959: Hubel \u0026amp; Wiesel Làm thế nào con người có thể hiểu được những gì đôi mắt nhìn thấy? Cơ chế hoạt động của não bộ khi bắt được tín hiệu hình ảnh? Những câu hỏi này không ngừng thúc đẩy các nhà khoa học tìm hiểu vấn đề này.\n  Nghiên cứu đạt giải Nobel năm 1981 này được thực nghiệm trên những chú mèo nhằm tìm câu trả lời cho câu hỏi về thị giác trong não bộ. Các nhà khoa học đã gắn các thiết bị ghi nhận tín hiện mỗi khi phần não (primary visual cortex) kích ứng với các sự thay đổi hình ảnh. Khi thử nghiệm với các hình ảnh như cá, thịt, hoa … hầu như não mèo không kích ứng tín hiệu nào. Lúc đó các nhà khoa học hầu như thất vọng với kết quả thu được. Nhưng điều lạ lùng là họ thấy các tín hiệu được kích ứng mỗi khi họ thay đổi tấm phim. Và sau đó, kết luận được đưa ra là tiền đề cho các nghiên cứu sau này của TGMT: tín hiệu não chỉ kích ứng với sự chuyển động của các cấu trúc cơ bản (biên, cạnh). Sau này, trong deep learning, kết quả visualize của tầng conv cũng cho kết quả tương tự.\nĐiều thú vị của não bộ về xử lí thị giác: não bộ cần khá nhiều phần trăm cơ quan của mình để có thể “hiểu” những gì mắt ghi nhận được (gần 50% thể tích não), và bộ phần này (visual cortex) nằm phần phía sau của não bộ. Có thể hiểu rằng đây là tác vụ khó nhất mà não bộ cần phải làm.\nTrong các bài viết sau, mình sẽ đề cập đến những tiến triển của hướng nghiên cứu này trong giai đoạn 1950-1960, khi mà AI trở thành một hướng nghiên cứu năng động và sôi nổi thời bấy giờ.\n Có một mối quan hệ mật thiết với Học Tăng Cường (Reinforcement Learning) [Có lẽ mình cần đề cập một chút ở đây] ^   ","href":"/vi/docs/compvision_hist/","title":"Lịch sử Thị Giác Máy Tính - Phần 1"},{"content":" Một chút thông tin về cuốn sách trước khi mình đánh giá:\n   Thông tin Mô tả     Tiêu đề Selected Papers on Computer Science [Amazon]   Tác giả Donald Knuth   Số trang 276    Đây là một trong những cuốn sách dễ tiếp cận nhất của Don Knuth. Tuy được xuất bản cách đây khá lâu (gần 20 năm về trước), nhưng đây là một trong những cuốn sách kinh điển dẫn nhập về KHMT. Trên trang Amazon có bình luận khá hay của Peter Norvig (giám đốc nghiên cứu của Google). Một trong những vấn đề được thảo luận nhiều trong sách chính là sự ra đời bộ môn KHMT ở giai đoạn khi ngành nghiên cứu còn khá mới mẻ. Thông qua các chương sách, ta có thể thấy thời đó các bậc tiền bối đã đấu tranh rất nhiều để KHMT có thể được công nhận là một môn \u0026ldquo;khoa học\u0026rdquo; chính thống và tách biệt với toán học.\nĐiều này khiến mình liên hệ với Deep Learning hiện giờ, dễ có khi vài năm sau, với sự bùng nổ và phát triển của hướng nghiên cứu này, Deep Learning sẽ trở thành một ngành riêng biệt và không còn nhập nhằng với KHMT. Nếu như khi xưa KHMT \u0026ldquo;tách ra\u0026rdquo; khỏi Toán học, thì biết đâu 5, 6 năm nữa, Deep Learning sẽ \u0026ldquo;tách\u0026rdquo; ra khỏi KHMT.\nMột số chương đặc biệt thú vị, có thể kể đến như:\n Chapter 0: cái nhìn toàn cảnh nhất về KHMT. Chapter 1: Computer Science and its Relation to Mathematics: sự khác nhau giữa toán học hiện đại và KHMT. Đồng thời tác giả cũng đề cập đến phân tích bài toán kinh điển: hashing. Chapter 2 và Chapter 3: cái nhìn toàn cảnh về các thuật toán, cũng như cách tác giả tiếp cận để giải các vấn đề. Dù được xuất bản lần đầu 1976, 1977 có thể trong giai đoạn đó khá là mới, nhưng theo mình những bài toán này (đường đi ngắn nhất, tìm kiếm, tối ưu rời rạc) trở thành chủ đề kinh điển trong KHMT hiện nay. Chapter 6-9: Theory and Practice: tinh hoa của cả cuốn sách, vừa mang yếu tố lịch sử, xoay quanh những thảo luận sôi nổi về 2 khía cạnh quan trọng nhất của KHMT. Chapter 11-13: Lịch sử KHMT: từ KHMT cổ điển (những thuật toán được sử dụng vào thời kì rất xa xưa), đến KHMT hiện đại khi John von Neumann phân tích về thuật toán merge sort.  Mình dành phần chi tiết nội dung cho bạn nào tìm đọc sách. Mình nghĩ ở Việt Nam thì cuốn này tương đối khó kiếm, nhưng những chương rời rạc có thể tìm được ở trang Publications của Don Knuth. Dưới đây mình thảo luận về chủ đề xoay quanh cuốn sách.\nToán học và KHMT Khi đọc cuốn sách này, người đọc sẽ cảm nhận được giai đoạn 1950-1975 có lẽ là thời kì bùng nổ của KHMT (có lẽ rất giống Deep Learning hiện giờ). Vào thời điểm đó giống như giai đoạn \u0026ldquo;mông muội\u0026rdquo; của KHMT vậy, các trường ĐH danh tiếng không dám mở 1 khoa riêng mang tên KHMT, thiên hạ vẫn tranh nhau gọi ngành mới này nên là KHMT, CNTT hay \u0026ldquo;Xử lý thông tin\u0026rdquo;\u0026hellip; Thời điểm mà những thuật toán dân tình nghĩ là giải $\\mathcal{O}(N^2)$ lại hóa ra giải được trong $\\mathcal{O}(N\\lg N)$, thời kì mà KHMT vẫn chưa có một công cụ chính xác nào về mặt toán học để phân tích các kỹ thuật được sử dụng. Và KHMT và những người có tâm đã đấu tranh rất nhiều để có thể phát triển hướng nghiên cứu này, từ việc xin phép mở khoa trong trường, đến việc phổ biến chương trình cho sinh viên, đến việc xây dựng nền móng lý thuyết (từ những nghiên cứu của Turing, John von Neunman) và nền móng phân tích (Don Knuth, Sedgewick, Ullman, \u0026hellip;).\nCó điểm gì với Deep Learning hiện nay? rất giống là đằng khác, Deep Learning được so sánh như giả kim học vì thiếu sự chính xác và một \u0026ldquo;công cụ phân tích toán học\u0026rdquo;. Tuy nhiên nếu theo đúng những gì đang diễn ra, và ta loại đi những gì quá hype của media, thì ta cũng rất nên hi vọng Deep Learning sẽ trở thành 1 ngành nghiên cứu và thoát khỏi cái gọi là \u0026ldquo;giả kim học\u0026rdquo; như hiện nay. Mình tưởng tượng, hẳn là trong thời kì 50-60 năm trước, hẳn cũng có ai đó đăng đàn và nói rằng KHMT không có cơ sở chính xác toán học. Chỉ là trong giai đoạn ấy, truyền thông và mạng xã hội không phổ biến như hiện nay và rốt cuộc bị xem như là cuộc cãi nhau giữa những giáo sư trong trường ĐH.\nToán học gắn liền mật thiết với KHMT, nhưng vào thời điểm này, Toán học \u0026ldquo;hiện đại\u0026rdquo; đã đi khá xa so với những gì kiến thức phổ thông cung cấp. Tuy nhiên, tác giả đã trình bày sự khác nhau trong tiếp cận vấn đề, dẫn đến KHMT xứng đáng có 1 chỗ đứng riêng ra khỏi toán học. Đồng thời, qua chapter 2, ta cũng thấy được KHMT đã góp phần nào phát triển rất nhiều hướng trong Toán học.\nLịch sử KHMT Mình đặc biệt hứng thú với những phân tích chi tiết về các thuật toán cổ đại của tác giả, cũng như cái nhìn cụ thể về những bản thảo merge sort mà John von Neunman để lại. Đây mới thực sự là cách ta tìm hiểu về lịch sử KHMT. Không phải là nhớ ngày tháng nào ai đó phát minh ra cái gì mà động lực nào, trong hoàn cảnh nào mà tác giả có thể tạo ra thuật toán đó, đồng thời đánh giá với những hạn chế kỹ thuật, ràng buộc công nghệ thời bấy giờ.\nThông qua những phân tích đó, ta mới có thể trân trọng sự đóng góp của tác giả, cũng như có góp nhặt được cách tiếp cận, phương pháp khi giải quyết vấn đề, theo mình đó là điều mà KHMT nên được nhớ theo lịch sử, và những điều đó sẽ trường tồn, cho dù sau này máy tính lượng tử có thay thế hoàn toàn các mô hình tính toán tuần tự.\nDon Knuth rất quan tâm đến điều này, thể hiện ra qua một số bài viết và talk:\n Let\u0026rsquo;s Not Dumb Down the History of Computer Science: rất đáng để bỏ ra 55 phút để nghe. GS phát biểu mở đầu chính là bố già của thung lũng Sillicon. Mình rất thích 1 comment trong clip này: \u0026ldquo;Discover how discoveries are discovered\u0026rdquo;. Lịch sử các thuật toán về sinh các mẫu [fasc4b]: tác giả tìm hiểu các thuật toán có từ thời cổ đại, trung đại và hiện đại với những thông tin cực kì thú vị. Lịch sử về chu trình Hamilton [fasc8a].  ","href":"/vi/docs/selectedpapers_cs/","title":"Sách: Selected Papers on Computer Science"},{"content":" Cấu trúc Hàng Đợi Ưu Tiên (priority queues) là một trong những CTDL kinh điển trong KHMT với rất nhiều ứng dụng khác nhau, có thể kể đến như:\n CTDL quan trọng cho các thuật toán khác như Dijkstra\u0026rsquo;s Algorithms. Numerical Optimization: một vài thuật toán optimization (đặc biệt là iterative optimization) phải chọn ra những biểu thức có sai số làm tròn cao nhất/thấp nhất để thực thi. Trong Hệ Điều Hành, các giải thuật lập lịch, scheduling. Trong các hệ thống giả lập, những sự kiện theo trình tự thời gian được ưu tiên thực thi trước.  Priority Queues có hai toán tử rất quan trọng:\n Chèn một phần tử vào queue (find_max). Lấy ra phần tử lớn nhất trong queue (push).  Chính vì hai chức năng này nên đôi khi Priority queues còn được nhắc đến với cái tên: Largest in, first out; (để phân biệt với First in, First out hay First in, last out). Cụ thể hơn, nếu phần tử K[N] là phần tử lớn nhất được chèn vào, thì K[N] cũng là phần tử đầu tiên được lấy ra.\nBởi tầm quan trọng của 2 hàm này, khi tiếp cận bất kì cài đặt nào liên quan đến priority queues, ta luôn quan tâm cách mà 2 toán tử này duy trì trạng thái trình tự của các phần tử trong CTDL, đó cũng là phần phân tích chính trong bài viết này.\nCác phương pháp cài đặt Toàn bộ các cài đặt bằng C++ và các phân tích được đề cập chi tiết trong note Algorithms trên Github của mình. Trên blog mình chỉ tóm tắt sơ lược về các cài đặt và một số fun facts xung quanh.\nDanh sách bên dưới có một điều thú vị, đó là ta sẽ thấy độ thần thánh của R.Tarjan, ông đóng góp 4/12 cấu trúc được đề cập.\nCài đặt bằng mảng Một cách đơn giản nhất khi sử dụng mảng đó là:\n Luôn giữ một mảng được sắp xếp, find_max đơn giản chỉ là lấy ra phần tử đầu hoặc cuối dãy. Khi push, ta sử dụng chiến lược tương tự như insertion_sort. push thực hiện như mảng bình thường. Khi gọi find_max, ta đơn giản tìm phần tử lớn nhất trong mảng đó.  Cả hai phương pháp đều có độ phức tạp $\\mathcal{O}(1)$ và $\\mathcal{O}(N)$ ứng với find_max, push (cho trường hợp 1) và push,find_max (cho trường hợp 2).\nMột cách tốt hơn, khá dễ cài đặt là sử dụng heapsort với độ phức tạp là $\\lg N$ cho cả 2 toán tử. Chi tiết về heapsort và heap trong priority queue thì quá kinh điển rồi, hầu như mọi sách về thuật toán đề có đề cập.\nLeftist tree Tác giả: Clark A. Crane (1971).\nMột phương pháp cài đặt dạng danh sách liên kết, trong đó mỗi node có các phần tử như sau:\ntemplate\u0026lt;typename Key\u0026gt; struct node { node * left; node * right; int dist; Key k; };  Đây là cây nhị phân đặt biệt, trong đó cây con bên trái luôn nhiều phần tử hơn cây con bên phải, việc này được duy trì thông qua việc câp nhật giá trị dist: khoảng cách của node hiện tại tới node NULL gần nhất.\nChi tiết về thuật toán và cài đặt:\n TAoCP, Vol 3, Section 5.2.3: A linked representation for priority queues. Geeksforgeeks  Ưu điểm của CTDL này chính là việc nó có khả năng gộp 2 priority queues lại với độ phức tạp khá nhỏ. Tuy nhiên, CTDL này thực sự không còn phổ biến.\nCây cân bằng Stratified tree Cấu trúc dữ liệu này có một cái tên phổ biến hơn: van Emde boas tree [Rất tiếc trên Wikipedia, phần van Emde Boas tre lại không đề cập đến tên gọi gốc của CTDL này].\n Beware of bugs in the above code; I have only proved it correct, not tried it\n Câu nói kinh điển này của Don Knuth xuất phát từ việc ông trao đổi với tác giả của cấu trúc này [link 1], [link 2].\nBinomial Queues Tác giả: J. Vuillemin (1978).\nPagodas Tác giả: J. Francon, G. Viennot, and J. Vuillemin (1978).\nPairing heaps Tác giả: Micheal Fredman, Robert Sedgewick, Daniel Sleator, Robert Tarjan (1986).\nSkew heaps Fibonacci heaps và dạng tổng quát: AF heaps Một trong những ví dụ kinh điển về những thuật toán/CTDL có tính chất rất tốt về mặt lý thuyết nhưng lại thất bại trong ứng dụng thực tiễn.\nCalendar queues Relaxed heaps Fishspear Hot queues So sánh ","href":"/vi/docs/impl_priority_queues/","title":"Có bao nhiêu cách cài đặt Hàng đợi ưu tiên?"},{"content":" Trước tiên là ôn lại một chút về quicksort. Dưới đây là bản implement (đơn giản) của thuật toán nổi tiếng này:\n// quicksort implement template\u0026lt;typename T\u0026gt; int partition(vector\u0026lt;T\u0026gt;\u0026amp; a, int lo, int hi) { int i = lo, j = hi; T v = a[lo]; while (true) { while (a[++i]\u0026lt;=v) if (i == hi) break; while (v\u0026lt;=a[--j]) if (j == lo) break; if (i \u0026gt;= j) break; swap(a[i], a[j]); } swap(a[lo], a[j]); return j; } template\u0026lt;typename T\u0026gt; void quicksort(vector\u0026lt;T\u0026gt;\u0026amp; a, int lo, int hi) { if (lo \u0026gt;= hi-1) return; int j = partition(a, lo, hi); quicksort(a, lo, j); quicksort(a, j+1, hi); }  Phân tích Độ phức tạp được đánh giá thông qua hàm:\n$$ C(N) = n-1 + {1\\over n}\\sum_{i=0}^{n-1} ( C(i) + C(n-i-1)) $$\nTrong phần partition thực hiện $n-1$ phép so sánh, sau đó gọi 2 lần quicksort với kích thước lần lượt là $i$ và $n-i-1$, xác suất cho mỗi phần tử trong mảng theo phân phối đều là ${1\\over n}$ vậy nên ta được biểu thức như trên.\nCách giải được đề cập chi tiết trong các sách như Introduction to Algorithms, Concrete Mathematics, Introduction to Analysis of Algorithms. Sơ qua cách giải:\n Nhân hai vế cho $n$. Viết biểu thức cho $n-1$. Tính $C(n) - C(n-1)$ ta được 1 quan hệ đệ quy tuyến tính, giải một chút sẽ ra.  Hạn chế trường hợp worst-case Một trong những phương pháp chống worst-case nổi tiếng của quicksort là xáo trộn mảng input trước khi dùng quicksort. Dùng Knuth shuffle với độ phức tạp $\\mathcal{O}(N)$ ta có thể đảm bảo hiệu quả của thuật toán. Ngoài ra, việc xáo trộn mảng input khiến cải tiến này, thường được gọi với cái tên randomized quicksort, trở thành ví dự kinh điển trong việc phân tích các thuật toán ngẫu nhiên. Mình có một bài viết đề cập tới phân tích randomized quicksort.\nNgoài cách xáo trộn mảng ra, còn có một số cách tiếp cận khác:\n Thay vì chọn pivot ở đầu hoặc cuối dãy, chọn giá trị median. Một trường hợp worst-case khác là khi tất cả các giá trị giống nhau, lúc nay ta dùng 3way-quicksort để giải quyết.  Khử đệ quy với mảng nhỏ Đây là 1 chiêu có thể dùng được với mọi thuật toán sử dụng chia để trị: khi vòng đề quy đủ nhỏ khiến cho mảng input của hàm đó nhỏ hơn 1 ngưỡng cho phép (10-15 phần tử), sử dụng insertion sort sẽ cải thiện hiệu năng đáng kể. Chỉ cần thêm vào trong hàm quicksort\n///... if (hi-lo \u0026lt; CUTOFF) { insertion_sort(a, lo, hi); return; } ///...  Khử phép so sánh giá trị 2 đầu dãy Với phiên bản được implement bên trên, ta có thể bỏ đi câu lệnh if trong while như sau:\n Ta có thể bỏ if khi kiểm tra j bởi a[lo] \u0026lt; a[lo] không bao giờ xảy ra. Để bỏ if trong i. Trước khi gọi quicksort, ta đặt 1 giá trị cờ là MAX_INT chẳng hạn. Như vậy luôn đảm bảo tồn tại 1 giá trị lớn hơn a[lo].  Median-of-three và median-of-five Thủ thuật khá kinh điển để tránh worst-case: sample 3 hay 5 phần tử, lấy giá trị median và lấy median đó làm pivot.\nTukey ninther quicksort. Dùng 9 phần tử thay cho 3/5 phần tử.\n3way Quicksort Đây là thuật toán nổi tiếng do Dijkstra đề xuất cùng với Dutch flag problem. Dùng để tránh trường hợp có quá nhiều giá trị trùng nhau trong dãy. Điểm thú vị là phiên bản quicksort này được chính mình là tối ưu về mặt entropy. Một chứng minh sơ lược có được đề cập trong Algorithms, R. Sedgewick.\nNếu có ai đó hỏi vì sao trong post này nhắc đến Sedgewick nhiều quá vậy, thì đơn giản là luận văn tiến sĩ của ông có tiêu đề: \u0026ldquo;Quicksort\u0026rdquo;.\nMột phiên bản khá ảo diệu của Jon Bentley (tác giả Programming Pearls, cộng tác với Sedgewick để chứng minh phiên bản tối ưu entropy của quicksort):\nvoid quicksort(int l, int u){ int i, m; if(l \u0026gt;= u) return; m = l; for(i = l+1; i\u0026lt;= u; i++) if(x[i] \u0026lt; x[l]) swap(++m, i); //this is where I'm lost. Why the heck does it preincrement? swap(l, m); quicksort(l, m-1); quicksort(m+1, u); }  Phiên bản khử đệ quy Cũng là một cải tiến được đề xuất bởi Sedgewick khi dùng stack thay cho gọi recursive. Một phiên bản cài đặt bằng C cực kì chi tiết được mô tả đây. Trong phiên bản này gồm có các cải tiến được đề cập phía trên:\n CUTOFF Median-of-three Khử đệ quy đồng thời optimize kích thước stack.  Phiên bản này cũng chính là phiên bản qsort trong GNU C.\nPhiên bản Java của Sedgewick cũng rất đáng để tìm hiểu: source code QuickX.\nSamplesort Đây là một bản chế lại của quicksort để chạy được trong các thuật toán song song. Tư tưởng ở đây là sử dụng quicksort để tìm các pivot cho từng process. Rồi sau đó chạy quicksort trên từng pivot được phân phối đó. Bài viết này mô tả cụ thể và phân tích độ phức tạp của thuật toán.\nTham khảo  Cormen, Thomas H. Introduction to algorithms. MIT press, 2009. Graham, Ronald L., et al. \u0026ldquo;Concrete mathematics: a foundation for computer science.\u0026rdquo; Computers in Physics 3.5 (1989): 106-107. Sedgewick, Robert, and Philippe Flajolet. An introduction to the analysis of algorithms. Pearson Education India, 1996. Sedgewick, Robert, and Kevin Wayne. Algorithms. Addison-Wesley Professional, 2011. Bentley, Jon. Programming pearls. ACM, 1986.  ","href":"/vi/docs/improved_qsort/","title":"Một số biến thể Quicksort"},{"content":" Bài viết dưới đây mô tả một giải pháp để cài đặt các quan hệ giữa các cấu trúc dữ liệu (CTDL) khác nhau trong C++. Ứng dụng của quan hệ giữa các đối tượng đóng vai trò quan trọng trong các thuật toán, dưới đây có thể nêu lên 1 số ví dụ:\n Total Order (Quan hệ thứ tự): Đây là một trong những quan hệ quen thuộc nhất, có vai trò quan trọng trong các thuật toán sắp xếp. Equivalence relation (Quan hệ tương đương): được sử dụng trong các thuật toán hashing.  Tuy nhiên trong bài này thay vì đề cập trực tiếp đến quan hệ thứ tự (Total Order), ta thử sử dụng quan hệ tổng quát hơn chút weak order. Điều khác biệt duy nhất của Weak Order so với Total Order nằm ở chỗ weak order không có tính đối xứng. Và trong \u0026ldquo;thực tế đời sống\u0026rdquo;, Weak Order chính là dấu \u0026lt;.\nVậy có điều gì khó khăn khi phải cài đặt dấu \u0026lt; này? Giả sử ta có một hàm như sau:\ntemplate\u0026lt;typename T\u0026gt; bool f(const T\u0026amp; lhs, const T\u0026amp; rhs) { return lsh\u0026lt;rhs; }  Giả sử ta viết một thư viện trong đó chứa hàm f và mong muốn bất kì ai sử dụng cũng phải cài đặt dấu \u0026lt; cho CTDL của mình. Bởi đôi khi, dấu \u0026lt; mặc định của C++ chưa chắc mang ngữ nghĩa đúng, hay bất kì một CTDL tự tạo nào không chứa dấu \u0026lt; cũng gặp lỗi. Vậy nếu có cơ chế nào giúp trình biên dịch phát hiện được LTV quên cài đặt dấu này. Cụ thể hơn ta, muốn có:\ntemplate\u0026lt;typename T\u0026gt; bool f(const T\u0026amp; lhs, const T\u0026amp; rhs) { // Error if T does not have `\u0026lt;` operator // otherwise return lsh\u0026lt;rhs; }  Trong C++11, ta có 1 cơ chế khá giống như vậy:\ntemplate\u0026lt;typename T\u0026gt; bool f(const T\u0026amp; lhs, const T\u0026amp; rhs) { static_assert(has_less_operator\u0026lt;T\u0026gt;::value, \u0026quot;Please implement \u0026lt; operator\u0026quot;); return lsh\u0026lt;rhs; }  Kỹ thuật sử dụng struct\u0026lt;T\u0026gt;::value được gọi là type traits, được sử dụng rất phổ biến trong STL, metaprogramming, các thư viện như BOOST, dlib. Tiếp, ::value ở đây phải là static, không có gì phải bàn. Đồng thời, ::value trả về yes/no khi lớp T chứa/ hoặc không chứa \u0026lt;, nên kiểu phải là bool. Do giá trị này được kiểm tra lúc trình biên dịch thực thi, nên hẳn là constexpr. Xong tạm thời ta có 1 cài đặt:\ntemplate\u0026lt;typename T\u0026gt; class has_less_operator{ private: // stuff public: static constexpr bool value = // and other stuff; };  Và giờ đến phần khoai nhất khi cài đặt. Ta buộc phải gán \u0026ldquo;cái gì đó\u0026rdquo; vào value, nhưng ngay tại thời điểm cài đặt ta còn không biết nó có giá trị gì, và hoàn toàn phụ thuật vào CTDL T nào đó do LTV khác viết. Hay nói một cách khác, chính giá trị boolean cũng bị tham số hóa theo kiểu. May mắn thay, STL có hỗ trợ vụ này:\n#include \u0026lt;type_traits\u0026gt; using namespace std; typedef true_type yes; typedef false_type no;  Lúc này ta có thể viết :\nstatic constexpr bool value = is_same\u0026lt;yes, /* X */\u0026gt;::value;  Như vậy value sẽ phụ thuộc vào is_same\u0026lt;yes, X\u0026gt;::value. Vấn đề X ở đây là gì? Ta xem trong STL, is_same nhận 2 datatype làm input. Vậy X chính là 1 datatype khác. Nhưng cụ thể hơn nó có thể là yes/no để value trở thành yes/no.\nTới đây là một đoạn cực kì fancy, nhưng mình không biết giải thích trước thế nào nhưng trước hết cứ viết ra đã:\nstatic constexpr bool value = is_same\u0026lt;yes, decltype(test\u0026lt;T\u0026gt;(nullptr)) \u0026gt;::value;  decltype trả về kiểu dữ liệu return type của hàm test và ta cố tình đưa toàn bộ cài đặt vào trong test này. Bởi toán tử \u0026lt; trong C++ yêu cầu 1 tham số đầu vào nên ta để 1 tham số hàm test làm dummy. Như vậy ta biết chắc chắn test\u0026lt;T\u0026gt; trả về 1 trong 2 kiểu dữ liệu : yes hoặc no như được typedef phía trên. Đồng thời, ta biết rằng mặc định mọi kiểu dữ liệu T sẽ trả về no.\nTức ta có :\ntemplate\u0026lt;typename\u0026gt; static no test(...);  Xong cho phần sai. Giờ làm thế nào để trả về yes khi dữ liệu thực sự đã cài đặt \u0026lt;. Ta có 1 hàm test thứ 2:\ntemplate\u0026lt;typename P\u0026gt; static auto test (P *p) -\u0026gt; decltype(declval\u0026lt;T\u0026gt;()\u0026lt;(*p), yes());  WTF =))) Điều gì đang xảy ra ở đây? Nhờ một khái niệm SFINAE, chúng ta được chứng kiến sự điên rồ của C++.\nHãy phân tích câu lệnh trên. Phần template\u0026lt;typename T\u0026gt; static không có gì khác với test của no. Kết quả trả về là auto để \u0026ldquo;nhường\u0026rdquo; phần quyết định cho decltype. decltype làm chuyện như sau, nếu biểu thức declval\u0026lt;T\u0026gt;()\u0026lt;(*p), yes() biên dịch được thì auto sẽ trở thành yes nhờ vào \u0026ldquo;comma-separated list\u0026rdquo;: trả về kết quả của term cuối cùng trong list. Vậy vấn đề nằm ở declval. Hàm nào giúp ta gọi được \u0026lt; mà không cần thông qua constructor. Chính xác hơn declval\u0026lt;T\u0026gt;() là template function với tham số kiểu dữ liệu T, trả về kiểu reference X nào đó, nhờ đó ta gọi được \u0026lt;(*p): chính là phép \u0026lt; thần thánh của chúng ta. Nếu như không tồn tại \u0026lt;, biểu thức này fail nhưng sẽ không bị báo lỗi biên dịch mà thay vào đó trình biên dịch gán test cho static no test(...).\nTổng kết lại ta có code như sau:\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; using namespace std; typedef std::true_type yes; typedef std::false_type no; template\u0026lt;typename T\u0026gt; class has_less_operator { private: template\u0026lt;typename P\u0026gt; static auto test(P *p) -\u0026gt; decltype(std::declval\u0026lt;P\u0026gt;()\u0026lt;(*p), yes()); template\u0026lt;typename\u0026gt; static no test(...); public: static constexpr bool value = is_same\u0026lt; yes, decltype(test\u0026lt;T\u0026gt;(nullptr)) \u0026gt;::value; }; template\u0026lt;typename T\u0026gt; bool f(const T\u0026amp; lsh, const T\u0026amp; rhs) { static_assert(has_less_operator\u0026lt;T\u0026gt;::value, \u0026quot;Please implement \u0026lt;\u0026quot;); return lsh\u0026lt;rhs; } struct s1 { int i; s1(int _i): i(_i) { } inline bool operator\u0026lt;(const s1\u0026amp; other) const { return i \u0026lt; other.i; } }; struct s2 { int i; s2(int _i): i(_i) { } }; int main(int argc, char const* argv[]) { s1 a(10); s1 b(20); f(a, b); /* s2 c(10), d(20); */ /* f(c, d); */ return 0; }  Nếu ta uncomment s2 và f bên dưới, ta có thông báo lỗi như sau:\na.cpp: In instantiation of ‘bool f(const T\u0026amp;, const T\u0026amp;) [with T = s2]’: a.cpp:47:11: required from here a.cpp:24:5: error: static assertion failed: Please implement \u0026lt; static_assert(has_less_operator\u0026lt;T\u0026gt;::value, \u0026quot;Please implement \u0026lt;\u0026quot;); ^~~~~~~~~~~~~  Thông báo cực kì dễ hiểu. Với việc sử dụng một số IDE thông minh, thậm chí thông báo lỗi sẽ được thông báo ngay lúc cài đặt s2 và gọi f. Quan trọng hơn, nhờ đó ta có thể viết mã theo \u0026ldquo;Design by Contract\u0026rdquo; hay theo phong cách interface của Java và C++. Sắp tới C++ sẽ giới thiệu khái niệm concept và theo tác giả của C++ là sẽ giải quyết vấn đề suốt 35 năm qua của Generic Programming (link).\nCác toán tử khác Sau khi cài đặt toán tử \u0026lt;, thông thường ta sẽ có nhu cầu cài đặt các toán tử so sánh khác như \u0026gt;, \u0026lt;=, \u0026gt;=. May mắn thay ta có thể quy đổi các toán tử này dễ dàng thông qua \u0026lt;:\n \u0026gt;: chính là rhs\u0026lt;lsh. \u0026lt;=: là !(rhs\u0026lt;lsh). \u0026gt;=: !(lhs\u0026lt;rhs).  Trong thâm ta ta có cảm giác rằng thể nào cũng có rất nhiều CTDL ta cài đặt kiểu này: chỉ cần định nghĩa \u0026lt; và 3 toán tử còn lại tự nội suy. Nhờ vào kỹ thuật Curiously recurring template pattern, ta có một code khá gọn:\ntemplate\u0026lt;typename T\u0026gt; struct order { virtual bool operator\u0026lt;( const T\u0026amp; rhs) const = 0; bool operator\u0026gt;( const T\u0026amp; rhs) const {return rhs\u0026lt;static_cast\u0026lt;const T\u0026amp;\u0026gt;(*this);} bool operator\u0026gt;=( const T\u0026amp; rhs) const {return !((*this)\u0026lt;rhs); } bool operator\u0026lt;=( const T\u0026amp; rhs) const {return !(rhs\u0026lt; static_cast\u0026lt;const T\u0026amp;\u0026gt;(*this));} };  Như vậy chỉ cần kế thừa order và cài đặt \u0026lt;, ta sẽ có luôn 3 toán tử còn lại. Điều duy nhất mình ức chê là phải sử dụng static_cast.\n","href":"/vi/docs/total_order/","title":"Cài đặt quan hệ thứ tự trong C++"},{"content":"Dưới đây là ghi chép/ sưu tầm của bản thân về những người Việt đã ảnh hưởng đến sự lịch sử và sự phát triển của Khoa học Máy Tính. Đây là thống kê cá nhân và nếu có bạn nào có phát hành lại thì nhớ ghi nguồn nhé :) [Một số nhân vật mình không rõ tên cụ thể trong tiếng Việt nên sẽ ghi bằng tên ghi trên wiki hoặc trang cá nhân.]\nTạm thời mình chưa sắp xếp và mô tả nhiều, hầu hết lấy thông tin từ wiki:\n Minh Lê: Tác giả của Counter-Strike một trong những game nổi tiếng nhất mọi thời đại. Đứng thứ 14 trong danh sách 100 người sáng tạo game của mọi thời đại (Nguồn: Wiki). Bùi Tường Phong: Tác giả thuật toán Phong shading, ông là một trong những tiên phong trong đồ họa máy tính. Trương Trọng Thi: Cha đẻ của máy tính cá nhân. Vâng, chính ông được mệnh danh là cha đẻ của máy PC thời nay. Minh Đỗ: Giáo sư Minh Đỗ rất nổi tiếng trong giới xử lý ảnh và thị giác máy tính. Giáo sư cũng là một trong những người Việt có số citation cao nhất trong KHMT (Nguồn: Chấn Thái: số lượng citation trong này chưa được cập nhật, hi vọng tác giả sẽ update sớm. Số lượng chính xác có thể tham khảo ở Google Scholar.) Lê Viết Quốc: Một trong những người tiên phong trong Deep Learning. Lí do mình không ghi tên tiếng Việt là mình quên mất anh ấy là Lê Viết Quốc hay Lê Việt Quốc. QT Luong: Tác giả của khái niệm Fundamental matrix và camera auto-calibration: một trong những khái niệm cơ bản của Thị Giác Máy Tính. Vũ Hà Văn: Giáo sư là tác giả của nhiều công trình về tổ hợp, tác giả của \u0026ldquo;Additive Combinatorics\u0026rdquo; (cùng với Terence Tao) được đánh giá là tham khảo chuẩn mực cho tổ hợp hiện đại (Nguồn: Yale news). Một trong số rất ít người Việt được đề cập trong The art of computer programming (Don Knuth). Dan Luu: \u0026ldquo;Second person on TPU\u0026rdquo;: anh đóng vai trò quan trọng trong dự án về phần cứng TPU: phần cứng tăng tốc xử lý deep learning của Google. Mình cá là họ ảnh tên Lưu, và chắc chắn có bà con với Lưu Cẩm Khương =)). Phong Quang Nguyen: Giáo sư và là chuyên gia hiện nay về bảo mật, đặc biệt là hướng bảo mật dựa trên lý thuyết số.  Please stay tuned. :)\n","href":"/vi/docs/vietcs/","title":"Người Việt trong Khoa học Máy Tính"},{"content":" Mình không tìm được từ nào tiếng Việt có thể dịch được từ \u0026ldquo;Fibonaccian Searching\u0026rdquo;, nếu \u0026ldquo;binary searching\u0026rdquo; có thể dịch là \u0026ldquo;tìm kiếm nhị phân\u0026rdquo;, thì \u0026ldquo;Fibonaccian Searching\u0026rdquo; không có ngữ nghĩa gì nhiều.\nNguồn gốc thuật toán này xuất phát từ bài tập 1.4.22 (Algorithms, Fourth Edition, Sedgewick). Ngoài ra đây cũng là một nội dung được đề cập trong TAoCP - Vol 3.\nLịch sử Thuật toán được để xuất bởi Devid E. Ferguson (CACM-1960, link). Một số phát hiện liên quan, chủ yếu về nguồn gốc cây Fibonacci có thể tham khảo tại TAoCP - Vol 3 (Mục 6.2.1).\nThuật toán Điểm thú vị của thuật toán này nằm ở chỗ thuật toán không sử dụng phép chia, nhưng vẫn đạt được độ hiệu quả của binary search. Tuy nhiên, ưu điểm này thực sự có tác dụng vào thời điểm thuật toán này được đề xuất (1960) khi mà các chép chia, hay shift bit tốn nhiều chi phí hơn so với phép cộng trừ. Tuy nhiên, fibsearch còn được sử dụng khi tốn ưu thời gian tìm kiếm khi mà dữ liệu quá lớn không thể đọc lên được toàn bộ lên RAM hoặc cache, khi đó thời gian đọc trên bộ lưu trữ ngoại vi trở nên tốn kém ( link ). Tuy nhiên mình nghĩ fibsearch sẽ là một câu hỏi phỏng vấn cực kì thú vị.\n Thiết kế một thuật toán tìm kiếm nhị phân không sử dụng phép nhân, chia hoặc dịch bit với độ phức tạp $\\mathcal{O}(\\lg N)$\n Cài đặt Phần dưới đây là giải thuật lấy từ TAoCP, mình nghĩ là cực kì dễ hiểu, tạm thời mình chỉ trình bày mã giả. Có thể tham khảo phần cài đặt bằng C, trong phần References. Một phiên bản cải tiến với kích thức mảng $N$ bất kì sẽ được update sau.\nInput: mảng $K_1, K_2, ..., K_N$ được sắp xếp và phần tử $K$ cần tìm. Giả sử $N+1 = F_{k+1}. Lưu ý index của mảng bắt đầu 1$ P1. [Khởi tạo] i = F[k], p = F[k-1], q = F[k-2] P2. [So sánh]. if K[i] \u0026lt; K: go to P3. else if K[i] \u0026gt; K: go to P4. else: return i; P3. [Xét cây con Fibonacci bên trái] if q = 0: return -1 else: i -= q (p, q) = (q, p-q) go to P2 P4. [Xét cây con Fibonacci bên phải] if p = 1: return -1 else: i += q p -= q q -= p go to P2  Bài tập  Thiết kế thuật toán cho trường hợp $N \\geq 0$. Thiết kế thuật toán với index bắt đầu bằng 0. Về mặt kĩ thuật chỉ có 1 thay đổi nhỏ trong code, nhưng cây Fibonacci sẽ tương đối khác.  Phân tích   Cây tìm kiếm Fibonacci với k=6. Source: TAoCP, Vol 3, P417.   Phần dưới đây là mô tả ngắn gọn cách mà thuật toán này thực thi. Khác với tìm kiếm nhị phân chia các nhánh tìm kiếm thành các cây nhị phân, fibsearch thay vào đó xây dựng cây Fibonacci. Cây Fibonacci bậc $k$ được định nghĩa là \u0026ldquo;cây\u0026rdquo; với $F_{k+1}-1$ internal nodes (vòng tròn) và $F_{k+1}$ external nodes (hình vuông),1 cây Fibonacci được xây dựng như sau:\n $k=0$ hoặc $k=1$, cây chỉ có 1 external node là 0. $k \\geq 2$, root là có giá trị $F_k$, cây con bên trái là cây fibonacci bậc $k-1$ và cây con bên phải là cây fibonacci bậc $k-2$ với tất cả các nodes tăng $F_k$ đơn vị.  Thuật toán fibsearch chính là việc xây dựng cây fibonacci bậc $k$ với $N=F_{k+1}$.\nTrong Figure 1, cây có bậc $k=6$ (tương đương với tìm mảng có $N=12$ phần tử ($N+1=F_{k+1} = F_7 = 13$)), số internal nodes $F_{k+1}-1=12$ và $F_{k+1}=13$ external nodes. Ngoài ra, ta có thể thấy root = $F_6 = 8$, phần nhánh bên trái của 8 có $F_6-1=7$ internal nodes, và bên phải gồm $F_5-1 = 4$ internal nodes. Tiếp tục xuống các level thấp hơn là các giá trị $F$ nhỏ hơn và theo đúng quy luật đã nêu. Nhìn hình ta có thể hình dung phần nào, với cách tiếp cận chia để trị tương đồng với tìm kiếm nhị phân, tìm kiếm fibonaci \u0026ldquo;có thể\u0026rdquo; có độ phức tạp tương tự.\nMột chứng minh cụ thể và chi tiết hơn sẽ được cập nhật sau, kèm theo đó là mã nguồn C++ của thuật toán.\nDạng tổng quát Cả tìm kiếm nhị phân lẫn Fibonacci search thực ra cũng thuộc một dạng tổng quát của một chiến lược chia để trị trong tìm kiếm chuỗi đã được sắp xếp.\nGọi $p$ và $q$ thỏa $p+q=1$, gọi $C(N)$ là số phép so sánh cần thực hiện của giải thuật. Chiến lược ở đây đó là chia mảng thành 2 phần với số lượng phần tử lần lượt là $pN$ và $qN$. Ta có dãy truy hồi số phép so sánh trong thuật toán:\n$$ C(N) = 1 + pC(pN) + qC(qN) $$\nCông thức này có dạng close form là $C(N) = \\log_bN$ trong đó $b$ là hằng số cần tìm. Dễ dàng thấy được với tìm kiếm nhị phần $p=q={1 \\over 2}$, còn với fibsearch thì $p={1 \\over \\phi}$ và $q= {1 \\over \\phi^2}$. Cụm $pC(pN)$ ở đây có nghĩa là xác suất $p$ phần tử cần tìm nằm trong khoảng $pN$ phần tử đã được chia, tương tự với $qC(qN)$.\n[$b = p^{-p}q^{-q}$ nhưng hiện giờ vẫn chưa biết giải như thế nào. Đây là dạng divide-and-conquer recurrence. Nếu sử dụng Akra-Bazzi method thì ta chỉ mới tìm được $\\Theta(1 + \\ln N)$ của nó nhưng vẫn chưa xác định được $b$].\nReferences  C implementation: cá nhân mình nghĩ đây là bản cài đặt khá chuẩn rồi. Knuth, Donald Ervin. The art of computer programming. Vol. 3. Pearson Education, 1997.[ aka TAoCP in my blog] Sedgewick, Robert, and Kevin Wayne. Algorithms. Addison-Wesley Professional, 2011. GeeksforGeeks\u0026rsquo;s Fibonaccian Searching. Wiki.  TODO Minh họa cây Fibonacci. Phiên bản C++. So sánh độ phức tạp với tìm kiếm nhị phân, tổng quát hóa bài toán. Hằng số $b$.    cũng không biết nên dịch internal nodes với external nodes thế nào cho hợp (node trong và node ngoài?). ^   ","href":"/vi/docs/fibsearch/","title":"Giải thuật tìm kiếm Fibonacci"},{"content":" Quy trình này mình tìm hiểu khi mua những hàng sử dụng International Shipping, lí do nó khiến mình quan ngại là vì:\n Chính sách đổi trả của Amazon thế nào với hàng được chuyển quốc tế. Nếu mình phải trả lại hàng (ví dụ gửi từ Singapore lại qua bên Mỹ) thì phía Amazon có chịu trả chi phí cho mình không? Hàng đổi được gửi như thế nào.  Sau đây là kinh nghiệm của mình sau 1 buổi sáng hì hục tìm hiểu:\n Amazon cung cấp 2 options: (1) refund - hoàn lại tiền, (2) give a replacement thay hàng bị hỏng bằng cái khác. Amazon sẽ gửi lại phí ship chi khách hàng nếu họ nhận được hàng bị hỏng và mình có hóa đơn đưa cho họ. Hàng gửi phải đến Amazon trong vòng 1 tháng. Maximum tiền ship mà Amazon trả là 20 USD.  Để tiến hành thủ tục trả hàng thì cách tốt nhất mình thấy là liên hệ trực tiếp với bên Amazon, đề cập vấn đề gặp phải, và họ sẽ tự động làm các thủ tục giúp bạn.\nỞ Singapore mình đã thử gửi bằng SingPost và phát hiện ra chi phí khá là đắt. Ví dụ 1 cuốn sách mình mua tầm 90 SGD nhưng để gửi lại qua Mỹ thì phí vận chuyển mất 60 SGD, mặc dù Amazon cam kết trả tiền shipping nhưng theo mình nhớ khoảng này maximum có 20 USD ~ 27 SGD.\nLưu ý cho các bạn mua sách Lý do mình đổi sách là vì 1 số figure bị lỗi, tuy nhiên vấn đề là xác suất sách mới thay thế cũng có nguy cơ bị như vậy. Điều đó đã từng xảy ra, điển hình như cuốn \u0026ldquo;Selected Papers on Fun and Games\u0026rdquo; của Don Knuth (link). Vậy nên miình nghĩ tốt hơn hoặc là xác định mua sách ở Amazon có tỉ lệ hên xui nhất định, và giải pháp tốt hơn đó là refund thay vì lấy 1 cuốn khác (vì có nguy cơ cuốn mới cũng bị như cuốn cũ).\nTuy nhiên việc mua hàng ở Mỹ, ship về Singapore rồi gửi trả lại với mình thấy không đáng lắm (với sách). Nên theo kinh nghiệm của bản thân:\n Chỉ thực sự đổi hàng khi cần thiết. Hàng điện tử, nhỏ gọn nhé và chi phí ship + công sức nhỏ.  23/10/2017: Amazon đã gửi cho mình bản mới của cuốn sách, và thật kì diệu, sách vẫn bị những lỗi như cũ (wtf). Kinh nghiệm ở trên của mình còn hữu dụng chán. Thật tiếc vì phải vote 4 sao cho textbook kinh điển của Sedgewick, nhưng mình không còn giải pháp nào khác link.\n24/10/2017: Chính xác là Amazon sẽ gửi lại đúng 20 USD (~27 SGD) cho dù mình phải chịu giá shipping cao hơn nhiều (59.9 SGD). Vậy nên khi mua hàng trên Amazon mà international shipping thì cần rất cẩn thận, check hàng kỹ trước khi mua.\n","href":"/vi/docs/amazon_replacement_policy/","title":"Chính sách gửi trả hàng của Amazon"},{"content":" Một lỗi tương đối nhỏ về mặt lịch sử trong clip mới ra mắt của Mỹ Tâm - \u0026ldquo;Đừng Hỏi Em\u0026rdquo;. Font chữ trong tờ giấy này là font Arial, được thiết kế lần đầu tiên năm 1982 ( được các hãng phần mềm phân phối vào khoảng năm 1992,) tuy nhiên theo mình đó thì thời đó ở VN chắc vẫn còn dùng máy in đời cũ, mà có ngay cả như vậy thì clip rõ ràng là các sự kiện trước năm 1975.\nVậy nên việc sử dụng 1 font đc tạo ra năm 1982 có gì đó hơi sai về lịch sử ở đây, đúng ra bên sản xuất nên chọn 1 font nào đó cổ hơn cho để đúng về mặt lịch sử và mốc thời gian.\nVì sao mình quan tâm đến font, vì có 1 lần Don Knuth nói ông mất 1 tuần để viết ra 1 công thức để có thể vẽ chữ \u0026ldquo;S\u0026rdquo; - hoàn hảo nhất có thể. Giáo sư John Hennessy , cha đẻ kiến trúc MIPS, president thứ 10 của Stanford và đc mệnh danh là \u0026ldquo;bố già Silicon Valley\u0026rdquo; từng sửng sốt với cách thiết kế chữ \u0026ldquo;S\u0026rdquo; và bao nhiêu tinh hoa của thuật toán, đồ họa máy tính đc đưa vào trong đó. Điều đó khiến mình tò mò về cách mà các font chữ đc tạo và vẽ, dẫn đến việc tìm hiểu lịch sử ngành in ấn =))\nKhông phải máy gõ chữ nào cũng tạo ra font chữ xấu. Thực ra font chữ đã khá hoàn hảo ở thế hệ máy in kim loại nóng (hot metal typesetting), sau đó đến máy gõ chữ (typewriter) mà hậu duyện dòng này là font chữ monospaced (thậm chí developer toàn dùng monospaced khi code chứ ko dùng serif ). Sau khi hot metal bị thay thế bởi digital printer, lúc đó chữ render cực kì xấu, đến nỗi Don Knuth tuyên bố sẽ ko viết TAoCP nếu tình trạng chữ như vậy. Cuối cùng ông bỏ ra 10 năm để tạo ra Tex và Metafont. Sau này dần dần công nghệ in ấn phát triển, các font thiết kế tốt hơn nên mới có kq là font \u0026ldquo;đẹp\u0026rdquo; như hiện nay.\nReferences  Đừng hỏi em Steve Jobs On Taking a Calligraphy class Arial font  ","href":"/vi/docs/dung_hi_em-font/","title":"[Font] Một lỗi nhỏ trong \"Đừng hỏi em\""},{"content":" Phải thành thật, mình là fanboy của Donald Knuth. Có thể có rất nhiều giáo sư có tầm ảnh hưởng lớn đến các hướng mà mình quan tâm (khoa học máy tính/ trí tuệ nhân tạo hay thị giác máy tính) như Hinton, Li Fei-Fei, Zisserman, Pascal Fua. Nhưng có rất ít nhà khoa học mà mình dành trọn thời gian để có thể tìm hiểu và \u0026ldquo;cuồng\u0026rdquo; như Donald Knuth. Và mong ước của mình từ khi bước chân vào giảng đường đại học, theo đuổi đam mê với Khoa Học Máy Tính, rằng mình sẽ chinh phục cuốn \u0026ldquo;Kinh Thánh\u0026rdquo; này. Đó là một cuộc hành trình, và còn thử thách hơn cả tất cả những hành trình mình từng trải nghiệm.\nNgày sinh nhật vào năm đầu tiên đi làm, mình đã tự thưởng cho bản thân bản full set của bộ sách . Trước giờ mình chỉ dùng với mục đích tham khảo là chính. Nhưng vừa sau đợt sinh nhật 24 của mình, mình quyết định phải \u0026ldquo;chinh phục\u0026rdquo; bằng được cuốn sách. Mà theo plan của mình Volume 1 sẽ tốn tầm \u0026hellip; 1-2 năm. Và có lẽ, mình sẽ mất chừng chục năm để chinh phục Volume 4A 😆. Chưa kể, phần 4B cực kì khó nhằn vì có cả Satistiability trong đó. Có lẽ riêng Volume 4 không thôi thì đã trở thành tượng đài mất rồi.\nTAoCP liệu có khó đọc? Theo mình thì không. Nhiều người khi nhìn vào cuốn sách với hàng đống công thức toán và những bài tập khó nhằng cũng như code mã máy MIX khiến họ nghĩ đây là một cuốn sách rất khó đọc. Nhưng ngay từ đoạn giới thiệu, Don Knuth đã hướng dẫn cách đọc và ông đã chỉ rõ những vấn đề mà người đọc thắc mắc.\n Với MIX - mình đồng ý quan điểm của Don Knuth, nếu ông viết chương trình theo C/C++ hay Java hay Python, một thời gian sau chắc chắn nó sẽ có vấn đề. Kể cả những ngôn ngữ bậc cao càng khiến ta khó phân tích chính xác số lượng tính toán trong thuật toán đó. Mà theo phân tích của Knuth, đó phải là những phân tích chính xác. Ngôn ngữ của MIX cũng rất dễ đọc, không đến nối rắc rối như mọi người tưởng. Đồng thời, việc đọc code bằng mã máy khuyến khích người đọc \u0026ldquo;vọc\u0026rdquo; với thuật toán được ghi. Thêm nữa, \u0026ldquo;ngôn ngữ bậc cao\u0026rdquo; mà Knuth dùng chính là tiếng Anh.\n Trong biểu đồ sử dụng sách của mình, Knuth có nói rằng nếu các công thức toán \u0026ldquo;is all Greek to you\u0026rdquo; ta chỉ cần xem qua và nắm được kết quả cơ bản mà phần đó đề cập, và hầu như các kết quả đó được nói ở đầu mục hoặc cuối mục.\n Với bài tập của TAoCP, Knuth đề xuất hệ thống phân loại. Hơn hết, hệ thống này nhằm giúp cho người đọc, với thời lượng cho phép của mình, lựa chọn và làm những bài bản thân nghĩ là phù hợp. Bởi thật sự những bài với độ khó lớn hơn 45, dù là không dính đến toán, M hay HM đều cần rất nhiều thời gian nghiên cứu. Bản thân mình nghĩ nếu giải được những bài đó thì có thể hoàn thành được PhD của Computer Science rồi. Nhưng mình vẫn nghĩ người đọc nên xem qua các câu hỏi này, vì nó chính là biên giới tri thức trong khoa học máy tính.\n Knuth nêu rõ trong cuốn sách của mình, mục đích của cuốn sách phục vụ: (1) là tài liệu tham khảo chính xác và chi tiết về phân tích thuật toán, (2) là một sách giáo khoa tự học dành cho những người đam mê về thuật toán cũng như Khoa Học Máy Tính. Nếu bạn mua TAoCP chỉ với giá trị tham khảo thì đó hoàn toàn là mục đích chính xác của bộ sách: mình đặc biệt thích phần tra khảo về lịch sử. Đúng ra, Don Knuth rất quan tâm đến lịch sử của Khoa Học Máy Tính, đó là lí do vì sao trong sách đề cập các thông tin lịch sử lại chi tiết đến như vậy. Nhưng ngoài ra, phần bài tập lẫn lời giải, mà thường chiếm đến 1/3 cuốn sách, nói lên rằng Knuth mong mỏi cuốn sách này sẽ là một tài liệu học tốt dành cho mọi người.\n  Kế hoạch của mình rất đơn giản: Chinh phục TAoCP đồng thời giúp mọi người dễ dàng tiếp cận với tài liệu quý giá này. Quá nhiều bạn đọc dường như sợ tiếp cận cuốn sách bởi những \u0026ldquo;myth\u0026rdquo; vừa nêu, đồng thời, chinh phục TAoCP là một hành trình thực sự thú vị. Mình đã học được rất nhiều điều thông qua cuốn sách. Những ngày đầu đại học khi lần đầu cầm trong tay Volume 1, mình mới thực sự hiểu \u0026ldquo;computer science\u0026rdquo; là một khoa học đầy hấp dẫn, và nó cũng rất \u0026ldquo;art\u0026rdquo;.\nMình đồng ý với quan điểm của Knuth, người làm về phân tích thuật toán hạnh phúc gấp đôi những ngành khác: họ chiêm nghiệm được những công thức toán phức tạp để tính toán độ phức tạp, phân tích thuật toán, đồng thời họ cảm nhận được tính hiệu quả của thuật toán đó trong thực tế. Ta chắc chắn không cần bận tâm đến câu \u0026ldquo;học toán để làm gì\u0026rdquo;, bởi khi tiếp cận với phân tích thuật toán, ta cảm nhận ngay được ích lợi của toán học, thuật toán cũng như vẻ đẹp của thuật toán khi ta cài đặt và sử dụng trong thực tiễn.\nMột chút về dự án này Ngoài những chi tiết ở trên, một phần khiến TAoCP khó đọc ở chỗ thông tin được Knuth viết tương đối cô đặc. Chính vì lẽ đó mà đôi khi có những phần tương đối khó hiểu đối với những bạn tìm hiểu về khoa học máy tính và chưa có nhiều kiến thức trước đó. Mục tiêu của project này nhằm giúp các bạn dễ tiếp cận hơn với sách, đồng thời giải thích các phần bài tập, bởi mình thấy Knuth viết phần Solutions cực kì gọn, và đôi khi cũng không biết là từ đâu lại có những đáp số đó. Ngoài ra, tìm hiểu về TAoCP cũng chính là tìm hiểu các thuật toán kinh điển, các bài toán làm trên nền tảng của Khoa Học Máy Tính cũng như đây là nguồn tài liệu rất quý giá để mài dũa \u0026ldquo;algorithmic thinking\u0026rdquo;. Một lý do nữa khiến mình có hứng thú để làm đó là hiện nay tuy có khá nhiều blog, repo trên Github note lại TAoCP nhưng chưa có ai viết đầy đủ, hoặc chi tiết.\nLoạt bài viết cùa mình yêu cầu người đọc đã đọc qua trước chương hoặc phần mình đề cập trong bài viết, trong các bài viết mình sẽ chú trọng đến các chi tiết sau:\n Các chi tiết tương đối khó hiểu. Phần bài tập. Các state-of-the-art hiện nay. Các thông tin lý thú liên quan đến chủ đề đó.  Mình có tích hợp plugin Hypothesis giúp các bạn có thể highlight, viết note trên blog của mình, đồng thời phần comment để mọi người thuận tiện trao đổi với nhau cũng như giúp mình update các lỗi có trong bài viết.\nKinh nghiệm cá nhân Một số kinh nghiệm bản thân khi mình đọc TAoCP, thực ra đến tận bây giờ bản thân mình mới dành thời gian với cuốn sách, trước đây mình chủ yếu dùng tham khảo là chính:\n Luôn có giấy và bút bên cạnh để có thể:  Chạy \u0026ldquo;chay\u0026rdquo; các thuật toán. Làm bài tập. Hiểu công thức đang muốn nói điều gì.  Có một sổ tay ghi chú. Một số chỗ Knuth viết rất cô đọng và mình nghĩ chỉ có cách ghi note lại mới thực sự nhớ và hiểu được. Thử implement thuật toán bằng một ngôn ngữ ưa thích. Quan điểm của mình thì C hoặc C++ là phù hợp nhất. C thì có thể gần với mục đích nhất, trong khi đó C++ sẽ tiện hơn.  Một chút về phần Preface (Volume I) Tuy chỉ là phần lời nói đầu, nhưng tác giả đã đề cập đến khá nhiều câu chuyện hay ho mà mình có thể tóm lượt như sau:\n Thuở xa xưa khi Khoa học máy tính mới hình thành, có 3 ngành chính thịnh hành lúc bấy giờ: numerical analysis, artificial intelligent và language theory. Chính Knuth là người đã khai sinh ra nhánh \u0026ldquo;analysis of algorithms\u0026rdquo;. Trước đó đã có các công trình của Alan Turing, Jon von Neumann tuy nhiên đó là những nghiên cứu rời rạc và không có một hệ thống hoàn chỉnh. Trong phần preface, Knuth đề cập rằng những phân tích của mình \u0026ldquo;non-numerical\u0026rdquo; bởi vì nó quan tâm đến các đối tượng rời rạc nhiều hơn. Nếu chọn \u0026ldquo;nonnumerical analysis\u0026rdquo; thì lại hơi mang tính tiêu cực (có lẽ do tiền tố \u0026ldquo;non\u0026rdquo; trong đó). Trong khi đó \u0026ldquo;programming techniques\u0026rdquo; thì lại quá hẹp về 1 phần trong lĩnh vực. Đó là lí do mà ông chọn từ \u0026ldquo;analysis of algorithms\u0026rdquo;. Việc chọn mã máy MIX cũng được ông phân tích khá rõ trong phần này. Thực sự những lý do đó hoàn toàn thuyết phục. Mình nghĩ một ngôn ngữ gần nhất ông có thể dùng đó là C. Nhưng nếu như vậy ông phải định nghĩa số chỉ thị cho từng câu lệnh trong C, điều này mình nghĩ không đơn giản lắm. Người đồng hành với ông trong cuốn sách này là Robert W. Floyd , ông chính là tác giả thuật toán \u0026ldquo;Floyd-Warshall\u0026rdquo;, thuật toán phát hiện vòng trong danh sách liên kết cũng như những đóng góp tiêu biểu của ông trong \u0026ldquo;program verificaition\u0026rdquo;.  Ghi chú  Một bài nói của Don Knuth về mối quan tâm của ông với lịch sử khoa học máy tính: [link] Phỏng vấn Don Knuth. Có khá nhiều chi tiết thú vị về suốt cuộc đời làm nghiên cứu của ông (Ông mất chỉ 1 giờ để hoàn thành luận án tiến sĩ của mình). [link]. Mình sẽ có một bài tóm tắt về cuộc phỏng vấn đầy hấp dẫn này.  Tài liệu Một số tài liệu mình thấy là khá hay để có thể bắt đầu tìm hiểu công trình của Knuth. Dưới đây là danh sách các sách mình đang/ đã đọc. Không theo lối thông thường mà dân tình hay truyền nhau sách này hay sách kia hay mà chưa bao giờ đụng vô, mình chỉ review những sách mình đã tiếp xúc:\n Algorithms - Sedgewick: cuốn sách lập trình mình tâm đắc nhất khi cung cấp cả code lẫn những phân tích chi tiết. Introduction to Analysis of Algorithms - Sedgewick \u0026amp; Flajolet: dẫn nhập trực tiếp vào công trình của Knuth, mình nghĩ đây là bước đệm quan trọng, cuốn sách này thực sự rất hay. Conrete Mathematics - Knuth: Không chỉ dần cho dân Toán, cuốn sách này đọc rất \u0026ldquo;đã\u0026rdquo; (Mình đang cố gắng đọc và làm nhiều bài tập nhất có thể)  ","href":"/vi/docs/taocp/howto/","title":"Đọc \"Nghệ Thuật Lập Trình\" (TAoCP)"},{"content":"Thực ra câu chuyện mình sắp kể không liên quan là mấy đến tai nghe dành cho programmer. Nó ít nhiều liên quan đến chuyện: ra quyết định tối ưu và không cần đắn đo đến nó nữa.\nTuy nhiên, vì đang nói đến tai nghe dành cho programmer. Nên tiện thể mình đề cập. Chuyện là mình đang cần một tai nghe có tính năng noise cancelling tốt, vì tiếng xì xầm cũng như âm thanh văn phòng khiến mình khó tập trung, bản thân vừa làm research vừa programming, đôi khi mình cần không gian rất yên tĩnh để có thể dành toàn bộ neural cho 1 task nào đó. Một cái nữa là noise isolation - mình cần 1 tai nghe không rò rỉ âm quá, vì như vậy khiến người xung quanh cũng khó chịu.\nSau một hồi research, mình cũng tìm được kha khá ứng viên:\n Sennheiser HD 4.50 (over-ear) Sennheiser CX 300 II (earbud) Bose QuietComfort 35 (over-ear).  Có một trang khá hay là RTINGS, trong đó có hẳn mục sử dụng tai nghe trong văn phòng ( link ), mình nghĩ rất đáng để lướt qua. Đại khái lướt qua thị trường thì có Bose và Sennheiser là có tai nghe khá tốt cho việc dùng ở văn phòng. Ngoài ra còn có cả Jaybird, tuy nhiên mình không thích design của hãng này lắm.\nMột số trang dưới đây cũng rất đáng để xem xét, như một nguồn tham khảo khi quyết định mua tai nghe:\n Coding Supply Pixel Monkey Stuff : tai nghe noise cancelling giá mềm.  Giờ mới là câu chuyện chính. Mình mất tầm 5 tiếng đồng hồ để xác định mình nên mua cái nào. Nhưng rốt cuộc, lại chọn đúng cái đã chọn trước đó. Bực bội hơn, mình cứ xem đi xem lại những cái tai nghe đã xem qua trước đó và thấy rằng nó hiện không phù hợp với nhu cầu của mình. Nó liên quan cả đến decision making lẫn optimization: tìm tai nghe tốt nhất trong những ràng buộc nhất định, đồng thời quyết định xem chọn mua cái nào. Sau một thời gian ngẫm nghĩ, mình đành tự propose một \u0026ldquo;framework\u0026rdquo; cho việc shopping và cố gắng không để tình trạng này diễn ra thêm lần nào nữa:\n Xác định khoảng tiền mình bỏ ra. Và đây là là ràng buộc có trọng số cao nhất. Nó hạn chế mình tiêu quá tay, đồng thời giúp bản thân quản lý tài chính tốt, giảm thời gian shopping lại bởi mình có thể giảm không gian tìm kiếm xuống khá nhiều. Dĩ nhiên trước đó nên coi xem món hàng cần mua thường có khoảng giá bao nhiêu. Thời gian bỏ ra shopping tỉ lệ thuận với số tiền ước tính. Có thể mua 1 món hàng 800-1000 usd thì mình cần 1 ngày để tìm hiểu cái mình cần mua chẳng hạn. Với những món 10-15 usd có thể chỉ cần 30 phút quyết định. Bắt đầu tìm hiểu, nhất thiết phải ghi note lại, ghi chú các ưu nhược điểm mà những món hàng mình có dự định mua (potential items). Việc này giúp mình không phải đắn đo lại 1 món hàng hay xem đi xem lại. Theo mình thấy, nhiều link cùng đề cập đến 1 món và hầu như lúc nào mình cũng mở link để xem lại đúng mô tả của món hàng đó. Liệt kê đầy đủ các nhu cầu, ràng buộc, Liên tục cập nhật vào ghi chép. Nên cài đặt một \u0026ldquo;hàng đợi ưu tiên\u0026rdquo; (priority queue) theo tiêu chí của riêng mình và chỉ giữ top K phần tử tốt nhất (vd: top 3, top 5). Nếu nhưng list đó full và cần thêm 1 item nữa, thì chắc chắn mình sẽ cần bỏ đi 1 item. Nhờ vậy ta sẽ luôn phân tích ưu nhược điểm các item đó, để cuối cùng có quyết định chuẩn hơn. Mua hàng: đơn giản là chọn top() ra khỏi và mua thôi. List k-1 item còn lại có thể dùng để \u0026hellip; mua sau đó hoặc có thể giữ làm Wish List chẳng hạn. Tuy nhiên mình nghĩ trước đó nên re-ranking trở lại. Nếu có nhiều items có cùng trọng số thì sao? Chuyện này có thể diễn ra, và likely diễn ra khá cao, ta có thể apply một số hypothesis sau:  Hỏi ý kiến người thân/bạn bè. Random. Dựa vào lượt review trên Amazon. Chọn cái nào rẻ hơn.   ","href":"/vi/docs/headphones/","title":"Tai nghe dành programmer"},{"content":"[Link from PBS]\nMột bộ phim tài liệu lịch sử xuất sắc về chiến Tranh Việt Nam. Với sự tham gia phỏng vấn của nhà văn Bảo Ninh, nhà báo Huy Đức. Điều làm nên bộ phim chính là tính chân thực và nhìn nhận đa chiều ở tất cả các bên tham gia vào cuộc chiến. Khác với \u0026ldquo;cuộc chiến 10k ngày\u0026rdquo;, bộ phim tài liệu trước đó \u0026ldquo;tránh\u0026rdquo; nói nhiều đến nội bộ việt nam cũng như quan hệ với Pháp. Ở seri phim này, ta có một cái nhìn rộng hơn, trung lập hơn.\nTập 1 với tên Deja vu (bóng ma quá khứ) được xây dựng với hai mốc thời gian đan xen, như sự ẩn dụ đoán trước được sự thất bại của người Mỹ cũng sẽ giống những gì đã diễn ra ở Pháp. Deja vu, là hiện tượng tâm lý về ảo giác một trải nghiệm tưởng như bản thân từng trải qua ở một môi trường và hoàn cảnh hoàn toàn khác được nhà biên kịch khéo léo đặt cho tượng đề của tập 1: nước Mỹ chưa từng trải qua chiến tranh với Việt Nam, nhưng sau mấy chục năm nhìn lại, họ đáng ra đã \u0026ldquo;cảm nhận\u0026rdquo; được kết cục đó.\nNgoài những thước phim đáng giá và những nhận định chi tiết cả hai phía, điều làm tôi cực kì ấn tượng là âm nhạc. Không chỉ thể hiện nội dung truyền tải, âm nhạc trong phim mang đến hơi thở văn hóa và xã hội những năm đó. Tôi rất thích các bản của Bob Dylan vầ Rosemary Clooney. Làm tôi nhớ đến cái đài radio quen thuộc của Fallout trong một \u0026ldquo;alternative history\u0026rdquo;.\nĐiều có tôi thích nhất chính là những diễn biến leo thang về chính trị và phản ứng của hai bên trong bối cảnh thế giới. Thêm vào đó, có những diễn biến chưa bao giờ được hai bên kể trước đó, ít nhất là theo trí nhớ của tôi. Đó là câu chuyện bức thư chưa bao giờ được gửi đến Tổng Thống Truman của Cụ Hồ. Đó là những động thái chính trị cực đoan của cả hai phía. Tôi thích nhất là giai đoạn ông Diệm thành lập chính quyền, Lê Duẩn thành Bí Thư Thứ Nhất và sự phức tạp về chính trị trên thế giới. Cảm giác bạn được xem Game Of Thrones phiên bản lịch sử vậy.\nNhững hình ảnh thì khỏi phải nói, giàu tính lịch sử và biểu tượng. Tôi phải thốt lên vậy khi xem những bức hình đầy ám ảnh.    Tập 1 đầy hấp dẫn, từ biên kịch phim, lối dẫn chuyện, hình ảnh và âm thanh.\n","href":"/vi/docs/vietnam_war-dejavu/","title":"The Vietnam War - Dejavu"},{"content":"   Lâu lâu tôi lại đi dạo một vòng ở Sin chơi. Một phần thường ngày cuối tuần chỉ cắm đầu trên lab, một phần thì muốn đi đông cho vui. Chứ thực ra, nếu đi chơi một mình, hay đi với hai thằng thì rất chán. Tôi nghĩ đi chơi trừ khi đi với bạn gái hoặc bạn khác giới, còn lại đực rựa đi chung với nhau thì 3-4 người là phù hợp. Tôi chưa đi Henderson Waves bao giờ, nghe đồn đâu ban đêm ở đó đẹp lắm. Nếu search trên mạng thì sẽ thấy rất nhiều kết quả gợi ý đi đến nơi đây vào ban đêm.\nGhé ở Vivo City, cả đám theo đường ngay phía trước ở Vivo City để leo lên núi (hay đồi). Tựa như là một khu rừng nguyên sinh vậy. Nghe cu Vinh kể là nơi đây có cả khỉ và động vật hoang dã. Rất nhiều người xài chai xịt tránh côn trùng, thành ra mùi xả lan khắp nơi làm tôi nghĩ nơi đây trồng nhiều.    Lâu rồi không đi đó lại nên lúc leo lên mệt đến đứt hơi. Tuy nhiên góc nhìn ở lại thật độc nhất, từ đây ta có thể nhìn ra phía cảng, một hướng khác có thể nhìn phía trung tâm. Đi một đoạn là tới Henderson Waves là một cây cầu gỗ với kiến trúc uốn lượn. Mình nghĩ đúng là khu này khi lên đèn hẳn là sẽ rất đẹp.    Sau khi đi mỏi giò, cả bọn quyết định ghé một nơi tên là Haw Par Villa, ở khá gần NUS. Để đi tới đây thì chỉ cần lên line màu vàng ở MRT, ở đó có luôn một trạm tên là Haw Par Villa. Nơi đây là một công viên với kiến trúc cổ ở trên đường Pasir Panjang với gần 1000 bức tượng và tranh vẽ. Chủ đề chính là câu chuyện văn hóa xã hội Trung Quốc, nhưng thực ra cái chính là nói về các tầng điện ngục theo quan điểm của người Trung Quốc.    Điểm thú vị ở đây là những người dựng lên công viên này chính là cha đẻ của dầu cao hổ  . Lúc đầu mình cũng hơi nghi nghi, vì lâu lâu lại thấy mây cái tượng xung quanh với 1 khối hình rất giống mấy chai cao hổ, khi đi về google thì đúng ra là vậy. Xem ra cái công viên này cũng gần 100 năm rồi. Các tượng ở đây có style khá là lạ và hơi dị, nhưng mình nghĩ nó xuất phát từ sự lai giữa phong cách Trung Quốc và các nước lân cận.\nSau khi bị nhầm tùng phèo bởi các trạm Bus để đến SMU, mà thực ra chỉ cần đi tàu đến quán \u0026ldquo;Kim Korean BBQ\u0026rdquo;, quán buffet thịt nướng khá ngon với giá tương đối ổn (29 SGD với người lớn, sinh viên có giảm giá). Phải nói là lần đầu tiên được đi ăn buffet nướng ở Sin sau gần 2 năm làm ở đây. Ngẫm lại mới thấy trải nghiệm ở Sin của mình ít thật. Hy vọng có nhiều dịp được đi nữa.\n","href":"/vi/docs/henderson_waves-haw_par_villa/","title":"Một vòng Henderson Waves và Haw Par Villa"},{"content":" Đôi khi có những thuật toán chỉ khiến bạn thốt lên: \u0026ldquo;xuất sắc, thông minh vãi cả đxx\u0026rdquo; Bài toán: Cho ngày, tháng, năm bất kì theo lịch Gregorian (lịch hiện nay), cho biết hôm đó rơi vào thứ mấy, tương ứng 0 -\u0026gt; Chủ Nhật, 1 -\u0026gt; Thứ Hai \u0026hellip; Tôi đang muốn nói tới phương pháp của Sakamoto được đề xuất năm 1992. (Code theo chuẩn K\u0026amp;R C).\ndayofweek(y, m, d) { static int t[] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4}; y -= m \u0026lt; 3; return (y + y/4 - y/100 + y/400 + t[m-1] + d) % 7; }  Quá đơn giản, quá thông minh. Nhưng hiểu được 3 dòng code này ta mới cảm nhận được tác giả \u0026ldquo;ranh\u0026rdquo; đến mức nào. Giả sử gọi ngày 1 tháng 1 trong 1 năm bất kì làm mốc, để biết được ngày 1 tháng tiếp theo rơi vào đâu, ta có 31 = 7*4+3. Tức là ngày 1 tháng 2 rơi sau 3 ngày so với 1/1 (Nếu ngày 1/1 là thứ Hai thì \u0026frac12; sẽ là thứ 5). t[] chính là offset cho ngày đầu tiên của tháng so với ngày 1/1, như vậy ta có t[] = {0, 3, 3, 6, 1, 4, 6, 2, 5, 0, 3, 5} (Hơi khác so với code). Chuyện tiếp theo là cộng offset đó với ngày (d-1) - khoảng cách từ ngày muốn tính đến đầu tháng , xong module cho 7 là ra được.\nTuy nhiên đây mới là trong 1 năm. Bởi vì 1 năm (ko nhuận) có 365 = 52*7+1. Tức là cứ mỗi năm trôi qua là có thêm 1 ngày dôi ra, vậy ta có năm y, ta phải cộng thêm y ngày dôi ra đó. Nhưng đây mới là tính những năm không nhuận.\nNhững năm nhuận, ta lại phải thêm cái ngày 29/2 vào trong, tức là nó sẽ thêm 1 ngày nữa, trong y năm? nếu có y năm nhuận thì sẽ có thêm x ngày được dồn vậy, $x = y/4 - y/100 + y/400$ (công thức tuy nhìn giống Inclusion-Exclusion Principle nhưng rốt cuộc ứ phải). Đơn giản là: những năm nhuận là năm (1) chia hết cho 4 nhưng không chia hết cho 100 hoặc (2) chia hết cho 400.\nNhưng vẫn còn vấn đề, cái ngày thêm vào của năm nhuận là ngày 29/2, tức là nếu năm đó là năm nhuận nhưng ngày và tháng thuộc tháng 1 hoặc 2 thì ta không được tính vào (ví dụ 10/1/2016). Tác giả giải quyết siêu đơn giản : y -= m \u0026lt; 3. Cứ hễ input tháng 1, 2 thì đẩy về năm trước đó. Và lúc đó thì năm nhuận sẽ hết nhuận.\nNhưng vẫn còn vấn đề, rốt cuộc toán tử đó áp dụng cho cả những năm không nhuận. Tức tháng 1, 2 năm nào cũng bị đẩy về trước đó 1 năm. Lúc này mảng t[] lại được dùng bằng cách bù cho tháng 1, 2, ta cộng 1 vào t[0] và t[1] và giữ nguyên các t[] còn lại Sau đó chuyển -1 trong d-1 vào offset, lúc đó ta sẽ được mảng t[] như trong code gốc.\nTa còn một vấn đề là xác định ngày ban đầu để làm mốc và độ lệch c của ngày gốc đó so với ngày Chủ Nhật với index = 0. Nhưng bằng kiểm chứng, người ta phát hiện ra c = 0. Wow. 😲\nMột thuật toán hay và đẹp, không chỉ tận dụng khả năng của ngôn ngữ lập trình, mà mỗi câu lệnh thể hiện được sự thông minh và khéo léo của tác giả.\nBonus Problem: Chứng minh tính đúng của thuật toán bằng quy nạp.\nReferences  Wiki: Determination of the day of the week Source  ","href":"/vi/docs/sakamoto_method/","title":"Bài toán chuyển ngày sang thứ"},{"content":"Ngày xưa mình mê coi phim này cực kì. Cứ mỗi lần đài lên sóng là rống họng lên hát: \u0026ldquo;quoài oa xinh xiên\u0026rdquo;. Đoạn nhạc phim mở đầu phải nói rất ấn tượng và mình nhớ mãi đến bây giờ. Hôm nay tình cờ được nghe bản lời Việt của 1 bài trong Hậu Tây Du Kí từ chế Bích Phương, tuổi thơ bỗng nhiên trào về.\n  Mới nghe là mình đã biết ngay rằng đây là bài nhạc phim bất hủ hôm nào. Thế là hứng chí lên tìm bản mở đầu, cái bản \u0026ldquo;quoài oa xinh xiên\u0026rdquo; đó\n  Lúc nhỏ coi phim này khá là vui. Chuyện đầu tiên là mấy viên xá lợi, mình thì cứ nghĩ là \u0026ldquo;xí lị\u0026rdquo;, hoặc \u0026ldquo;xá xị\u0026rdquo; gì đó. Phim này thì đánh đấm quá ảo, chưa kể là câu chuyện tam giới phức tạp hơn trong Tây Du Kí bản gốc. Mình vẫn còn nhớ có những chi tiết liên kết với phần trước như vụ \u0026ldquo;Tôn Hành Giả - Giả Hành Tôn\u0026rdquo;, \u0026ldquo;Vô Thiên\u0026rdquo;, rồi cả chuyện hồi sinh của Phật Tổ, các yếu tố thần thoại và fantasy được đề cập nhiều hơn. Mặc dù tạo hình không thân quen như trước nhưng cũng rất đáng xem nếu xét những phim ra sau bộ kinh điển 1986.\n","href":"/vi/docs/hau_tay_du_ky/","title":"Hậu Tây Du Kí"},{"content":"Lâu lắm rồi tôi mới được xem một bộ phim hay đến vậy, có lẽ từ khi xem La La Land, đó là những bộ phim buộc bạn phải ngẩn ngơ một lồi lâu và không ngừng suy nghĩ về nhân vật và những lời thoại. Không có những kĩ xảo tráng lệ hay cốt truyện hại não, bộ phim đơn giản chỉ là câu chuyện của một thanh niên với bộ óc thiên tài trải nghiệm những thay đổi trong cuộc đời. Điều hại não nhất chăng chính là những bài toán được đề cập trong bộ phim, một phần làm tôi rất thích thú.\nCó lẽ nhiều người sẽ quan tâm nhiều hơn về những biến đổi của nhân vật Will, còn với tôi, tôi lại thích hình tượng hai giáo sư Sean và Lambeau. Cả hai là sự nhân cách hóa lựa chọn của Will. Khi cả hai giáo sư nói chuyện với nhau, mà đa phần cãi nhau vì bất đồng quan điểm, những gì thảo luận cho thấy họ từng là những gã thiên tài với đam mê toán học, nhưng Lambeau trở thành một “mathematical god” - với giải Field danh giá, còn Sean thì chọn một hướng đi hoàn toàn khác. Cả hai đều dù trái ngược nhau nhưng lại là phần bù của nhau. Hình ảnh hai người, và cả Will khiến tôi ám ảnh. Một phần trong con người tôi giống Lambeau: Lambeau ám ảnh bởi sự thành công, ám ảnh bởi Field danh giá, ám ảnh bởi vinh quang trong nghiên cứu. Tôi từng, và có lẽ cũng đang có những suy nghĩ tương tự, nỗi ám ảnh phải làm mọi thứ để trở thành “expert” trong lĩnh vực mình làm và lúc nào cũng ép bản thân tới hạn của công việc, như cách mà Lambeau nói về chính mình:\n I am what I am today because I was pushed and because I learned to push myself\n Nhưng ấn tượng hơn cả là Sean, Sean đã đưa tôi một bài học khi nói: “There\u0026rsquo;s more to life than a fuckin\u0026rsquo; Field\u0026rsquo;s medal.” Chính Lambeau thừa nhận Sean thông minh hơn ông, chính Lambeau cũng thừa nhận Sean từng có thể có Field, nhưng ông đã không làm, ông đã không hối hận về quyết định của mình.\nBộ phim có rất nhiều đoạn hội thoại rất ý nghĩa, nhưng có lẽ đoạn hay nhất là khi Sean nói chuyện với Will, về sự khác nhau giữa kiến thức và sự thông thái: bạn có thể có được kiến thức bằng cách đọc rất nhiều sách và sở hữu một bộ óc của thiên tài; nhưng bạn không có được sự thông thái nếu không thực sự cảm nhận.\n  Điều đặc biệt ấn tượng với tôi là khi Sean liên tục hỏi Will: “What do you wanna do?” được lặp đi lặp lại, như sự ẩn dụ của bộ phim dành cho người xem, đó chính là câu hỏi dành cho người xem. Đoạn cãi nhau của Sean và Lambeau và chính câu hỏi : “What do you wanna do?” khiến tôi luôn bần thần sau bộ phim, rốt cuộc, điều gì là điều tôi thực sự muốn làm?\n  Mỗi phân cảnh trong phim có lẽ là một câu chuyện đầy ý nghĩa về cuộc sống. Và những đoạn hội thoại ấy sẽ còn lưu lại trong tâm trí người xem thời gian dài.\nMột bộ phim quá hay, và thật không ngờ là Matt Demon và Ben Affleck viết kịch bản xuất sắc đến vậy, đồng thời diễn xuất của các diễn viên hết sức thuyết phục. Từ bối cảnh, kịch bản, biên kịch, tất cả tạo nên một bộ phim giàu tính nghệ thuật và ý nghĩa, đó cũng chính là lí do mà bộ phim có 9 đề cừ Oscar và giành được tượng vàng cho hạng mục Nam Diễn Viên Phụ Xuất Sắc (Robin William) và Kịch Bản Gốc Hay Nhất (Matt và Ben).\nVề những câu hỏi toán trong bộ phim, điều thú vị là Lambeau đạt giải Field trong toán tổ hợp, và đó là lí do mà mấy câu hỏi thách thức để tìm ra thiên tài toán học mới đều liên quan đến mảng này. Các câu hỏi khá hay về đồ thị: từ ma trận cạnh kề và tính chất của nó, từ hàm sinh đến phương pháp đếm đến bài toán tô màu đồ thị. Câu chuyện về các nhà toán học được đề cập trong phim cũng rất thú vị: Ranamujan (có lẽ cuộc đời và trí tuệ của ông thú vị đến nỗi tôi thường xuyên thấy bóng dáng của ông trong các lĩnh vực mình tìm hiểu: trong Hỗn Độn và Hài Hòa của gs. Trịnh Xuân Thuận, trong Volume 1 của The art of computer programming đến bộ phim The Man Who Knew Infinity trên chuyến bay đi Hawaii), Ted Kaczynki: một giáo sư toán học Berkeley, đồng thời cũng là một tên khủng bố. Có lẽ cần đến một post hàng toàn khác để có thể nói về lịch sử thú vị của những bài toán trong phim này.\n  ","href":"/vi/docs/review_good_will_hunting/","title":"Good Will Hunting và những bài toán đồ thị "},{"content":"Tuổi trẻ, tình yêu và khát vọng. Đó là La La Land. Một tựa phim đầy mơ hồ. Nhưng không phải, có lẽ âm \u0026ldquo;La La Land\u0026rdquo; vang lên như một thứ âm nhạc của tuổi trẻ, vượt qua những rào cản của ngôn ngữ, đó là chốn thiên đường mà những kẻ khao khát từng chìm đắm và mơ mộng.\nXem La La Land tôi nhớ đến Black Swan và Whiplash, cũng là câu chuyện về những người trẻ với khát vọng và niềm đam mê của mình.\nBlack Swan nói về đam mê đến ám ảnh, đến những vũ điệu balê và tác phẩm Hồ Thiên Nga nổi tiếng. Đó là câu chuyện về nghệ thuật, về bản ngã và cái giá của nghệ thuật. Cô gái (Nina - Natalie Portman) trong phim ám ảnh vai diễn đến nỗi trong tưởng tượng đã giết chết bạn diễn của mình, thoát khỏi vỏ bọc bé bỏng mỏng manh của thiên nga trắng đến hoàn toàn hóa thân thành Thiên Nga Đen với sự lôi cuốn và khao khát mãnh liệt. Nina Thoát khỏi giới hạn và khuôn khổ của bản thân để đạt đến sự hoàn hảo.\nWhiplash lại là câu chuyện về chàng trai Andrew đam mê chơi trống. Giống Black Swan, chàng trai khi muốn vượt đến một tầm cao mới phải trả giá bằng tổn thương cả thể xác và tinh thần và cố gắng thoát khỏi vùng an toàn của chính bản thân. Tôi nghĩ hai bộ phim trên bao giờ cũng mang lại động lực cho người trẻ tìm đến sự toàn mỹ, cái đích đến của một tài năng được công nhận không bao giờ là dễ dàng.\nLa La Land chính là thành quả của tuổi trẻ và đam mê của Damien Chazelle. La La Land là jazz, La La Land là sự tri ân của chàng sinh viên Harvard với khát vọng điện ảnh đã viết nên trong suốt thời gian ở trường. Đó là câu chuyện của chính chàng trai, gói gém trong những bản nhạc jazz trữ tình, kể về thổn thức của tuổi trẻ của anh.\nĐó cũng là thổn thức của những người trẻ.\nJazz là phương tiện để chàng mang đến nỗi khắc khoải về tuổi trẻ. Như chính nhân vật Sebastian trong phim khi kể về nguồn gốc của jazz, jazz là sự tương tác của những con người ở các tầng lớp với nhau với ngôn ngữ khác biệt, họ có câu chuyện của riêng họ. Chính sự tương tác của những cảnh đời vậy tạo nên jazz. Còn phương tiện nào tuyệt hơn để nhà biên kịch truyền tải về tuổi trẻ của mình.\nLa La Land rất đẹp, đẹp từ dựng hình, từ âm thanh đến trang phục. Đó cũng chính là con mắt của người trẻ với cuộc đời, đầy ước mơ. Và đó chính là những gì đẹp đẽ nhất mà tuổi trẻ mong có được. Rất khó để diễn tả gam màu chủ đạo của bộ phim. Rực rỡ, tươi tắn. Jazz. Hollywood. Bồng bột và nhiệt huyết. Ồ, đó là màu sắc của điện ảnh.\nVới tôi La La Land không phải là cả bộ phim, La La Land thực sự chính là trường đoạn kết thúc phim. Mọi thứ đều đẹp, mọi giấc mơ đều chạm tới, và hạnh phúc tràn ngập. Tất cả cuộn trong chất nhạc, gam màu sắc tươi tắng và lãng mạn. Và đúng như những gì dự tính, La La Land được miêu tả bằng jazz, bằng hình ảnh và tuyệt nhiên không một lời thoại. Bởi trong giấc mơ nào, đó là lời tự tình của đạo diễn, của người xem với chính họ. Đạo diễn đưa bàn tay đễn dẫn lối người xem đến La La Land của riêng họ.\nNhưng cái tài của đạo diễn chính là khiến người xem thổn thức với La La Land, họ cay đắng nhận ra, rốt cuộc, tên tác giả láo cá đã kể 1 câu chuyện khác suốt hai tiếng đồng hồ. Ở đó nhân vật của chúng ta luôn hoài nghi về năng lực của mình, và họ buộc phải làm những việc họ không muốn làm, phải chọn con đường thực tâm không muốn đi. Tôi rất thích hai nhân vật chính, hoàn cảnh của họ, động lực của họ phần nào giống bản thân tôi: lạc lõng giữa những quyết định, với mục tiêu và hoài bão của bản thân. Đó là lí do tôi không chê trách gì quyết định của Mia lẫn Sebastian, tấm vé đến La La Land không dành cho mọi người. Vé đôi lại càng kham hiếm.\nGiấc mơ tuyệt mỹ năm nào dần dần rời xa như cái ánh sáng xanh phía bên kia hồ dần rời xa Gatsby. Phải chăng, tất cả cũng đều là giấc mơ. Gatsby chạy theo giấc mơ về sự vương giả và tình yêu, mà không gì khác là hình tượng của giấc mơ Mỹ. Mia và Sebastian cũng đuổi bám theo giấc mơ nghệ thuật riêng mình, chính là hình tượng của kinh đô Hollywood mà Sebastian nói:\n L.A. worships everything and values nothing\n Để rồi đọng lại, La La Land tuy rất đẹp, nhưng rất buồn. Bởi vùng đất ấy mãi mãi chỉ nằm trong hồi ức một thời xa lắm.\nCó lẽ tôi không nói nhiều về sự thành công của phim. 11 đề cử giải Oscar và 5 giải thưởng được trao đã nói lên điều đó. Nhưng điều tôi đặc biệt thích, đó có lẽ là âm nhạc và hình ảnh. Hơn hết hai yếu tố trên đã trở thành một người kể chuyện trong phim. Và sự kiện trao nhầm giải ở Oscar có lẽ cũng là điều thú vị cho bộ phim. Dù rằng tình huống này thạt oái ăm cho cả đoàn phim của La La Land lẫn Moonlight.\n  Honest Trailer có một video xuất sắc về vụ này :lol:\n  ","href":"/vi/docs/la_la_land/","title":"La La Land"},{"content":" rand() Bài talk khá hay về việc sinh số ngẫu nhiên (trong trường hợp này là ngôn ngữ C++). Làm mình nhớ đến 1 bài tập trong The Art of Computer Programming (TAOCP - Vol 2): \u0026ldquo;hãy thử thay đổi random generator trong máy tính bằng một thuật toán tốt hơn, và quan sát điều kì diệu sẽ xảy ra\u0026rdquo; Bài talk duy chỉ nói về việc dùng hàm rand() và đặc biệt sử dụng chung với % (mod) hay floating point scale là thực sự sai lầm và nghiêm trọng . Đặc biệt, nó không hề tạo ra uniform distribution như ta thường nghĩ, thậm chí nó khiến cho 1 số giá trị đặc biệt hiếm khi xảy ra 😄\nBản chất hàm rand được implement khá đơn giản linear congruential  nhờ tận dụng tính chất của số căn nguyên thủy (xem Lehmer random generator). Điều thú vị nằm ở chỗ 1 tính chất không liên quan mấy bên lý thuyết số lại hỗ trợ cho việc sinh số ngẫu nhiên. Btw, TAOCP Vol 2 nói khá kĩ về vấn đề này. Một kỹ thuật để check xem empirical results có đúng với probabilities không (uniform distribution với biến ngẫu nhiên rời rạc), đó là dùng Chi squared test.\nLink: https://channel9.msdn.com/Events/GoingNative/2013/rand-Considered-Harmful\n","href":"/vi/docs/rand/","title":"rand() is harmful"},{"content":" Các ví dụ về thuật toán ngẫu nhiên Tiếp tục seri về thuật toán ngẫu nhiên, trong bài viết này mình ghi lại 3 ví dụ điển hình trong họ bài toán này. Tất cả các ví dụ đều nằm trong cuốn sách Randomized Algorithms\nRandomized Quicksort Thuật toán quicksort có lẽ là một trong những thuật toán khá dễ hiểu khi tìm hiểu về các thuật toán ngẫu nhiên. Thử tưởng tượng ta cho quicksort thông thường chạy 10 lần với dữ liệu đã sắp xếp với randomized-quicksort cũng với cấu hình như vậy, ta sẽ thấy sự khác biệt lớn.\nThuật toán Chứng minh Cho dữ liệu đầu vào gồm $n$ phần tử khác nhau. Gọi $S_i, 1 \\leq i \\leq n$ là phần tử rank i (phần tử nhỏ thứ i) trong mảng, đồng thời ta có $X_{ij}$ biến ngẫu nhiên bằng 1 nếu xuất hiện phép so sánh của 2 phần tử $S_i$ và $S_j$ trong quá trình thực thi, bằng không nếu không xuất hiện phép so sánh nào.\nNhư vậy, độ phức tạp của randomized-quicksort được tính thông qua quá trình sắp xếp mảng theo pivot mà chi phí chính nằm ở phép so sánh các phần tử, tổng chi phí chính là\n$$ \\sum_{i=1}^n \\sum_{j\u0026gt;i} X_{ij} $$\nTuy nhiên, điều ta quan tâm hơn ở đây là kì vọng chi phí trong các lần thực thi:\n$$E \\left [ \\sum_{i=1}^n \\sum_{j\u0026gt;i} X_{ij} \\right ] = \\sum_{i=1}^n \\sum_{j\u0026gt;i} E[X_{ij}]$$\nCông thức trên được xây dựng dựa vào một tính chất của kì vọng: tính tuyến tính của kì vọng. Như vậy kì vọng của tổng các chi phí so sánh chính bằng tổng của từng kì vọng của biến ngẫu nhiên $ X_{ij}$. Gọi $p_{ij}$ là xác suất để $X_{ij}=1$. Ta có:\n$$ E[X_{ij}] = p_{ij} * 1 + (1-p) * 0 = p_{ij} $$ $$ E \\left [ \\sum_{i=1}^n \\sum_{j\u0026gt;i} X_{ij} \\right ] = \\sum_{i=1}^n \\sum_{j\u0026gt;i} p_{ij} $$\nBài toán được qui về việc tính xác suất khi nào phép so sánh giữa hai phần tử $S_i$ và $S_j$ xuất hiện.\nNếu ta xem quá trình thực thi của randomized-quicksort là quá trình xây dựng cây nhị phân: với mỗi node chính là 1 pivot tại thời điểm gọi hàm partition, kết quả hàm partition ta có được 2 cây con bên trái và phải của node pivot dùng để so sánh. Nếu $S_i$ và $S_j$ nằm ở hai nhánh con trái-phải thì phép so sánh giữa hai phần tử này chắc chắn không xảy ra. Như vậy $S_i$ và $S_j$ có quan hệ cha con - một trong hai phần tử phải thuộc node cấp lớn hơn của node kia. Một giả thuyết khác cần xem xét đó là xác suất các số được chọn làm pivot phải bằng nhau (uniform distribution) - có được giả thuyết này ta mới tính được độ phức tạp trong thời gian trung bình được.\nNhư vậy, để $X_{ij}=1$ khi và chỉ khi một trong hay vị trí $S_i$ hoặc $S_j$ được chọn, và đó là $p_{ij} = \\frac{2}{j - i + 1} $ (Xác suất này được tính khi loại đi xác suất chọn phải những pivot nằm bên trái của $S_i$ hoặc nằm bên phải của $S_j$)\nNhư vậy ta có:\n$$E \\left [ \\sum_{i=1}^n \\sum_{j\u0026gt;i} X_{ij} \\right ] = \\sum_{i=1}^n \\sum_{j\u0026gt;i} \\frac{2}{j - i + 1}$$\nĐặt $k = j - i + 1$, ta được:\n$$\\sum_{i=1}^n \\sum_{j\u0026gt;i} p_{ij} \\leq \\sum_{i=1}^n \\sum_{k=1}^{n-i+1} \\frac{1}{k}$$\n$$\\leq 2 \\sum_{i=1}^n \\sum_{k=1}^{n} \\frac{1}{k}$$\n$$= 2n \\sum_{k=1}^{n} \\frac{1}{k}$$\n$\\sum_{k=1}^{n} \\frac{1}{k}$ chính là chuỗi harmony và tổng này sẽ hội tụ về xấp xỉ của $ln(n)$. Và như vậy\n$$E \\left [ \\sum_{i=1}^n \\sum_{j\u0026gt;i} X_{ij} \\right ] \\leq 2n\\log{n}$$\nRandom Mincut Ví dụ Giả sử ta có dữ liệu facebook của đám bạn cấp 3 và đang tò mò xem trong chục năm qua, những đứa bạn đó có lập thành nhóm chơi thân nào không. Dữ liệu đầu vào là danh sách các bạn trong lớp cấp 3 và mỗi quan hệ từng người với nhau (quan hệ bạn cấp 3, bạn đại học, đồng nghiệp, quan hệ nam nữ, vợ chồng).\nGiả sử ta tạo một đồ thị với đỉnh là một người trong lớp, a có thể nối với b thông qua các cạnh nối:\n Bạn cấp 3 (cái này chắc chắn) Bạn đại học Đồng nghiệp  Việc tìm ra nhóm bạn thân - tức gắng bó với nhau sau thời gian cấp 3 chính là việc tìm cách tách đồ thị lớn này thành những đồ thị con.\nNhững bài toán chia cắt đồ thị gọi là graph cut, nếu trong bài toán yêu cầu tìm ra đoạn cắt nào có chi phí thấp nhất: cắt ít số cạnh nhất - thì đó chính là bài toán tìm mincut.\nTrong ví dụ này ta xét đồ thị là một multigraph - tức đồ thị có thể có nhiều cạnh cùng nối chung hai điểm. Một số định nghĩa cho phép multigraph là đồ thị có các cạnh lặp (self-loop). Để thuận tiện cho việc chứng minh và minh hoạ, các đồ thị được đề cập trong bài là các đồ thị vô hướng.\nKarger Mincut Một quá trình quan trọng trong thuật toán Karger là Edge Contraction - gộp cạnh. Cho một cạnh $ e = {u, v}$, sau phép gộp cạnh ta sẽ có được một đỉnh mới là $uv$ trong đó tất cả các cạnh nối từ $u$ đến $v$ hay ngược lại đều bị loại bỏ, đồng thời các cạnh lặp (self-loop) cũng bị xoá bỏ.\nVới các cạnh khác $ e’ = {u, w}$ hay $e’={v, w}$ đều trở thành $e’={uv,w}$.\nMột cách đơn giản: phép gộp cạnh sẽ nhập 2 đỉnh lại với nhau - xoá toàn bộ các cạnh nối 2 cạnh cũ và giữ lại những cạnh nối 2 đỉnh đó với các đỉnh khác trong đồ thị.\nThuật toán được mô tả như sau:\n1. Chọn ngẫu nhiên (theo phân phối đều) một cạnh trong đồ thị. 2. Thực hiện phép gộp cạnh vừa chọn. 3. Lặp lại bước (1) cho đến khi số đỉnh trong đồ thị còn lại 2. 4. Output: min-cut là các cạnh còn lại trong đồ thị  Tính đúng đắng của giải thuật Để có thể tính được độ phức tạp trong thời gian trung bình, ta cần quay lại một chút về các tính chất của đồ thị. Cho đa đồ thị (multigraph) $G=(V, E)$ gồm các đỉnh $V$ và các cạnh $E$. Gọi $d(v)$ là bậc của đỉnh $v$ là tổng số các cạnh liên thuộc với $v$. Ta có tính chất sau:\n$$\\sum_{v \\in V} d(v) = 2 | E |$$\nGọi $C$ là lát cắt có kích thước nhỏ nhất $k$ - tức số lượng các cạnh trong lát cắt đó là $k$. Do đó, bậc tối thiểu của mỗi cạnh trong đồ thị này là $k$. Bởi nếu tồn tại một đỉnh có bậc nhỏ hơn $k$ thì lắt cắt $k$ không phải là lát cắt nhỏ nhất.\nNhư vậy ta có:\n$$nk \\leq \\sum_{v \\in V} d(v) = 2 | E |$$ $$|E| \\geq \\frac{nk}{2}$$\nTa thấy xác suất để thuật toán gộp cạnh chọn đúng ngay 1 cạnh trong C chính là\n$$\\frac{k}{|E|}$$\nkết hợp với bất đẳng thức phía trên, ta được:\n$$\\frac{k}{|E|} \\leq \\frac{2k}{nk} = \\frac{2}{n}$$\nNhư vậy, xác suất để thuật toán gộp cạnh không chọn phải các cạnh của $C$ là $p_n $.\nTa có $p_n \\leq (1-\\frac{2}{n})p_{n-1} $ .\nĐồng thời ta cũng có $ p_2 = 1 $ lí do là bởi Karger chỉ chọn cạnh để gộp khi $ \\vert V \\vert \u0026gt; 2 $\nNên khi $ n=2 $ thì biến cố chọn phải cạnh để gộp nằm trong $ C $ chắc chắn không xảy ra.\nXác suất $p_n$ có cận như sau:\n$$p_n \\geq \\prod_{i=0}^{n-3} \\left (1 - \\frac{2}{n-i} \\right ) = \\frac{2}{n(n-1)}$$\nĐể dễ tưởng tượng hơn, ta có thể phân tích một chút về trường hợp Karger không tìm ra được mincut, rõ ràng xác suất đó chính là $ 1 - \\frac{2}{n(n-1)}$, để tăng độ chính xác, ta có thể cho Karger chạy $k$ lần. Lúc này, xác suất Karger không tìm ra được mincut là: $ \\left (1 - \\frac{2}{n(n-1)} \\right )^k$. Có một bất đẳng thức thú vị ở đây:\n$$\\frac{1}{4} \\leq \\left (1 - \\frac{1}{x} \\right )^ x \\leq \\frac{1}{e}$$\nGiả sử $k = \\frac{n(n-1)}{2}\\ln n$ ta có được kết quả khá đẹp như sau:\n$$\\left (1 - \\frac{2}{n(n-1)} \\right )^{\\frac{n(n-1)}{2}\\ln n} \\leq \\left (\\frac{1}{e} \\right )^{\\frac{n(n-1)}{2}\\ln n} = \\left (\\frac{1}{e} \\right ) ^{\\ln n} = \\frac{1}{n}$$\nBinary Planar Partitions Giới thiệu Binary Planar Partitions (trong trường hợp tổng quát là Binary Space Partitions) là một phương pháp phổ biến được sử dụng nhằm chia cắt không gian thành các tập lồi (convex set) chứa các siêu phẳng - hyperplane. Sự chia cắt này tạo nên một cấu trúc dữ liệu được gọi là cây BSP.\nBSP có nhiều ứng dụng, đặc biệt là trong các bài toán về đồ hoạ. Điển hình như trong bài toán dựng hình (xác định đối tượng nào được dựng trong khung hình từ góc một góc nhìn nào đó), trong hệ thống CAD, phát hiện va chạm trong robotics, cũng như trong các bài toán chứa các cấu trúc không gian phức tạp.\nTrong trường hợp tổng quát, cây BSP, từ mỗi node của mình sẽ chia không gian thành hai nửa siêu phẳng, từ mỗi nửa siêu phẳng đó sẽ tiếp tục được chia cắt thành các nửa siêu phẳng nhỏ hơn sao cho những node lá cuối cùng sẽ chứa 1 đối tượng mà thuộc không gian. Có thể thấy cây BSP là trường hợp tổng quát của cây k-d, và Quadtree.\nVí dụ Để đơn giản bài toán ta xét trường hợp mặt phẳng với dữ liệu đầu vào là tập các đoạn thẳng sao cho từng cặp trong tập không giao nhau $S={s_1, s_2, \\dots, s_n}$, output của bài toán là một cây BSP mà mỗi vùng trong mỗi node lá chỉ chứa 1 một đoạn thẳng.\n Chọn ngẫu nhiên (theo phân phối đều) một hoán vị $\\pi$ trong tập hoá vị của ${1, 2, \\dots, n }$ (gồm $n!$ phần tử). Tồn tại một vùng chứa nhiều hơn 1 đoạn thẳng:\n2.a Cắt vùng này bởi đường thẳng $l(s_i)$ trong đó $i$ là phần tử đầu tiên trong hoán vị (ở đây đường thẳng $l$ sẽ chứa $s_i$) $\\pi$ sao cho $s_i$ cắt vùng đang xét.\n  Phân tích Gọi biến $X_{ij}$ là biến ngẫu nhiên và $X_{ij}=1$ khi đường thẳng chứa $s_i$ cắt $s_j$ trong một vòng gọi đệ quy nào đó, $X_{ij}=0$ trong trường hợp ngược lại.\nỞ đây ta muốn xét xem kì vọng số lần thuật toán này cắt phải một đoạn thẳng trong tập đầu vào $S$.\n$$\\mathbf{E} (X) = \\mathbf{E} \\left [ \\sum_{i=1}^{n} \\sum_{i=1}^{n} X _ {ij} \\right ]$$ $$= \\sum_{i=1}^{n} \\sum_{i=1}^{n} \\mathbf{E} [X _ {ij} ]$$ $$= \\sum_{i=1}^{n} \\sum_{i=1}^{n} Pr [X _ {ij} = 1 ]$$\nBài toán được quy về việc tính xác suất $Pr[X_{ij}=1]$. Gọi $t$ là giao điểm của $s_i$ và $s_j$, $index(i,j)=t$ nếu $s_i$ cắt $t-1$ đoạn thẳng trước khi giao với $s_j$, như ví dụ bên dưới $s_{ij}=4$. Trường hợp hai đoạn thẳng không cắt nhau thì $S_{ij}=\\infty$.\nBởi đường thẳng chứa $s_i$ bất kì có thể tiến vô cùng về hai phía nên tồn tại hai đoạn sao cho $index(s_i, s_j) = index(s_i, s_k)$. Nếu $index(s_i, s_j)=t$ ta gọi $s_{i1}, s_{i2}, \\dots, s_{it}$ là những đoạn thẳng mà $s_i$ sẽ cắt trước khi giao với $s_j$, xác suất đề sự kiện này xảy ra là $\\frac{1}{t+1}$\nCho một đoạn $s_k$ cố định và $m \\in {0, 1, 2, dots, n-2 }$ tồn tại tối đa hai đoạn thẳng $s_l$ sao cho $index(s_l, s_k)=m$\nCận trên được tính như sau:\n$$\\mathbf{E}[X] = \\sum_{i=1}^{n} \\sum_{j=1}^{n} Pr [X _ {ij} = 1 ]$$ $$\\leq \\sum_{i=1}^{n} \\sum_{j=1}^{n} \\frac{1}{index(i, j) + 1}$$ $$\\sum_{i=1}^{n} \\sum_{k=2}^{n} \\frac{2}{k}$$ $$= 2n \\ln n$$\nTài liệu tham khảo.  Introduction to Randomized Algorithms Randomised Algorithms  ","href":"/vi/docs/randalgs_ex/","title":"Các thuật toán ngẫu nhiên"},{"content":"Từ nhỏ, tôi luôn thích những cuộc phiêu lưu và những câu chuyện giả tưởng. Từ cuộc phiêu lưu của Robinson đến con tàu chu du hai mươi ngàn dặm dưới đáy biển của Jules Verne hay cuộc chiến ngoài vũ trụ trong Starcraft. Star Wars cũng không phải là ngoại lệ, dĩ nhiên tôi không phải fan cuồng đến mức đọc từng trang wiki về từng nhân vật, thậm chí đến những nhân vật xuất hiện trong phim có vài giây cũng có hẳn [trang wiki riêng cơ mà](https://www.youtube.com/watch?v=bsb9ZTmbSKQ\u0026amp;feature=youtu.be\u0026amp;t=38s). Và dù biết đến Star Wars khá muộn màng vào những năm đại học, câu chuyện về cuộc chiến trong dải thiên hà xa xôi luôn khiến tôi thích thú.  Hôm nay tôi dành ngày nghỉ lễ để xem Star Wars VII: The Force Awakens. Cảm nhận của tôi không gì ngoài một từ: xuất sắc.\nTrước khi vào rạp, tôi không mong nhân vật nữ mới sẽ mang đến cảm giác như công chúa Leia từng mang đến. Nàng mang một vẻ đẹp nhẹ nhàng với tính cách vừa là của một nàng công chúa kiêu kì vừa là một người tướng của quân Kháng Chiến. Ngoài ra nàng còn rất thông minh và bá đạo, đôi lúc nàng “chơi lầy” khiến thanh niên Han Solo nhiều lúc cứng cả họng. Với việc xây dựng nhân vật nữ mới Rey xuất thân không phải tầng lớp quí tộc, một phần mang hơi hướng hiện đại khiến tôi có cảm giác bất an cho nhân vật này. Tôi cũng không biết cách tiếp cận của đạo diễn sẽ thế nào. Trong khi các tập IV, V và VI là những tượng đài kinh điển của điện ảnh và là biểu tượng của văn hoá Pop, tập I, II, III đã khiến khán giả thất vọng vì kịch bản sơ sài, hiệu ứng hình ảnh sử dụng thừa thãi và nhân vật trẻ trâu Anakin xứng đáng được liệt vào danh sách những đứa trẻ trâu nhất trong lịch sử điện ảnh, áp lực đè lên tập VII không hề nhỏ. Họ phải làm vừa lòng những fan trung thành nhất, khôi phục lại hình ảnh mang tính chất biểu tượng, và hơn thế nữa là tạo nên một thế hệ những khán giả mới.\nTheo quan điểm của tôi, Star Wars 7 đã thành công ngoài mong đợi.\nTính đến thời điểm hiện tại, nói về mặt doanh thu toàn cầu đã là một minh chứng hùng hồn về việc Star Wars 7 đã chinh phục trái tim người hâm mộ. Với điểm IMDB và điểm Tomatoes khá cao đã phản ảnh được chất lượng của bộ phim trong mắt những nhà phê bình. Và nếu có dịp, tôi vẫn sẽ ra rạp và xem lại bộ phim đầy hấp dẫn này.\nVới những người đã xem các tập trước, đặc biệt là tập IV, V và VI thì Star Wars VII như một cầu nối kí ức. Chúng ta được gặp lại Han Solo và Chewbacca, được gặp lại Leia và các droid C-3PO, R2-D2. Tính cách của họ vẫn vậy, chàng cao bồi Han Solo vẫn tưng tửng như ngày nào, nàng Leia vẫn đẹp (lão) rạng ngời. C-3PO vẫn nhiều chuyện như xưa, R2-D2 thì vẫn “nghiêm túc” với sứ mệnh của mình. Luke giờ thì là phiên bản 2 của Obi-wan Kenobi. Những tàn tích của cuộc chiến tranh với xác tàu chiến và cỗ máy AT-AT nằm la liệt, đội quân stormstrooper vẫn là bia tập bắn cho phe chính nghĩa, cùng rất nhiều thiết bị vũ trụ làm fan cảm thấy bồi hồi xúc động.\nVà chúng ta cũng được gặp những con người của thế hệ sau: Rey, Ren, Finn và Poe. Cuộc đời và số phận của họ đang dần được hé lộ cùng với bộ phim. Điểm hay của bộ phim chính là việc kế thừa và tôn trọng những gì thuộc về “truyền thống” của Star Wars như đoạn mở đầu phim (khiến bản thân mình khi nghe nhạc còn rùng mình vì thích thú) hay cũng những con quái vật trên màn chiếu hologram, hệ thống chiến đầu trên tàu Falcon hay những cảnh rượt nhau sát sườn hệ thống vũ khí của phe Bóng Tối. Star Wars vừa là một câu chuyện nối tiếp, vừa là bản cover (tôi không gọi nó là remake) tuyệt vời. Giữ lại cái chất trong Star Wars và mang một luồng gió mới cho dòng phim kinh điển.\nÂm thanh và nhạc nền đóng một phần không nhỏ trong thành công của bộ phim. Cả những kĩ thuật sử dụng hiệu ứng ánh sáng và hoá trang, Star Wars 7 đã tránh được vết xe đổ của bộ prequel trước đó. Hình ảnh hành tinh sa mạc và những chủng tộc hành tinh xuất hiện, đống tàn tích sau cuộc chiến tranh đã thể hiện rõ nét hơn về những gì sau sự kiện “Return of The Jedi”. Khi các phần prequel bị thiên hạ thém cà chua vì lạm dụng kĩ xảo, chúng ta càng không mong đợi Star Wars 7 mang đến sự đột phá về cách làm phim, nhưng cách mà Star Wars 7 đã làm đầy thông thinh, kết hợp yếu tố hiệu ứng hình ảnh với practical effect, vừa mô tả được sự hùng vĩ cả các hành tinh, tàu vũ trụ, những trận chiến khốc liệt, vừa tạo nên những thước phim rất chân thật.\nTôi không rõ Kylo Ren vì sao lại quá lo lắng vì không đạt được sức mạnh như ông ngoại mình. Nhưng tôi đảm bảo độ trẻ trâu của nhân vật này đã bằng với Darth Vader lúc còn là Anakin. Thật sự tôi cũng không hiểu sao mấy ông đạo diễn thích làm nhân vật phản diện trẻ trâu đến thế. Nhưng điểm cộng cho Ren đó là khi anh tức giận, thay vì bóp phát chết luôn tướng của mình như ông ngoại làm, anh ta lấy kiếm chém búa lua xua - ít ra anh còn biết bảo vệ nguồn nhân lực và người có tài. Đoạn đầy nước mắt của Ren theo mình nghĩ là do chả diễn sâu để ông bố không đề phòng. Coi như là một điểm cộng trong sự thủ đoạn của anh ấy. Finn và Rey rất dễ thương - nhưng bản thân mình thấy độ dễ thương và khùng không bằng Leia và Han. Rey thì cứng cỏi và mạnh mẽ hơn Leia nhiều, một phần là do nàng có thần lực. Mình rất thích Poe, chàng phi công xuất sắc và cũng hơi tưng tửng này. Tuy nhiên so về độ điên và bảnh thì không thể bằng Han Solo rồi.\nTóm lại, câu chuyện từ phần 1 đến phần 7 rốt cuộc xoay quanh “gia đình bá đạo” Skywalker cho cả thiên hà ăn hành ngập mặt và gánh chịu bao nhiêu tai ương. Con gái nhà này thì khùng khùng thất thường lại chảnh (đắng lòng khi phải nhận xét về Leia yêu dấu như vậy), con trai thì đứa nào cũng nhăm nhe sát hại cha mình, nếu không về mặt sáng thì cũng về mặt tối, thằng không bị chặt tay cũng bị ngâm mình trong dung nham, và điển hình là gen trẻ trâu di truyền qua nhiều thế hệ. Và tốt hơn hết, nếu bạn sống trong vũ trụ này, vào một ngày đẹp trời nào đó có ai đưa cho bạn thanh gươm ánh sáng màu xanh lá thì tốt nhất là trả lại gươm, xách tàu chạy 500 parsec tới vùng Vành Đai và chịu khó sống cuộc đời yên bình. Còn không …\n May The Force Be With You\n ====\n1: http://kenh14.vn/mot-phim/star-wars-the-force-awakens-bo-phim-can-moc-1-ty-usd-doanh-thu-nhanh-nhat-moi-thoi-dai-20151228124025985.chn\n2: http://www.imdb.com/title/tt2488496/?ref_=nv_sr_1\n","href":"/vi/docs/startwars-vii-review/","title":"Cảm nhận Star Wars VII: The Force Awakens"},{"content":" Sau gần 4 năm kể từ khi phát hành, mình mới được chơi cái game này. Thực ra do một cách tình cờ mà thấy được cái giá rẻ bất ngờ của em ý, tính ra là 20 USD cho bản Standard. Hoá ra là do đã có bản Expansion nên bản cũ mới rẻ vậy. Thôi thì lượm về chơi vậy.\nLần đầu tiên chơi game Diablo là bản Diablo 2 Fury Within hồi lớp 6 lớp 7 gì đó. Vậy là cũng gần 10 năm mất rồi. Trước giờ toàn chơi Barbarian và không thèm đếm xỉa đến các nhân vật khác. Phá đảo đánh boss không biết bao nhiêu lần nhưng vẫn không hiểu sao vẫn khoái nó đến vậy.\nQuay trở lại với Diablo 3, với góc nhìn của một đứa chơi game cho vui và không phải là tụi geek khi chơi game và thuộc lòng các công thức tính demage, defense hay tá lả các thuộc tính khác.\nNhân tiện về tính Damge per second (DBP) trong game:\n\\text{dps} = \\frac{\\text{min} + \\text{max}}{2} \\times \\text{APS} \\times \\text{Attach Speed} \\times ( 1 + \\frac{\\text{Primary Stat}}{2} ) \\times (1 + \\text{CritC} \\times \\text{CritDam}) \\times \\text{DamMod} Sợ rồi chứ. Tuy vẫn chưa kinh dị bằng bọn pokemon.\nQuay trở lại cảm nhận và những kỷ niệm liên quan giữa Diablo III và Diablo II.\nCốt truyện Có vẻ gì đó rất ảo lòi ra. Ngày xưa không quan tâm đến cốt truyện vì nhiều lý do. Đa phần là vì dốt tiếng Anh và tốn thời gian đọc thoại, nhưng ngẫm lại thì không phải là vấn đề của riêng mình; ngoài ra các bản trên đĩa CD lúc đó bán toàn bị cắt hết những cảnh Cinematic. Nhưng nếu quan tâm thì cốt truyện trông rất là thần thánh, thuộc thể loại dark fantasy và rất gần với gothic nên màu sắc đen tối (màu mè hơn ở bản III), liên quan mật thiết tới ký hiệu Judeo-Christian. Xét một cách nào đó, cả ba dòng game của Blizzard đều có cái hay trong cốt truyện khá riêng biệt. Nếu Starcraft là câu chuyện của tương lai, hi-tech và các chủng loài ngoài hành tinh cũng như cuộc phiêu lưu ở tít xa các dãy thiên hà, Warcraft là câu chuyện thần thoại mang phong cách Bắc Âu với biên niên sử đồ sộ thì Diablo lại là cuộc đấu tranh của con người với nền là Cuộc Chiến Bất Tận giữa thiên đàng và địa ngục.\nCuốn Book of Cain rất hay, dành cho dân nào mê cốt truyện. Mà thật ra, trước giờ toàn thấy thiên hạ click và click thay vì đọc thoại game. Tới đây mình đã hiểu vì sao những game như Fallout 3 lại có cốt truyện hơn, một phần vì người chơi buộc phải theo những thoại, mạch truyện để hoàn thành nhiệm vụ.\nMột số cải tiến Dưới góc nhìn của một đứa chơi lâu năm Diablo 2, thì một số vấn đề sau được giải quyết khá tốt trong Diablo 3:\nRương đồ Nếu chơi bản Diablo cũ thì rương đồ rất là tội nghiệp, chưa kể cái Cube cũng tội nghiệp không kém, trong diablo 3 thì kích thước rương đồ và item có cải thiện rõ rệt. Kích thước tối đa của item là $2 \\times 1$ khác hẳn với Diablo II là $ 3 \\times 2$, ngoài ra thì rương to hơn, có tăng thêm số lượng rương (thực ra là số tab), có thay đổi icon trong mỗi tab tiện cho công cuộc sắp xếp hàng.\nBản đồ Bản đồ siêu dễ chơi, một phần vì không đánh đố nhưng trong bản 2. Thêm vào đó có mũi tên chỉ dẫn làm nhiệm vụ nên không khó để tìm đến các đích. Ngoài bản đồ trong địa hình hiện tại còn có bản đồ khái quát của ACT. Có cảm giác nó không bự bằng Diablo II, quái trong bản đồ cũng không đông như bản trước. Không thấy có nhiều cave hay đường hầm gì nhiều, hoặc có thể là do mình chưa mò hết.\nCác cải tiến linh tinh  Khi đi đến cuối hầm hay cave luôn có 1 portal bằng đá để ra ngoài hang nhanh chóng. Không cần sách xanh nữa, muốn portal về nhà bao giờ cũng được. Và không cần đến chỗ portal point mới thổ địa phù. Không hiểu sao bản này dễ quá, Normal đánh không mất tí máu, lên Hard hiện giờ chỉ có boss mới làm mình mất máu được.  ","href":"/vi/docs/diablo3-review/","title":"Diablo III"},{"content":" Hôm rồi học course Introduction to Algorithm (2006-MIT) mình được biết qua khái niệm Randomized Algorithms, dành một buổi tìm hiểu về họ thuật toán thú vị này vậy.\nĐịnh nghĩa Randomized Algorithms (viết gọn là randalgs) là những thuật toán mà trong các bước xử lý có sử dụng số ngẫu nhiên để quyết định cho các bước tính toán tiếp theo.\nĐiểm thú vị của randalgs chính là nó không quan tâm đến trường hợp xấu nhất mà chỉ quan tâm đến kì vọng trong trường hợp xấu nhất.\nTưởng tượng ta có một hệ thống nghiêm trọng, nếu như hệ thống đó bị crash thì sẽ kích hoạt Cheget và Nuclear football cùng một lúc. Hệ thống quá lớn và phức tạp, quan trọng hơn, nó sẽ không hoạt động được khi liên tục phải chạy quicksort trong $\\mathcal{O}(n^2)$ - dữ liệu đầu vào là mảng được sắp xếp sẵn.\nHacker, bằng một cách nào đó biết được điều này và tấn công hệ thống bằng cách đưa vào hệ thống những mảng đã sắp xếp sẵn. Và bùm, apocalyptic diễn ra.\nVà để ngăn chặn thảm hoạ đó xảy đến, ta tạo ra một phiên bản gọi là randomized quicksort: trước khi được xử lý, mảng đầu vào sẽ được xáo trộn. Và cho dù hacker có cố tình tấn công bằng chuỗi đã sắp xếp thì sau bước tiền xử lý này , mảng được sắp xếp ngẫu nhiên.\nNếu một input có trật tự ngẫu nhiên, sau khi xáo trộn trở thành một chuỗi thứ tự thì sao? Murphy’s law\n Nếu đã xui, thì hẳn phải xui nhất có thể.\n Ví dụ Một biến thế nổi tiếng của Quick sort chính là Randomized Quicksort, có hai phiên bản chính:\n Chọn ngẫu nhiên pivot để xử lý. Xáo trộn mảng đầu vào trước khi sắp xếp.  Randomized Quicksort được tạo ra nhằm tránh trường hợp xấu nhất của thuật toán quicksort là $\\mathcal{O}(n^2)$.\nPhân loại  In Las Vegas, the dealer can tell you whether you’ve won or lost, but in Monte Carlo, le croupier ne parle que Français, so you have no idea what he’s saying\n Las Vegas algorithm Thuật toán nằm trong họ Las Vegas luôn luôn đảm bảo kết quả trả ra đúng với mong muốn. Quicksort là một ví dụ điển hình.\nNói cách khác, Las Vegas không chơi hên xui ở kết quả trả về, nó chỉ sử dụng yếu tố ngẫu nhiên trong các phép tính toán để cho ra kết quả đúng.\nMonte Carlo algorithm Khác với Las Vegas, Monte Carlo không đảm bảo kết quả sẽ luôn luôn đúng. Nhưng Monto Carlo có xác suất kết quả sai thấp có thể.\nThay vì sử dụng xác suất như một trong những quá trình tính toán, Monte Carlo hên xui ngay cả kể quả trả về.\nPhân biệt Bài toán Cho một chuỗi có độ dài 2n trong đó có n kí tự a và n kí tự b. Nhiệm vụ là tìm ra một vị trí bất kì trong chuỗi chứa kí tự a\nimport sys import random # Las Vegas version def find_a_lv(string): while True: pos = random.randint(0, len(string)-1) if string[pos] == 'a': return pos # Monte Carlo version def find_a_mc(string, k): pos = 0 while k and string[pos] != 'a': k = k -1 pos = random.randint(0, len(string)-1) return pos if __name__ == '__main__': string = sys.argv[1] if len(string) % 2 == 1: raise ValueError(\u0026quot;Wrong input\u0026quot;) print find_a_lv(string) print find_a_mc(string, len(string)/2)  Ta dễ dàng nhận thấy find_a_lv luôn luôn cho ra kết quả, tuy nhiên đôi khi nó lại không thực sự hiệu quả. Ví dụ như nếu ta có chuỗi đầu vào là “ab” và find_a_lv mất 2 triệu vòng lặp mới pick đúng pos=0.Dĩ nhiên xác suất để xảy ra chuyện đó rất thấp, nhưng không có nghĩa là nó không xảy ra.\nCòn trong trường hợp find_a_mc, kết quả sẽ sai với xác suất khá dễ tính: $\\frac{1}{2^k}$ - khi trong k lần thử để chọn đúng vị trí chứa b.\nCác kĩ thuật cơ bản  Avoiding adversarial inputs:  Trong các thuật toán online. Hashing. Trong các thuật toán sắp xếp.  Verification:  Phát sinh số ngẫu nhiên trong các bài toán kiểm thực.  Random sampling:  Trong các bài toán tìm kiếm (tìm median..) Trong các thuật toán geometry.  Load balancing:  Parallel algorithms. Hashing problems.  Symmetry breaking:  Dùng trong hệ thống distributed.  Probabilistic existence proofs:  Thông qua các thực nghiệm. Đảm bảo trong bài toán tìm kiếm đối tượng cần tìm tồn tại.   Tài liệu Khoá học  Randomized Algorithms and Probabilistic Analysis - Washington Probabilistic Methods in Computer Science  ","href":"/vi/docs/intro_randalgs/","title":"Dẫn nhập thuật toán ngẫu nhiên"},{"content":" Biên dịch thư viện OpenCV Điểm thuận lợi của việc tự cài đặt và biên dịch thư viện có thể kể đến như sau:\n Hỗ trợ IDE mới nhất, như trong bản OpenCV 3.0 (22/11/2015) thì chưa có bản biên dịch sẵn dành cho VS 2015. Customize được các thư viện khác liên quan như Kinect, OpenCL, Python…  Link Download thư viện OpenCV cho HĐH Windows\nBước 1: Giải nén thư viện vào thư mục được định sẵn. Giả sử đường dẫn của mã nguồn là C:\\opencv\nBước 2: Tải và cài đặt CMake. Thư mục build chứa những tập tin của phần mã nguồn được biên dịch sẵn. Phần sources được sử dụng cho cài đặt manual.\nBước 3: Mở CMake. Trong phần Where is the source code sẽ trỏ đến thư mục sources đã đề cập lúc trước. Phần Where to build the binaries là nơi chứa phần thư viện được biên dịch. Trong ví dụ này đường dẫn là C:\\opencv\\sources\\build.\nBước tiếp theo nhấn Configure, sau đó chọn bộ generator cho project, trong phần này sẽ chọn tương ứng với IDE/Compiler mà mã nguồn mình sử dụng. Đồng thời, nếu máy tính đang ở kiến trúc x86 thì chọn các phiên bản IDE với tùy chọn là x86 (Ví dụ Visual Studio 14 2015). Đối với các máy tính kiến trúc x64 thì chọn phiên bản có hậu tố là Win64. Nhấn Finish để kết thúc cấu hình.\nSau khi configure xong thì danh sách các tùy chọn khi biên dịch để hiện ra với rất nhiều tùy biến đi kèm. Phần này trong tutorial này sẽ bỏ qua vì mục tiêu chỉ cần cài đặt bộ thư viện ở mức mặc định là thành công rồi. Nếu không có gì thay đổi ta nhấn chọn Generate.\nSau khi quá trình phát sinh mã nguồn hoàn tất, trong thư mục build sẽ xuất hiện các Project/Solution khác nhau.\nBước 4: Dùng Visual Studio để mở solution có tên là OPENCV. Lưu ý: khi bản VS này phải trùng với bản VS đã configure trong cmake.\nQuá trình biên dịch cần thực hiện qua 2 bước: (1) biên dịch thư viện cho quá trình Debug và (2) biên dịch chương trình trong quá trình Release. Để thực hiện các bước này đơn giản chỉ cần click chọn Target sẽ build rồi sau đó nhấn F7 và ngồi đợi (Mất khoàng 10-15 phút cho quá trình biên dịch trên Debug/Release). Kết quả trong quá trình biên dịch sẽ có khoảng 50 projects biên dịch thành công, 17 cái bị skip và 2 cái bị fail. Sau khi biên dịch, ta sẽ có 2 thư mục cần quan tâm nằm trong build. Đó là thư mục lib chứa toàn bộ dữ liệu cần thiết cho quá trình lập trình; thư mục là dữ liệu cần thiết để chương trình sau khi build có thể chạy được.\nCấu hình Opencv trên Visual Studio Bước 1: Tạo một Project (Empty Project).\nTrước khi thực hiện tiếp các công việc cấu hình cho project. Ta cần xác định rõ sẽ cần cấu hình những thông tin gì:\n Nơi chứa header file của OpenCV. Dĩ nhiên ta cần làm điều này để include các đối tượng, hàm… của OpenCV. Cấu hình các file cần thiết khi lập trình. Cấu hình các file cần thiết cho quá trình thực thi. Bởi trong Visual Studio có 2 target khi run bao gồm Debug và Release, nên ta cần phải cấu hình riêng biệt cho mỗi target đó.  Cấu hình header file Click chuột phải vào tên project (InstallOpencv) chọn Properties (Hoặc nhấn Alt + F7).\nPhía bên phần Sidebar chọn C/C++, General, mục Additional Include Directories ta trỏ đến thư mục opencv\\build\\include (không phải sources\\build\\include). Để đảm bảo ta có thể check bằng cách kiểm tra xem thư mục include đó có các header file không. Xong nhấn OK.\nCấu hình thư viện cho quá trình lập trình Nhấn Alt + F7 để vào phần Properties của Project. Chọn Thẻ Linker, mục Additional Library Directories ta trỏ đến thư mục lib\\Debug (trong ví dụ này là: C:\\opencv\\sources\\build\\lib\\Debug). Vì đang cấu hình cho target là Debug nên phần Configuration phải là Debug\nChuyển đến thẻ Input, mục Additional Dependencies ta nhập các file sau:\nopencv_calib3d300d.lib opencv_core300d.lib opencv_features2d300d.lib opencv_flann300d.lib opencv_hal300d.lib opencv_highgui300d.lib opencv_imgcodecs300d.lib opencv_imgproc300d.lib opencv_ml300d.lib opencv_objdetect300d.lib opencv_photo300d.lib opencv_shape300d.lib opencv_stitching300d.lib opencv_superres300d.lib opencv_ts300d.lib opencv_video300d.lib opencv_videoio300d.lib opencv_videostab300d.lib  Sau khi cấu hình xong, ta chuyển qua target là Release và thực hiện giống hệt như vậy. Tuy nhiên đường dẫn lần này sẽ là C:\\opoencv\\sources\\build\\lib\\Release.\nPhần Additional Dependencies sẽ là:\nopencv_calib3d300.lib opencv_core300.lib opencv_features2d300.lib opencv_flann300.lib opencv_hal300.lib opencv_highgui300.lib opencv_imgcodecs300.lib opencv_imgproc300.lib opencv_ml300.lib opencv_objdetect300.lib opencv_photo300.lib opencv_shape300.lib opencv_stitching300.lib opencv_superres300.lib opencv_ts300.lib opencv_video300.lib opencv_videoio300.lib opencv_videostab300.lib  Cấu hình thư viện cho quá trình thực thi Khi thực hiện build 1 chương trình, VS sẽ tạo ra trong thư mục của Solution hai thư mục với cấu trúc như sau: \\Debug và \\Release. Trong ví dụ này là x64\\Debug, x64\\Release. Ta chép toàn bộ file trong build\\bin\\Debug vào x64\\Debug, tương tự như vậy đối với build\\bin\\Release và x64\\Release.\nTạo một file cpp và run thử chương trình.\nMã nguồn:\n#include \u0026lt;opencv2/opencv.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace cv; using namespace std; int main() { Mat img = imread(\u0026quot;demo.jpg\u0026quot;); imshow(\u0026quot;show image\u0026quot;, img); waitKey(0); destroyAllWindows(); }  (Với mã nguồn này lưu ý đặt 1 file tên là demo.jpg vào trong thư mục chứa mã nguồn).\nKết quả ta được như hình trên.\nTuy nhiên Có một chữ tuy nhiên to đùng như vậy vì với cách cấu hình thế này có khá là nhiều bất cập:\n Mỗi lần tạo 1 project OpenCV mới mà ngồi config (Mục 2) thì cũng rất là mất thời gian. Chưa kể trong lúc cấu hình mà quên mất một công đoạn nào thì có khi đi tong cả buổi chỉ để fix lỗi. Những file trong sources\\bin\\Debug hay Release đều xấp xỉ 900MB. Vị chi mỗi lần chép qua bên project thì tốn thêm 1.8GB bộ nhớ. Chỉ cần trong máy chứa dăm ba project dùng OpenCV thì sẽ ngốn dung lượng đến chừng nào. Phần Additional Dependencies mỗi phiên bản OpenCV mỗi khác, làm thế nào để lấy được danh sách các file như thế này.  Ta sẽ giải quyết từ dễ đến khó trước.\nAdditional Dependencies Sau khi biên dịch xong thư viện ta mở Command Line và trỏ đến thư mục sources\\build\\lib\nGõ lệnh sau\ndir Debug\\*d.lib /B \u0026gt;..\\DependenciesDebug.txt dir Release\\*.lib /B \u0026gt;..\\DependenciesRelease.txt  Sau khi gõ xong thì trong thư mục build sẽ xuất hiện 2 file text là DependenciesDebug và DependenciesRelease chứa danh sách tât cả các file libs. Mỗi lần sử dụng chỉ cần mở file lên và chép vào.\nLib Configuration Mở Command Line (Với quyền Admin - click chuột phải vào biểu tượng Start và chọn Command Promp) và gõ lệnh\n setx -m OPENCV_DIR C:\\opencv  Nhấn Windows E để mở File Explorer\nClick vào Computer và chọn Properties\nChọn Advanced system settings. Trong thẻ Advanced chọn Environment Variables…\nĐiền ngay phía sau của phần Variable value giá trị sau: %OPENCV_DIR%\\sources\\build\\bin\\Debug;%OPENCV_DIR%\\sources\\build\\bin\\Release\nXong, và từ giờ trở đi ta không cần phải chép các file trong build\\bin vào trong project nữa.\nSao lưu config của project Trong sidebar Property Manager ta thấy danh sách các config tương ứng với từng target architecture trong project.\nTa sẽ tạo một Property Sheet mới (Click chuột phải vào từng mục và chọn Add New Project Property Sheet…), double click vào mục mới tạo và cấu hình giống hệt với mục 2. Sau đó lưu lại. VS sẽ tạo ra 1 file có định dạng props trong project. Sau này khi tạo ra 1 project mới ta chỉ cần import Property đã tạo mà không cần config lại từ đầu.\nVì đã set OPENCV_DIR là thư mục của OpenCV nên ta có thể thay đổi đường dẫn của các config thành\n %OPENCV_DIR%\\build\\include %OPENCV_DIR%\\source\\build\\lib\\Debug %OPENCV_DIR%\\source\\build\\lib\\Release  ","href":"/vi/docs/install_opencv_vs/","title":"Hướng dẫn cài đặt OpenCV trên Windows"},{"content":" Hôm nay tình cờ thấy cái link liệt kê các bài được accept ở CVPR16, thế là mình ngồi thống kê vài cái cho vui\nĐầu tiên là parse đống html này, sau đó dùng python load một dữ liệu lên, ta có được:\n Số bài báo được accept: 643 bài. Người có nhiều bài được đăng nhất: Ming-Hsuan Yang với tổng cộng 11 bài. Bài có chữ deep trong tiêu đề: 87 bài, chiếm 13.53% tổng số bài được accept. Bài có số tác giả nhiều nhất: Multimodal Spontaneous Emotion Corpus for Human Behavior Analysis với 13 tác giả đứng tên. Bài chỉ có 1 tác giả (một mình chống mafia):\n Structured Feature Similarity With Explicit Feature Map Hierarchically Gated Deep Networks for Semantic Segmentation Robust, Real-Time 3D Tracking of Multiple Objects With Similar Appearances Semantic Filtering Learnt Quasi-Transitive Similarity for Retrieval From Large Collections of Faces   cv-foundation còn hào phóng đính kèm trong source link download các paper, đồng thời có cả bibtex của các bài, nếu kết hợp với arxiv api thì có thể thống kê được nhiều thứ hay ho hơn nữa =))\nMột số thống kê về tác giả. Thử xem phân phối số lượng tác giả trên đầu bài của CVPR16 thế nào. Theo như kết quả, số bài ở CVPR16 trung bình có từ 2, 3 hoặc 4 tác giả đứng tên. Nhiều nhất là các bài có 3 tác giả (186 bài). Ngoại trừ gã outlier 13 tác giả thì biểu đồ đã gần giống với phân phối chuẩn rồi.\nCó 1843 tác giả có bài trong CVPR16. Ngoài Ming-Hsuan Yang bá đạo ở trên, trong danh sách tác giả nhiều bài còn có những cái tên nổi bật như: Pascal Fua, Li Fei-Fei. Dưới đây là danh sách các tác giả có nhiều bài nhất trong CVPR16:\n Lei Zhang [scholar] [homepage]: 7 bài. In So Kweon [scholar] [homepage]: 7 bài. Antonio Torralba [scholar] [homepage]: 7 bài. Jiashi Feng [scholar] [homepage]: 7 bài. Wangmeng Zuo [scholar] [homepage]: 7 bài. Anton van den Hengel [scholar] [homepage]: 8 bài. Bernt Schiele [scholar] [homepage]: 8 bài. Luc Van Gool [scholar] [homepage]: 8 bài. Xiaogang Wang [scholar] [homepage]: 9 bài. Ming-Hsuan Yang [scholar] [homepage]: 11 bài.  Một điểm mình quan tâm nữa là mối quan hệ giữa các tác giả với nhau đó là lí do mình viết: một mình chống mafia ở đoạn trên. Ở đây mình dùng graph-tool để minh hoạ data đã thu thập được. Cách xây dựng đồ thị khá đơn giản: những tác giả đứng chung bài với nhau sẽ có cạnh nối với nhau.\nXưa kia nhà toán học Michael Gurevich đã từng thử điều này với các nhà toán học, và hiện nay bài toán Six degree of Seperation đã nổi tiếng và quan tâm nhiều.\nNhìn hình ta có thể hình dung có 1 hội mafia cực lớn dây mơ rễ má với nhau. Và các team lẻ lẻ hơn thì bị nằm ngoài rìa, có 1 số team hoạt động khá độc lập (nằm giữa vùng trung tâm và vành đai). Đồng thời những chấm đỏ mỏng manh nằm ngoài vùng vành đai chính là các thánh một mình chống mafia, xin hoan nghênh các anh.\nChủ đề của CVPR16 Ban đầu mình dự định sử dụng arvix-api để lấy keywords từ Bibtex tuy nhiên vì có cơ số bài hiện chưa có trên Arvix (mình sample 5 bài và cả 5 bài đều không được tìm thấy trên đó) nên không có cách để lấy chính xác keywords.\nCó 2 cách tiếp cận:\n Dựa vào tiêu đề. Cách này sẽ nhanh hơn vì dữ liệu này đã có sẵn. Dựa vào nội dung. Cách làm tương đối đơn giản nhưng hơi mất thời gian: (1) download đống paper từ cv-foundation, (2) dùng pdf2text lưu text, (3) dùng 1 số thuật toán clustering để phân loại.  Cách thứ (2) tương đối dài hơi nên mình ưu tiên dùng cách thứ (1) trước. Một thuật toán để rút trích keywords khá nổi tiếng là RAKE. Dưới đây là kết quả.\n deep convolutional neural networks convolutional neural networks recurrent neural networks deep neural networks salient object detection convolutional networks sparse coding object detection image segmentation action recognition semantic segmentation optical flow shot learning unsupervised learning activity recognition set registration person re image pose detection video learning  Future Works Hiện giờ minh đang tìm cách download toàn bộ pdf của bài năm nay để làm clustering và phân tích nội dung, đồng thời làm 1 tool search nho nhỏ. Ngoài ra hiện giờ mình đang tìm kiếm danh sách các bài các năm trước để có thêm 1 số phân tích hay ho hơn nữa (về trending, các bài được cite nhiều,).\n","href":"/vi/docs/cvpr16-stat/","title":"Một chút thống kê về các bài báo CVPR16"},{"content":" Đây là một chủ đề được mình nói kha khá nhiều lần tại Open Talk ở trường ĐH Tự Nhiên (nói quá thôi chứ đi có 2 lần). Một trong những thiếu sót lớn của sinh viên CNTT đó là không nắm kịp tin tức công nghệ cũng như không biết thế giới đang chạy tới đâu rồi. Chia sẻ dưới đây của mình chỉ tập trung vào các mảng mình quan tâm nên dĩ nhiên còn rất nhiều thiếu sót những lĩnh vực khá. Tuy nhiên, có thể tìm các kênh thông tin thông qua một số thủ thuật, mẹo vặt. Chăm đi hội thảo Dĩ nhiên là trừ mấy hội thảo Đa Cấp. Theo như kinh nghiệm lặn lội 4 năm ở giảng đường đại học, kinh qua không biết bao nhiêu hội thảo của IBM, M$, Nokia, blah blah. Mình vẫn còn ấn tượng lần đầu tiên hồi năm 1 đi dự buổi training về công nghệ Cloud của IBM, nhờ buổi đó mà đi về mình chả biết thêm gì cả. Nhưng vẫn còn nhớ cái cảnh xuống xe số 6 chỗ đường Sư Vạn Hạnh giao với An Dương Vương và đi bộ mệt nghỉ tới trường Ngoại Ngữ Tin Học . Buổi thứ hai là khi tham dự buổi phát động Imaging Cup. Phải công nhận buổi đó rất ấn tượng và khiến mình có động lực làm đại sứ Microsoft: Microsoft Student Partner. Dù đã có cố gắng tham gia hồi năm 2, năm 3 gì đó nhưng bất thành. Không liên quan nhưng 1 thằng bạn trong lớp sau này thành MSP. Đến năm hai thì đi nhiều hơn, máu hơn, dù đôi lúc ngồi bên trong chả biết thiên hạ nói gì, nhưng quan trọng mình cũng định hình được chuyện gì đang xảy ra với làng công nghệ.\nMột số hội thảo khá hay ho ở TP.Hồ Chí Minh có thể kể đến như:\n Barcamp: Phải đi vì là nơi qui tụ các thánh, ăn buffet được tặng áo. blah blah, đây cũng là event công nghệ khá lớn. Các buổi training của Microsoft: tập trung vào công nghệ của Microsoft. Google Developer Group: buổi ra mắt năm 2013 cực kì hoành tráng. Nhưng rồi có vẻ hơi chìm dần, nhưng nghe đồn đâu vẫn còn hoạt động. Các nhóm lập trình trên MeetUp: Có thấy group về Javascript và PHP hoạt động khá dữ dội trên này.  Reddit Thật khó để nói Reddit là mạng xã hội như thế nào. Có thể hiểu đây là một hình thái của Voz hay Webtretho phiên bản nước ngoài, tuy nhiên tầm hoạt động cũng như các chủ đề vô cùng rộng lớn. Có rất nhiều diễn đàn con trong này là những chia sẻ về công nghệ rất đáng quan tâm. Chỉ cần tạo một nick và subcribe những chủ đề mình thích, mỗi ngày sẽ có hàng tá thông tin hay ho. Ngoài ra, việc đọc bài trên Reddit còn giúp luyện tiếng Anh (chủ yếu slang và idiom ) cũng như học hỏi được từ các thành viên khác.\nMột số trang tiêu biểu mình follows:\n /r/programming: trang này hầu như cập nhật những tin mới nhất về lập trình. Nhảm hài hay nghiêm túc đều có. /r/dailyprogramming: coding mỗi ngày. Trang này rất hay để mỗi ngày tập code một tí. /r/coding: thuần tuý về coding. /r/compsci: tin tức trong lĩnh vực Khoa Học Máy Tính. /r/webdev: subreddit dành cho dân phát triển website. /r/machinelearning: Máy Học và các vấn đề liên quan. /r/vim: editor ưu thích. /r/programmingchallenges: dành cho những thánh code. /r/cpp: ngôn ngữ C++ thần thánh. /r/javascript: trang tin về javascript. /r/ProgrammerHumor: Hài hước theo cách của tụi lập trình viên.  Trang tin công nghệ Hiện nay có rất nhiều trang thông tin công nghệ có thể theo dõi, ở trong Việt Nam thì mình thấy có một số trang khá hay ho đến từ các tổ chức, công ty. Có thể kể đến như của Silicon Strait Saigon trang này chuyên tin về iOS, Web và Design, chất lượng bài viết khá tốt. TinhTe.vn cập nhật các tin tức liên quan đến công nghệ, có cả máy ảnh, xe cộ, blah blah. Tuy nhiên điểm mình không hài lòng đó là chất lượng bài viết không quá tốt, không đào sâu, đặc biệt liên quan đến các chủ đề lập trình hay khoa học máy tính, tốt nhất là đọc để biết tin tức thế nào. Một phần nữa users thành phần trẻ trâu nhiều, hàm lượng thông tin chả có bao. VinaCode cũng là một trong những trang chăm chỉ cập nhật bài viết, chủ yếu dịch từ nước ngoài, nhưng có gọi là có đầu tư. Một trang khác đó là ITViec: rất nhiều thông tin bổ ích để xây dựng thương hiệu bản thân, mình cũng thấy chất lượng dịch thuật ở đây khá là chất.\nMột trang mới nổi hiện nay là Re/Code: trang này cập nhật các thông tin công nghệ rất hay, bài viết cũng chất lượng.\nMột số trang cũng hay follow như:\n The Verge. The Mashable. Quora.  Đứng trên vai người khổng lồ Mình rất thích vế này. Những người đầu ngành, nhất là về lĩnh vực Công Nghệ thì thường hay chia sẻ tin tức, quan điểm, sản phẩm của mình ở các trang xã hội như Facebook, G+ (có khá nhiều giáo sư đầu ngành xài mạng này) và Twitter, một số khác còn dùng trang cá nhân (homepage) hay blog để chia sẻ kiến thức nữa. Ở Việt Nam mình thích nhất trang của các bậc tiền bối, bài viết rất chất lượng và có tính chuyên sâu. Nếu quan tâm đến máy học và các vấn đề về thị giác máy tính có thể quan tâm, theo dõi trang cá nhân của các nhân vật lừng lẫy sau:\n Andrew Ng.: không cần nói cũng biết là ai. Yann LeCun: Trưởng điều hành bộ phận AI Facebook Research. Linus Tovalds: cha để Linux. Facebook Research: Cập nhật các công trình nghiên cứu của Facebook.  Còn rất nhiều bậc cao nhân khác nữa. Đọc và tìm hiểu quan điểm về công nghệ của họ là một cách tốt nhất nâng cao hiểu biết của mình.\nBlogs Điểm khác biệt của blog là mang nhiều ý kiến chủ quan của người viết hơn, giọng văn và cách hành ngôn cũng cá nhân hoá hơn. Thông thường các bài viết ở đây khá vui và độc đáo, thực sự mình thích đọc bên blog nhiều hơn, phần nào đó thể hiện được quan điểm của tác giả, bài viết thường có đầu tư và chuyên sâu vào một mảng nào đó.\nVề mảng Thị Giác Máy Tính có Computervision blog - bài viết rất chất.\nCó khá nhiều trang blog kinh điển của mà hầu như mọi programmer đều biết. Có thể kể đến như (1): Coding Horror: đọc bài trong này level về công nghệ phần nào tăng lên rõ rệt.\nMột thánh nữa mà ngày xưa mình rất hay theo dõi khi còn xài Windows và code C# đó là Hanselman. Ngày xưa biết đến thánh nhờ bài viết các công cụ dành cho dev,\nJeremykun: những bài viết là sự kết hợp tuyệt vời của toán học và lập trình, rất đáng để dành thời gian đọc.\nCodeless code: trang này viết theo kiểu “khó-hiểu-như-trong-kinh-thánh”, độ giải trí và suy ngẫm rất cao.\nProgramming Languages weblog: trang này thì quá nổi tiếng rồi.\nMột số chuyên sâu hơn về các kỹ thuật trong lập trình, mình chỉ khoái mỗi C++ và Python, theo mình một số trang sau khá là hay:\n CLion blog: Các tin tức liên quan đến C++. Cpp Hints: Phân tích các lỗi trong các dự án mã nguồn mở sử dụng C++. Meeting Cpp: cập nhật các bài viết về C++. Pycoder: cuối thứ 6 nào cũng dành thời gian đọc tin. Mục tiêu là trở thành Full Stack Devloper mà lị. Javascript Weekly: trang này rất giàu thông tin, tuần nào cũng cập nhật về các tin tức liên quan đến Javascript và web dev.  Một số blog của các cao thủ võ lâm ở Việt Nam cũng thường xuyên cập nhật công nghệ và các kỹ thuật mới. Blog của Quan 404 là một site điển hình. Tuy trang này khá mới, nhưng những bài viết khá là chất và bám sát các công nghệ hiện là state-of-the-art.\nMột số trang khá là vui mà mình cũng hay follow:\n XKCD: đơn giản đó là những gì lãng mạn, châm biếm, toán học và ngôn ngữ. Comic có vài hình mà độ hại não cao. PHD Comics: ai làm research nhiều sẽ thấu hiểu những gì mà comic này đề cập, rất hài hước.  Tổng kết Internet mở ra cho mọi người một cổng thông tin tuyệt vời. Nhưng đó cũng chính là vấn đề, đôi khi chúng ta bị “ngập ngụa” trong mớ thông tin mà không biết cái nào đáng dành thời gian để đọc. Điều cần thiết khi truy cập thông tin đó là xác định bản thân mình đang muốn tập trung vào mảng nào, tìm kiếm các nguồn kênh đáng tin cậy, đọc một cách đào sâu và nghiên cứu kỹ, đồng thời trao đổi, chia sẻ và đánh giá các bài viết. Điều đó giúp ta có thể không follow nhiều trang tin tức, nhưng kiến thức và thông tin của bản thân được trao dồi. Tập trung vào chất lượng hơn số lượng là một bước đi khôn ngoan trong kỷ nguyên số này.\n","href":"/vi/docs/it_news/","title":"Những kênh thông tin công nghệ"},{"content":" Tiêu chí Để đảm bảo hồ sơ được duyệt, bài báo và hội nghị tham dự phải đạt một số tiêu chí mà Quỹ đưa ra:\n Nhà khoa học đang thực hiện đề tài do Quỹ hỗ trợ, hoặc Nhà khoa học là người dưới 35 tuổi. Quỹ đánh giá hội nghị dựa trên lịch sử của hội nghị, uy tín của đơn vị tài trợ hội nghị, uy tính của các nhà khoa học khách mời hay uy tính của ban tổ chức. Ưu tiên: Hội nghị được liệt kê trong danh sách của Thomson Reuters hoặc bảng xếp hạng của ERA. Ưu tiên: Người xin tài trợ là keynote speaker, track chair/co-chair, hoặc được giải thưởng bài báo xuất sắc.  Quy trình Tổng thời gian NAFOSTED duyệt, chấp nhận và xử lý hồ sơ trung bình mất từ 1-2 tháng. Hồ sơ xin tài trợ của NAFOSTED bao gồm:\n Đơn đề nghị tài trợ có xác nhận của cơ quan, tổ chức nơi công tác. Thông báo của Ban tổ chức kèm theo địa chỉ trang web giới thiệu về hội nghị, hội thảo; Thư mời tham dự và trình bày báo cáo khoa học tại hội nghị, hội thảo; Báo cáo khoa học sẽ trình bày tại hội nghị, hội thảo; Lý lịch khoa học của người nộp đơn đề nghị tài trợ; Dự toán kinh phí đề nghị Quỹ tài trợ, trong đó nêu rõ các khoản chi phí được ban tổ chức hội nghị, hội thảo hoặc các tổ chức khác cam kết tài trợ - nếu có.  Tất cả tài liệu này phải được điền đầy đủ, có chữ ký của cá nhân và xác nhận của cơ quan đang làm việc/học tập, sau đó gửi đường bưu chính đến địa chỉ: Tầng 4, Số 39 Trần Hưng Đạo, P. Hàng Bài, Q. Hoàn Kiếm, Hà Nội.\nCác tài liệu (1), (5) và (6) có mẫu từ website chính thức của Quỹ.\nTài liệu (3): trong thư mời phải đề cập rõ ràng đây công trình khoa học được công bố dạng báo cáo, không phải dạng poster. Quỹ còn bắt buộc trong thư mời phải đề cập đến chi tiết oral presentation.\nTài liệu (4): Gửi kèm email thông báo và các đánh giá của hội nghị.\nKhoảng một tuần sau khi gửi hồ sơ thì bên Quỹ sẽ liên lạc và yêu cầu cập nhật hoặc chỉnh sửa một số hồ sơ. Trong đó chủ yếu liên qua đến Dự Toán Kinh Phí (Tài liệu 6). Bên Quỹ sẽ thanh toán tiền vé máy bay, tuy nhiên người xin tài trợ có thể nhờ thay đổi chuyến bay hoặc thay đổi hãng bay để phù hợp hoặc cân đối các khoản chi phí. Người xin tài trợ có thể được Quỹ hỗ trợ tối đa trong 5 ngày, tuy nhiên nếu người xin tài trợ ở lại lâu hơn, thì những ngày còn lại sẽ không nằm trong phần hỗ trợ của Quỹ. Thông tin chi tiết về các khoản trong tài liệu này được trình bày cụ thể trong thông tư 102/2012/TT-BTC.\nĐiểm lưu ý là toàn bộ tiền hỗ trợ được tính bằng đơn vị USD và sau đó khi quyết toán được quy đổi theo tỉ giá VND và USD. Kể cả khi tham dự hội nghị ở các nước không dùng đồng USD thì các khoản chi phí trong dự trù bắt buộc phải đổi sang USD.\nTrong trường hợp được hỗ trợ, NAFOSTED sẽ thanh toán trước tiền vé máy bay. Tất cả các khoản tiền còn lại sẽ được NAFOSTED quyết toán sau. Trong quá trình tham dự hội nghị, người báo cáo phải xin hoá đơn có con dấu (xanh hoặc đỏ) hoặc có chữ ký xác nhận của thư kí hội nghị.\nKhi hoàn tất chuyến báo cáo hội nghị, người báo cáo phải nộp lại hồ sơ (gửi đường bưu điện) các hồ sơ sau:\n Vé lên máy bay (boarding pass). Hoá đơn của hội nghị. Chứng nhận tham dự hội nghị. Hợp đồng bảo hiểm. Bản photo Passport. Dự toán kinh phí được hiệu chính lại. Thông thường sẽ không khác so với bản trước đó nhưng có thể thay đổi liên quan đến tỉ giá hiện tại hoặc các chi phí phát sinh.  Sau khi gửi toàn bộ hồ sơ này đến Quỹ, Quỹ sẽ giải quyết và sẽ có thông báo danh sách được quyết toán của Quỹ. Trong khoảng 1 tuần kể từ sau khi có thông báo, tiền hỗ trợ sẽ được gửi vào tài khoản ngân hàng.\nKinh nghiệm cá nhân  Thương lượng về vé máy bay để có thể có vé rẻ hơn, thay đổi thời gian bay để có thể ở lại hội nghị lâu hơn. Khi xin giấy chứng nhận tham dự hội nghị và hoá đơn thì xin con dấu và kèm cả chữ ký của thư ký hội nghị. Nộp đơn hội nghị trước 2 tháng để đảm bảo cập nhật kịp hồ sơ.  Nguồn tham khảo  NAFOSTED Thông tư 102/2012/TT-BTC.  ","href":"/vi/docs/nafosted_travel_fund/","title":"Quy Trình Xin Tài Trợ NAFOSTED"},{"content":" Mình quyết định đọc cuốn Refactoring: Improving the Design of Existing Code sau khi đọc xong cuốn Design Pattern.\nSơ lược Mặc dù đã được nghe đến khái niệm này rất nhiều lần, tuy nhiên sau khi đọc xong cuốn sách, đối chiếu với những trải nghiệm của bản thân về các project trước đây. Mình hiểu:\n Refactor là quá trình thao tác trên mã nguồn có sẵn nhằm gia tăng chất lượng mã nguồn nhưng vẫn giữ lại được các ràng buộc của hệ thống.\n Như vậy, refactor không phải quá trình tạo mới hoàn toàn một dự án hay một hệ thống nào cả, mà nhằm làm tăng chất lượng của mã nguồn đó. Chất lượng ở đây được đánh giá trên các độ đo khác nhau:\n Khả năng mở rộng của mã nguồn. Khả năng dễ đọc và tìm lỗi. Khả năng thích ứng với lỗi (tính robustness) Hiệu suất của hệ thống.  Ngoài việc làm gia tăng chất lượng của hệ thống, bên cạnh đó refactor phải đảm bảo giữ lại được các ràng buộc mà trước đó hệ thống đã có. Ví dụ như:\n Những APIs đã được phát hành của hệ thống, ta không nên refactor và thay đổi luôn các APIs đó. Những class, functions liên hệ trực tiếp đến các modules khác trong hệ thống lớn hơn.  Những kĩ thuật trong refactor Một phần quan trọng của cuốn sách không chỉ nói về định nghĩa của refactor mà còn đề cập đến lí do vì sao cần refactor, khi nào nên refactor, những tác động nào ảnh hưởng đến quá trình refactor, và đặc biệt là xây dựng bộ test cho hệ thống. Trước giờ mình chủ yếu làm các hệ thống trong academic, việc xây dựng các bộ test không được chú trọng quá nhiều. Nhưng thực sự đọc xong cuốn sách mình nghĩ mình nên tập các viết các bộ test trước khi viết một function nào đó. Việc tự tay viết các bộ test mang lại khá nhiều thuận lợi:\n Giúp người thiết kế biết được giao diện tương tác API mà function mình đảm nhiệm. Hiểu được các ràng buộc về Input/Output và tham số. Thuận lợi cho việc refactor, các bộ test sẽ giúp ta kiểm tra xem việc vừa refactor xong có ảnh hưởng gì đến hệ thống hiện có không. Hình thành được outline của hệ thống trong quá trình xây dựng bộ test.  Cuốn sách được bố cục phần nào giống với bên Design Pattern, cung cấp một lượng lớn từ vựng về các kĩ thuật refactor. Với mỗi kĩ thuật được đề cập, tác giả nêu lên: động lực sử dụng, ví dụ minh họa, các lưu ý. Các kĩ thuật refactor được chia thành các category\n Thao tác trên các method trong 1 class. Thao tác trên các method giữa các class với nhau. Tổ chức dữ liệu. Đơn giản hóa các câu lệnh điều kiện. Đơn giản hóa các hàm. Tái tổ chức hệ thống class.  Cuối cùng là những thao tác refactor ảnh hưởng đến các ràng buộc của hệ thống, đây là những thao tác sẽ ảnh hưởng lên đến việc tương tác giữa các hệ thống với nhau nên cần suy nghĩ cẩn trọng trước khi thực hiện.\nPhần cuối cùng là các công cụ refactor, mình nghĩ phần nào không cần nói nhiều vì trên các IDE nổi tiếng như Visual Studio, Eclipse, IntelIJ thì các kĩ thuật refactor đã trở thành những tính năng khá quen thuộc. Việc refactor tự động giúp tránh xảy ra lỗi và giảm thời gian cho công việc này khá nhiều.\n Nếu có hành động nào đó lặp đi lặp lại trên 5 lần. Tốt hơn là ta nên làm cách khiến nó thành tự động.\n Bình luận Đây là cuốn sách cuối cùng mình đọc liên quan đến công nghệ phần mềm trước khi đến với phần thử thách với mình nhiều hơn: Machine Learning và Computer Vision.\nCuốn sách đặc biệt phù hợp với các bạn sinh viên năm 3, 4 sau khi đã học về lập trình hướng đối tượng cũng như đã trải qua một thời gian tiếp xúc với những mã nguồn, dự án có sẵn. Thời gian đọc có lẽ mất từ 5-7 ngày.\nĐiều thú vị khi mình đọc đó là cảm giác:\n wtf?? đổi tên biến cũng được gọi là refactor wtf?? đổi tên hàm cũng vậy …\n Mình nghiệm ra, refactor không phải là cái gì đó quá cao siêu, có lẽ bạn nào lập trình cũng đã từng thực hiện một lần. Nhưng refactor như thế nào hiệu quả, tốn ít thời gian và công sức và hơn hết là biết cách refactor là một chuyện khác.\nRefactoring là cuốn sách sẽ giải đáp những điều đó.\nFuture Works Mình đã đọc xong cuốn Design Patterns nhưng chưa biết review thế nào. Có lẽ cần nhiều thời gian hơn để có thể viết về các mẫu. Nhưng có lẽ mình không tập trung nhiều thời gian.\nKế hoạch sắp đến: Pattern Recognition and Machine Learning.\n","href":"/vi/docs/refactoring-review/","title":"Review Refactoring"},{"content":" Mình đã giành một ngày cuối tuần và dịp nghỉ lễ để ngồi xem 3 phần của Star Wars: 4, 5 và 6. Đánh giá sơ bộ về bộ phim thì nếu đặt bản thân vào thời điểm bộ phim được ra mắt thì đúng là một kiệt tác. Giờ mình xem vẫn còn rất ấn tượng với kĩ xảo được thực hiện trong phim. Theo như mình biết về 3D và các hiệu ứng hình ảnh vào thời điểm đó để dựng nên những mô hình 3D phi thuyền hay các loài ở các hành tinh là điều không thể. Và đúng như vậy, hầu hết các hiệu ứng hình ảnh không đến từ đồ hoạ máy tính.\nCốt truyện Cốt truyện của Star wars thực sự không quá hại não, kết cấu chặt chẽ với tình tiết trong phim luôn diễn ra liên tục khiến người xem hồi hộp theo dõi theo cuộc hành trình của các nhân vật. Tuy nhiên vì series này được sản xuất khá là lâu nên tốc độ phim tương đối chậm, đôi lúc dễ bị mất tập trung, nhưng nhìn chung rất cuốn hút. Mình nghĩ đây cũng là một điểm mạnh khiến cho bộ phim được cuồng đến vậy. Nội dung khó quá phức tạp và dành cho mọi lứa tuổi nên dễ đi vào lòng người. Kết hợp với các yếu tố giả tưởng, khoa học thì Star Wars xứng đáng là một hiện tượng của văn hoá Pop.\nMột điểm mạnh của dòng phim này có lẽ là việc xây dựng vũ trụ với việc xây dựng câu chuyện là cuộc chiến trong toàn cõi thiên hà của bên Kháng Chiến chống lại Đế Quốc, người viết truyện và cả khán giả tha hồ chìm đắm vào trong thế giới sci-fi đầy mê hoặc này. Và như vậy sự phức tạp trong hệ thống hành tinh, thể chế, cuộc sống ở mỗi hệ thiên hà cũng vì thế trở nên đa dạng. Thử so sánh với một dòng chiến tranh vũ trụ mà mình rất thích là StarCraft thì SC thì mới là câu chuyện xoay quanh khu vực Koprulu và ba chủng tộc chính Terran, Zerg và Protoss. Trong khi đó trong 3 bộ phim Star Wars là ta đã thấy bao nhiêu chủng tộc với biết bao điều lý thú.\nNhân Vật Mình không thích đồng chí Luke, hoặc cũng có thể là do mình đã thấy rất nhiều nhân vật có cốt truyện na ná giống giống ở khắp các thế giới tưởng tượng như Frodo trong Chúa Tể Những Chiếc Nhẫn, Harry Potter… trong thần thoại Hy Lạp và của trong Dune (sẵn tiện Star Wars lấy cảm hứng từ Dune) thành thử ra mình không bất ngờ lắm với độ trẻ trâu của nhân vật và được buff niềm tin như vậy. Sẵn bàn về những hero, thực ra những hero này luôn có một công thức được xây dựng và một mẫu hình chung.\nTrong khi đó mình rất thích thích công chúa Leia và Han Solo. Và mình cá là những thánh cuồng scifi, thể loại viễn tưởng phiêu lưu thì Leia là mẫu con gái trong mộng. Một minh chứng rõ ràng còn ảnh hưởng cả đến văn hoá Pop là anh Ross nhà ta còn nói bạn gái mặc bộ bikini của Leia trong Return of The Jedi. Cả tác giả của Doreamon cũng lấy thỉnh thoảng lấy hình tượng nàng công chúa này nữa. Nàng công chúa trong Star Wars bản lĩnh, lãnh đạo quân Kháng Chiến chống lại Đê Quốc nhưng cũng có những khoảnh khắc rất đáng yêu. Han Solo thì là chàng cao bồi vũ trụ, luôn lạc quan trong những lúc khó khăn nhất. Tình cảm của hai người được xây dựng nhẹ nhàng, đáng yêu và liền mạch với câu chuyện.\nCác nhân vật khác đều có chiều sâu trong tính cách cũng như về cuộc đời như thầy Yoda và thầy Kenobi cũng như các nhân vật phản diện khác.\nTổng kết Đây là một seri rất đáng xem, giới thiệu cho khán giả về thế giới Star Wars vô cùng rộng lớn với những cuộc phiêu lưu đầy thú vị. Xem xong mới chỉ 3 tập nhưng mình đã hiểu vì sao khán giả khắp nơi lại cuồng đến vậy, nhà nhà người người đều bàn tán về Star Wars đến vậy.\n","href":"/vi/docs/startwars-series-review/","title":"Review Start Wars series"},{"content":" Protocol Buffers (ProtoBuf hay PB) là một trong những thành phần quan trọng trong thư viện Caffe. Bài viết dưới đây là một số note và cách sử dụng Protocol Buffers trong ngôn ngữ C++. Mục tiêu ban đầu chủ yếu tìm hiểu xem khả năng tuỳ chỉnh của Caffe đến đâu. Giới thiệu Protocol Buffers là một cơ chế lưu trữ và thao tác dành cho dữ liệu có cấu trúc do Google phát triển. Protocol Buffers có thể so sánh giống như XML, tuy nhiên PB có một số ưu điểm (theo quảng cáo của Google): tiện hơn, nhẹ hơn (từ 3 đến 10 lần so với XML), thao tác đọc ghi nhanh hơn (20 đến 100 lần nhanh hơn so với XML) và dễ dàng hơn. Protocol Buffers cho phép người dùng thiết kế dữ liệu và sử dụng code tự động phát sinh để đọc ghi các dữ liệu đó.\nCơ chế Người dùng định nghĩa cấu trúc dữ liệu của mình trong file .proto. Trong đó định nghĩa kiểu dữ liệu, ràng buộc của các thuộc tính cũng như cấu trúc (mảng hay giá trị scalar). Trình biên dịch PB sẽ dịch file .proto thành một file mà ngôn ngữ lập trình đọc được (trong trường hợp C++ là file .h) giúp lập trình viên thao tác trên dữ liệu được thiết kế trước đó. Và như vậy, thay vì tự thiết kế 1 dữ liệu bằng chính ngôn ngữ lập trình, và tốn thêm thời gian để viết các cơ chế đọc ghi, chuyển đổi dữ liệu hay chuyển từ định dạng này (text) sang định dạng khác (binary), ProtoBuf sẽ tự động sinh code cho những thao tác này.\nTrong Caffe Protocol Buffers đóng vai trò khá quan trọng trong thư viện Caffe. Nếu không sử dụng PB thì Caffe trở thành một thư viện rất khó xài bởi nhiều lí do:\n Không có tài liệu cụ thể để tuỳ chỉnh các layer hay tự thiết kế mạng cho riêng hệ thống. Vấn đề này được giải quyết đơn giản nhờ PB. PB cho phép cá c tác giả của Caffe tạo ra các dữ liệu dùng cho hệ thống này (Solver, Layer, Net, …). Những ai dùng Caffe chỉ cần bỏ chút thời gian để đọc lại đoạn thiết kế trong file proto này đã được comment khá đầy đủ và chi tiết. Nhờ việc open source phần này nên các nhóm nghiên cứu khác có khả năng custom bằng cách thêm các Layer hoặc thêm các hàm vàotrong hệ thống Caffe.\n Khả năng không custom cao: việc tạo ra một kiến trúc mới khá dễ dàng nhờ vào PB. Việc thiết kế một mạng giờ đây giống như một trò xếp hình với các khối là những kiểu dữ liệu được thiết kế trong ProtoBuf [Hình 1]. Một ví dụ kinh điển là sử dụng Caffe để thiết kế mạng LeNet. Người nghiên cứu không phải quá nặng đầu hay nhũn não để viết code C++ hay Matlab hay Python hay Cuda để thiết kế mạng mà thay vào đó là viết một kiến trúc trong file prototxt như thiết kế một cấu trúc XML hoặc JSON. Tác giả Caffe cũng không nhũn não khi ngồi parse từ file text sang kiểu dữ liệu của mình.\n  Cài đặt Clone mã nguồn của ProtoBuf tại Github, sau đó cài theo lệnh\n ./autogen.sh ./configure make make install  Thiết kế dữ liệu Dữ liệu được thiết kế trong một file proto. Dưới đây là ví dụ trong website của Google, mục đích để quản lý danh bạ điện thoại.\npackage tutorial; message Person { required string name = 1; required int32 id = 2; optional string email = 3; enum PhoneType { MOBILE = 0; HOME = 1; WORK = 2; } message PhoneNumber { required string number = 1; optional PhoneType type = 2 [default = HOME]; } repeated PhoneNumber phone = 4; } message AddressBook { repeated Person person = 1; }  Để biên dịch file này, ta gõ lệnh\n protoc -I=$SRC_DIR --cpp_out=$DST_DIR $SRC_DIR/addressbook.proto  Trong đó $SRC_DIR là thư mục chứa mã nguồn, $DST_DIR là thư mục chứa các code cpp mà ProtoBuf sẽ phát sinh, addressbook.proto là file chứa dữ liệu danh bạ. Trước khi xem thử trong ProtoBuf viết cái chi chi, ta xem thử ProtoBuf đã phát sinh ra 2 file addressbook.pb.cc và addressbook.pb.h. Trong đó chứa tất cả phần định nghĩa và cài đặt của các Lớp đối tượng Person, PhoneNumber. Chính xác là ProtoBuf đã làm giúp dev chuyện thiết kế lớp, viết phần truy xuất và chuyển đổi kiểu dữ liệu, thao tác các thuật tính (kiểm tra thuộc tính, getter và setter). Xong, ta quay lại phần thiết kế của ProtoBuf.\nCú pháp Trong bài viết mình chỉ giới thiệu rất vắn tắt về các từ khoá sử dụng trong ProtoBuf nhằm có thể tìm hiểu cơ chế thiết kế dữ liệu trong Caffe. Chi tiết hơn về cứ pháp ngôn ngữ này có thể tham khảo ở trang tài liệu của ProtoBuf.\n package: tương đương với namespace trong C++. message: tương đương với Class trong C++. int32 ,string , enum: tương đương với các kiểu dữ liệu trong C++. Ngoài ra trong ProtoBuf còn có bool, float, double. Các giá trị 1, 2, … đằng sau các khai báo: các tag phân biệt nhau trong một message. Có 3 modifier như sau: required, optional, repeated:\na. required: trường bắt buộc phải tồn tại trong 1 lớp. b. optional: trường có thể tồn tại hoặc không trong một lớp. c. repeated: trường là một mảng động (không có phần tử nào hoặc có 1 hay nhiều phần tử).\n  Trong Caffe Bây giờ quay trở lại file proto của Caffe và dường như mọi thứ đã quá rõ ràng. Với mỗi hàm activation, hàm loss, các Layer (convolution, reshape, filter, …) và Blob (chứa dữ liệu) Caffe thiết kế các lớp chính là nơi chứa các tham số cho các hàm, layer và data này.\nMột điều khá thú vị đó là thư viện TensorFlow của Google cũng sử dụng ProtoBuf cho project của họ.\nNếu như chú ý kĩ, trên website của Caffe không liệt kê toàn bộ các tham số có thể cấu hình cho các Layer trong thiết kế mạng. Có thể kể đến ở đây như Data Layer, trong tham số transform_data có scale, mean_file_size, mirror và crop_size; nhưng nếu xem trong phần định nghĩa của protobuf, ta thấy ngoài ra còn có mean_file, mean_value, force_color và force_gray, qua đó ta thấy được rõ ràng xem protobuf có lợi hơn là xem trong phần documents. Một điểm thuận lợi khác là file caffe.proto được cập nhật liên tục so với document trên website.\nLấy một ví dụ minh hoạ trong mạng AlexNet. Có 2 file prototxt rất đáng quan tâm và hầu như ở các model được cung cấp sẵn đều có đó là: train_val.prototxt và solver.txt.\ntrain_val.prototxt Đây là file chứa kiến trúc mạng của mô hình được cung cấp. Trong này định nghĩa toàn bộ kiến trúc (các tầng, tham số của mỗi tầng) cũng như định nghĩa dữ liệu đầu vào và output đầu ra cho mạng deep.\nname: \u0026quot;AlexNet\u0026quot; layer { name: \u0026quot;data\u0026quot; type: \u0026quot;Data\u0026quot; top: \u0026quot;data\u0026quot; top: \u0026quot;label\u0026quot; include { phase: TRAIN } transform_param { mirror: true crop_size: 227 mean_file: \u0026quot;data/ilsvrc12/imagenet_mean.binaryproto\u0026quot; } data_param { source: \u0026quot;examples/imagenet/ilsvrc12_train_lmdb\u0026quot; batch_size: 256 backend: LMDB } } layer { name: \u0026quot;data\u0026quot; type: \u0026quot;Data\u0026quot; top: \u0026quot;data\u0026quot; top: \u0026quot;label\u0026quot; include { phase: TEST } transform_param { mirror: false crop_size: 227 mean_file: \u0026quot;data/ilsvrc12/imagenet_mean.binaryproto\u0026quot; } data_param { source: \u0026quot;examples/imagenet/ilsvrc12_val_lmdb\u0026quot; batch_size: 50 backend: LMDB } }  Thành phần đầu tiên là name, tên của mạng. Các phần tử tiếp theo là các layer, tất cả các tham số liên quan đến layer đều nằm trong khối ngoặc \u0026lt;span class=\u0026quot;p\u0026quot;\u0026gt;{\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;w\u0026quot;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;p\u0026quot;\u0026gt;}\u0026lt;/span\u0026gt;. Có 3 thành phần chắc chắn có của một layer:\n name: tên của layer. Caffe dựa vào tên layer để xác định xem layer đó ở đâu trong mạng. type: chắc chắn rồi, Caffe cần biết đây là layer Input hay là layer Convolution hay là ReLu hay là Softmax. top/bottom: xác định xem layer hiện tại sẽ nằm trên layer nào và sẽ nằm dưới layer nào. Vì kiến trúc mạng kiểu xếp tầng thế này rất thuận tiện để thiết kế mạng CNN. Và điểm bất lợi đó là ta khó có thể thiết kế các mạng có cấu trúc phức tạp hơn, kiểu như đồ thì chẳng hạn.  Ngoài 3 thuộc tính kể trên, mỗi layer sẽ có những tham số khác, phụ thuộc vào loại layer và tính chât của layer đó trong mạng.\nsolver.prototxt Đây là tập tin chứa tham số trong quá trình train mạng deep và các tham số trong quá trình forward cũng như lan truyền ngược.\nnet: \u0026quot;models/bvlc_alexnet/train_val.prototxt\u0026quot; test_iter: 1000 test_interval: 1000 base_lr: 0.01 lr_policy: \u0026quot;step\u0026quot; gamma: 0.1 stepsize: 100000 display: 20 max_iter: 450000 momentum: 0.9 weight_decay: 0.0005 snapshot: 10000 snapshot_prefix: \u0026quot;models/bvlc_alexnet/caffe_alexnet_train\u0026quot; solver_mode: GPU  Ta dễ dàng thấy ở đây có net: dẫn đến file chứa kiến trúc mạng. Một số tham số khá quen thuộc như: momentum, max_iter, có cả một thuộc tính nhằm set xem mạng sẽ chạy ở GPU hay CPU (solver_mode). Cũng giống như các tham số ở train_val.prototxt, tất cả các thông tin về cấu hình được đề cập trong file caffe.proto.\nTổng kết Protobuf đóng vai trò quan trọng trong công cụ Caffe, giúp các nhà nghiên cứu có thể dễ dàng xây dựng, chỉnh sửa, cũng như chia sẻ kiến trúc mạng của mình với cộng đồng. Ngoài ra protobuf còn giúp nhà lập trình dễ dàng trong quá trình xây dựng hệ thống phần mềm cũng như mã nguồn. Đối với người dùng, việc xem xét, hiệu chỉnh trên file prototxt thuận lợi và tốn ít công sức hơn so với đọc từ code C++ hay kể cả matlab, cũng như có một “ngôn ngữ chung” cho thiết kế mạng deep.\n","href":"/vi/docs/protocol-buffers-caffe/","title":"Sử dụng Protocol Buffers trong C++ và Caffe"},{"content":" constexpr Đầu tiên ta xem xét động lực của việc tạo ra từ khoá mới này. Điều mà C++11 muốn tạo ra chính là tăng tốc hiệu suất của chương trình viết bằng ngôn ngữ này. Ta quay một chút về cú pháp define bất hủ của C, ưu điểm của phương pháp tạo macro chính là hiệu suất nhanh, các hàm được tạo ra trong lúc biên dịch và không tốn bộ nhớ cũng như các lệnh nhảy trong hàm. C++ cũng có tham vọng vậy, và mục tiêu của C++ chính là nếu một biến/hàm có thể tính toán được trong thời gian biên dịch thì tính luôn tại thời điểm đó. Và như vậy trong quá trình chạy chương trình sẽ không mất thêm thời gian tính toán hàm/biến này. Done! Thời gian thực thi chương trình được nhanh hơn.\nNhìn đi nhìn lại mới thấy ngôn ngữ C được thiết kế rất hay, tinh giản nhưng mạnh mẽ. Để giải quyết vấn đề loại bỏ define trong C mà C++ đã chế ra const, inline và tá lả tùng xèn các thứ khác. Tuy nhiên cái gì cũng có hai mặt của vấn đề, với các từ khoá const, inline, ... thì việc người lập trình đỡ nhọc hơn về phần code (hạn chế được các lệnh define) nhưng để sử dụng tốt các tính năng của C++ khiến người lập trình phải hiểu rõ tính năng mà ngôn ngữ đó cung cấp. Tầm hoạt động Từ khoá constexpr được sử dụng cho 3 đối tượng như sau:\n Hàm. Biến. Hàm khởi tạo.  Trong đó, nếu từ khoá này được dùng cho khai báo đối tượng hoặc biến thì đối tượng hoặc biến đó được ngầm hiểu là const. Trong trường hợp là hàm, thì hàm đó được ngầm hiểu là 1 hàm inline.\nQuay lại câu chuyện vì sao có 3 ẻm này.\nTừ khoá constexpr có hàm nghĩa hoàn toàn khác với const:\n const: không được thay đổi giá trị. constexpr: thực thi tại thời điểm biên dịch.  constexpr là từ khoá yêu cầu trình biên dịch tính toán phép tính hay biểu thức tại thời điểm biên dịch, trong khi đó const là công cụ giúp trình biên dịch nhắc nhở người dùng những biến nào không được thay đổi giá trị (nó chỉ nhắc nhở, có nghĩa là nếu ta muốn đổi cũng ok). constexpr liên quan mật thiết tới khái niệm biểu thức hằng (constant expression). Vậy constant expression là gì?\nBiểu thức hằng là biểu thức mà trình biên dịch có thể tính toán được. Điều đó có nghĩa biểu thức hằng không thể thực thi nếu các biến/ toán tử trong biểu thức chưa được biết trong thời gian biên dịch, và biểu thức này không gây ra tác dụng phụ (side effect). Thêm vào đó, biểu thức hằng phải được cấu thành từ các giá trị nguyên, các số thực và kiểu liệt kê (enumerator), hay các tổ hợp của 3 kiểu dữ liệu này (một trong những cách tổ hợp là tạo ra 1 đối tượng giữ các giá trị này: constexpr constructor ra đời là vì lí do này).\nTrong quá trình viết mã, người lập trình sẽ có yêu cầu đặt tên biến cho giá trị của biểu thức hằng (constexpr function ra đời) hoặc các dữ liệu có trong biểu thức, và đây chính là lí do mà constexpr variable ra đời. Ngoài việc đặt tên, biểu thức hằng còn có kha khá công dụng khác nhau như:\n Sử dụng trong khai báo kích thước mảng, nhãn trong lệnh switch, tham số trong template. Trong các hệ thống nhúng, các giá trị chỉ đọc các chi phí thấp hơn so với giá trị dữ liệu động. Ngoài ra dữ liệu chỉ đọc tránh được các lỗi trong hệ thống. Trong các hệ thống đa luồng, biểu thức hằng tránh được hiện tượng data race. Tăng hiệu suất chương trình.  constexpr variable Khi khai báo constexpr thì biến đó được hiểu là const - tức không thể thay đổi nội dung trong quá trình thực thi chương trình. Nhưng khác với const ở chỗ: constexpr là hằng ở quá trình biên dịch, và còn const thì được qui định trong quá trình thực thi.\nĐể trở khai báo một biến là constexpr, biến đó phải thoả mãn một số điều kiện sau:\n Kiểu của biến phải thuộc kiểu Literal. Khi khai báo là biến constexpr, biến đó phải được định nghĩa ngay trong thời điểm đó. Tham số của hàm khởi tạo trong kiểu của biến này phải chứa: (1) kiểu literal, (2) biến constexpr, (3) hàm. Hàm khởi tạo của biến được khai báo phải thoả các điều kiện của constexpr constructor và trong Kiểu/Lớp đó phải có hàm khởi tạo là constexpr constructor.  constexpr function Để khai báo là một constexpr function, hàm này phải thoả những điều kiện sau:\n Không phải là hàm ảo (virtual funciton). Kiểu trả về phải là LiteralType. Mỗi tham số đầu vào của hàm phải thuộc kiểu LiteralType.  Hàm chỉ được chứa các lệnh sau:\n state_assert. Chỉ có duy nhất 1 lệnh return. Lệnh Null, lệnh không thực hiện gì. Lệnh khai báo typedef. Khai báo sử dụng using.  constexpr constructor Hàm khởi tạo constexpr được xây dựng nhằm phục vụ cho các biến constexpr, vì hàm khởi tạo cũng là hàm nên nó có những yêu cầu buộc thoả mãn giống như constexpr function, ngoài ra constexpr constructor còn phải thoả mãn một số điều kiện:\n Lớp chứa hàm khởi tạo constexpr có hàm cha không phải là Lớp ảo. Không phải hàm khởi tạo function-try-block.  Ghi chú Các thông tin trên được lấy từ chuẩn C++11, tuy nhiên trong C++14 có những thay đổi lớn sẽ được cập nhật sau.\nTham khảo  C++ Programm Language. Book: C++ Programming Language.  ","href":"/vi/docs/constexpr/","title":"constexpr: Hằng biểu thức trong C++11"},{"content":" Hồi năm 1 đại học, mình rất thích cuốn C Programming Language của K\u0026amp;C, dù cuốn sách khá là ít trang nhưng đầy tinh tuý và rất hấp dẫn. Đến tận bây giờ, khi đã tốt nghiệp ra trường, tức đã 4 năm được biết cuốn sách, đôi lúc mình vẫn muốn đọc lại. Một thời gian sau mình có đọc thêm một số sách có tựa: The XXX Programming Language nhưng chỉ thấy C++ là hay.\nBản C++ Programming Language mới nhất cập nhật cách tính năng của C++11, vì vậy, đây là một cuốn rất cần thiết cho bất kì ai muốn tìm hiểu về phiên bản C++11 cũng như các phiên bản tiếp sau như C++14, C++17. Chính vì những tính năng hoàn toàn mới và những thay đổi kể từ C++03, bản cập nhật này thêm vào kha khá chương so với phiên bản 3 của cuốn sách.\nNhìn chung Điều mình không thích nhất là bản 4 đã bỏ phần câu hỏi và bài tập ra khỏi cuốn sách - điểm mà ngày xưa mình rất thích. Một điều nữa là cuốn sách khá là dày, một số phần khá hay, một số phần giống sách reference về ngôn ngữ lập trình. Mà điều đó lại không cần thiết lắm vì nếu cần tra cứu thì cppreference hay cplusplus lại gần gũi và chi tiết hơn.\nPart I: Introductory Material Đây là phần rất hay của cuốn sách. Tác giả giúp người đọc hình dung được như thế nào là lập trình sử dụng ngôn ngữ C++. Vì sao điều này quan trọng? Theo như kinh nghiệm bản thân, rất nhiều người học lập trình bị lẫn lộn giữa C++ và C, và hơn thế nữa là sử dụng tư tưởng của Java hay C# khi lập trình C++. Thêm vào đó, phần I giới thiệu sơ lược về thư viện chuẩn - một thành phần rất quan trọng trong ngôn ngữ C++.\nTừ các ví dụ tính toán thông thường đến các sử dụng các cấu trúc dữ liệu, thiết kế hàm hay module cũng như thiết kế hướng đối tượng, chương cuối của phần I còn đề cập phần mới đó là tính toán song song.\nPart II: Basic Facilities Phần này đề cập đến các thành phần cơ bản trong ngôn ngữ C++. Cơ bản ở đây gồm có:\n Các lệnh (lặp, điều kiện, …) Hàm. Cấu trúc mảng, con trỏ và reference. Structure và các cấu trúc liên quan như Enumeration, Union. Exception và namespace.  Các tính năng (1) và (2) có lẽ rất quen thuộc với những ai đã lập trình với các ngôn ngữ họ nhà C. Tuy nhiên, các tính năng (3), (4) và (5) lại khá quan trọng. Nằm vững phần này giúp việc tránh các lỗi rất ngỡ ngẩn vì nhầm lẫn khái niệm trong C++.\nPart III: Abstraction Mechnisms Phần này cực kì quan trọng và có lẽ là phần mình thấy hay nhất trong cuốn sách bởi lẽ:\n Tác giả đề cập đến lập trình hướng đối tượng và các kĩ thuật liên quan. Tác giả nêu lên những vấn đề trong lập trình hướng đối tượng cũng như phát triển phần mềm. Tập trung vào phương pháp trong kiến trúc ngôn ngữ nhằm giúp lập trình viên giải quyết các vấn đề dễ dàng hơn. Các kĩ thuật trong phát triển phần mềm khá hay và thực tế.  Tuy nhiên, điều làm mình không thích lắm có lẽ ngay ở các C++ giải quyết các vấn đề. Đặc biệt là ở template, và mình cảm thấy càng về sau càng rắm rối. Và điểm này C++ rõ ràng không “tốt” trong thiết kế hơn Java. Về mặt “hướng đối tượng” có lẽ Java đảm nhiệm tốt hơn hẳn.\nPart IV: the Standard Library Phần “chán” nhất trong cuốn sách. Vì sao ư? Hầu như tác giả liệt kê toàn bộ các lớp, hàm, cũng như thiết kế trong thư viện chuẩn. Nếu đề cập một số thành phần quan trọng (container, algorithm hay string) thì không có gì đáng nói. Nhưng là toàn bộ thư viện chuẩn rất đồ sộ và việc đọc hết part này rất mệt, nó giống như đọc một cuốn từ điển vậy. Ưu điểm duy nhất mình thấy khi đọc phần này đó là phát hiện ra một số hàm mà mình không nghĩ là nó tồn tại (điển hình là convert từ string sang số và ngược lại). Chương mình nghĩ là quan trọng gồm:\n Container. Algorithms. Threads and Tasks, (Optional) Memory: mặc dù khá quan trọng, nhưng mình nghĩ dùng unique_ptr hay weak_ptr vẫn có gì đó không ổn.  Tổng kết Đây là cuốn sách rất đáng đọc cho bạn này đang học/làm việc hay quan tâm về ngôn ngữ C++. Như chính Bjarne Stroustrup từng nói: “Lập trình C đau thương như thể bắn vào bàn chân mình; nhưng C++ còn khó hơn; đó là lúc bạn bắn bay cả đôi chân của mình” Nguồn, để tránh bản thân “đau thương” đến vậy thì C++ Programming Language chính là cuốn sách hướng dẫn sử dụng súng. Ngoài ra, một số chương còn đề cập đến phương pháp cũng như quá trình hình thành ngôn ngữ và các tính năng trong ngôn ngữ, đó cũng là những kiến thức rất hay trong viết phần mềm. Nhưng đây không phải là cuốn sách để đọc ngấu nghiến từ trang đầu tới trang cuối cùng. Theo kinh nghiệm của bản thân, có thể đọc một số phần tuỳ thuộc vào việc người đọc đang làm việc với C++ ở mức độ nào:\n Đang học lập trình: Part 1 và Part 2 rất quan trọng, đọc xong 2 part là ở mức khá khi hiểu về C++ rồi. Đang học về lập trình hướng đối tượng: Part 3 buộc phải đọc, bỏ qua phần Template. Part 1 là optional nhưng khuyến khích đọc nếu trước đây bị lậm Java hay C# nhiều, Part 2 có thể không đọc. Người làm về C++: Part 3 và Part 4. Cho dù cppreference hay cplusplus có tiện đi chăng nữa thì trong sách này là văn bản chính thức và qui chuẩn về các hàm cũng như về thư viện STD. Expert về C++: đổi sách khác đọc. Xét về khía cạnh expert thì mình nghĩ cuốn sách này hơi chung chung và chưa đi sâu vào các vấn đề trong lập trình C++.  ","href":"/vi/docs/review_cpp_proglang_book/","title":"Review: The C++ Programming Languages"},{"content":" Đây là một trong những khoá rất đỉnh về lập trình, vì sao ư?\n Kiến thức được dạy vững chắc và có nhiều thông tin rất thú vị và bổ ích. Bài tập lập trình rất hay. Bài tập trắc nghiệm giúp người học hiểu rõ hơn về các thuật toán và cấu trúc dữ liệu trong bài giảng. Các câu hỏi phỏng vấn rất hay và sáng tạo.  Part 1 của khoá học cover các phần sau:\nUnion-Find Cấu trúc dữ liệu này rất hay. Một phần nó hay là vì hồi đại học mình chưa được học cấu trúc này, cộng thêm nó cũng có kha khá ứng dụng trong thực tế (phần Interview Questions có vài câu hỏi khá thực tế). Vì phần này ngoài cấu trúc dữ liệu nên bài tập và phần lập trình không quá xoắn não.\nStacks and Queues Phần bài tập lập trình làm về cấu trúc Deque và RandomizedQueue, khá là thú vị. Phần thuật toán có giới thiệu giải thuật Graham scan - tìm tập bao lồi trong một tập các điểm. Phần này thì cũng không quá khó, thiên về lập trình và API là nhiều. Để được 100/100 điểm lập trình thì cần tricky một chút cho phần RandomizedQueue.\nMerge sort và Quicksort Hai thuật toán sort rất nổi tiếng, đồng thời tác giả có đề cập cả stable sort và các vấn đề liên quan. Ví dụ như tìm k phần tử nhỏ nhất (có thuật toán nào có thể run tốt hơn O(nlogn) không). Vì sao quick sort lại tốt hơn merge sort dù 2 ẻm này đều là O(nlogn), vì sao ta phải shuffle dữ liệu trước khi thực hiện quick sort, merge sort được sử dụng trong các thuật toán cần stable sort. Đồng thời bài giảng cũng đề cập đến các thuật toán sort được cài đặt sẵn trong các ngôn ngữ lập trình.\nPhần bài tập lập trình cũng hơi tricky, tui nhiên rất hay: đó là tìm những điểm collinear trong một mặt phẳng.\nPriority Queue và Symbol Table Học về heap sort và các vấn đề liên quan. Bài tập lập trình 8-puzzle, một bài rất hay.\nBalanced Search Trees Cây và các vấn đề liên quan đây cây cân bằng, điểm mình thấy hay nhất đó là được học về 2-3 tree, cây đỏ đen, B-tree. Đặc biệt là B-tree sử dụng trong cơ sở dữ liệu và hệ điều hành. Một phần khá hay khác là thuật toán sử dụng trong không gian, điển hình là kdtree. Bài tập lập trình là kdtree, quá là phê luôn.\nBài tập trắc nghiệm trong phần này bao khó, vì phải chạy bằng tay cây đỏ đen.\nHash Tables Học về hashing function, các cấu trúc dữ liệu trong hashing, birthday problem … blah blah. Một trong những ứng dụng của nó chính là cấu trúc dành cho véc tơ, ma trận thưa (sparce vector), nhờ khoá này mà khi dự một buổi meeting có liên quan đến Hashing thì mình không bị bỡ ngỡ bởi các khái niệm.\nKhoá học còn một phần nữa là Part 2, đề cập đến các chủ đề như:\n Đồ thị. Cây. Maximum Flow và Minimum Cut. Regular Expression và Data Compression. Reductions và Linear Programming.  Tổng kết Một khoá bắt buộc phải học với những ai theo nghiệp lập trình. Một trong những điểm cộng sáng giá đó là khoá học này không giảm độ khó so với khoá gốc ở Princeton (Như khoá Machine Learning của Andrew Ng. trên Course thì quá dễ so với khoá của ông ở Stanford). Không những được học về những cấu trúc dữ liệu và giải thuật kinh điển mà còn được học, sử dụng vào các ứng dụng thực tiễn, các bài toán còn nóng hổi cũng nhưng các giải thuật nâng cao. Bài tập lập trình rất hay và sáng tạo, điểm cộng đó là cho người học tự do với sự sáng tạo cũng như cách ra đề giúp người học động não.\nMột số lưu ý Thầy dạy rất dễ buồn ngủ, để tránh hiện tượng này ta có thể:\n Tăng tốc độ video lên 1.25 hoặc 1.5, việc này giúp não tránh bị nhàm chán. Viết note đầy đủ. Pause video, viết một đoạn code minh hoạ thuật toán hoặc search wiki về các thông tin thầy đề cập. Uống nước cho tinh thần thoải mái, tránh Red Bull và nước có ga.  Để theo hết được khoá học, thì đây là một số kinh nghiệm của bản thân:\n Follow theo đúng deadline và lịch của khoá học. Tốt nhất là dành 2 ngày để nghe video, vì thường 1 tuần sẽ có 2 nội dung học. Một bài thường có thời lượng 60-70 phút, tốt nhất nên dành 2 tiếng trong ngày để nghe video, ghi chép và tìm hiểu. Dành khoảng 10 phút giải lao trong mỗi 45 phút học bài. Dành một tuần cho bài tập lập trình và bài tập trắc nghiệm. Dành một ngày trong tuần sau đó để ôn lại bài, làm lại bài tập hoặc nộp lại bài lập trình. Thông thường khi bài lập trình rất khó để đạt 100/100 ngay từ lần submit đầu tiên, tuy nhiên để đạt trên 80 thì không khó. Cố gắng nắm bắt thật kĩ đề bài, thiết kế API và mã giả trước, được kĩ checklist cũng như hint được tiết lộ. Chịu khó Google về bài tập, thường chủ đề của bài tập là những bài toán/vấn đề nổi tiếng trong Khoa Học Máy Tính. Tham gia diễn đàn, ta sẽ được an ủi phần nào khi có kha khá đứa cũng đang nổi điên với bài tập như mình. Bài tập trắc nghiệm: đọc lại slides, với các bài tập thuật toán thì cần chạy chính xác từng lệnh trong thuật toán đó bằng tay. Các bài tập về mệnh đề rất mẹo, cần đọc kĩ câu hỏi và xem kĩ lại video.  ","href":"/vi/docs/review_algs_princeton_coursera/","title":"Review Algorithms (Princeton) - Coursera"},{"content":" Bài viết tập trung các thủ thuật khi sử dụng kỹ thuật Hướng Đối Tượng trong Python. Thực ra trong Python, các khái niệm về hướng đối tượng đã được giản lược nhiều. Thêm vào đó, lại không có những khái niệm phức tạp như access modifier, destructor, \u0026hellip; Việc xây dựng các class cũng vì thế đơn giản hơn.\nEnum trong python Sử dụng lớp được cài đặt trong thư viện cung cấp sẵn:\nfrom enum import Enum class Color(Enum): RED = 1 GREEN = 2 BLUE = 3  Không multiple constructors Nhưng ta có thể sử dụng optical argument như một thế mạnh và thay thế cho multiple constructor.\nKhông access modifier Đồng nghĩa với việc không có public, private hay là protected gì cả. Ngay cả việc thêm __ vào trước properties hay method cũng không giải quyết được vấn đề. Với mỗi thuộc tính __p của lớp A đơn giản là được đổi tên thành _A__p.\nPrivate methods Sử dụng tiền tố __ khác các phương thức muốn đặt private.\nTạo property Nếu được, tạo thành method thay thế. Còn không có thể sử dụng decorator @property trước method để đổi thành property.\nĐa kế thừa Tránh vấn đề này càng tốt. Tham khảo tại đây.\nCác thuộc tính và method static Mình không nghĩ là cần thuộc tính hay method static cho lắm. Nếu có thể cài thuộc tính/method static thì thay vào đó có thể đặt bên ngoài class và xếp trong cùng module. Nhưng vậy có thể truy cập các thuộc tính, hàm thông qua module thay vì class, và mình thấy hầu như không khác nhau là mấy.\nGọi constructor từ lớp cha Đây là một vấn đề khá nan giải trong trường hợp đa kế thừa. Giả sử ta có lớp A, lớp B và C. Trong đó lớp C kế thừa vừa lớp A và lớp B. Vấn đề là làm thế nào để gọi A, B trong hàm khởi tạo, và làm thế nào để biết lớp cha nào được gọi trước.\nclass A(object): def __init__(self): super(A, self).__init__() print \u0026quot;entering A\u0026quot; print \u0026quot;leaving A\u0026quot; class B(object): def __init__(self): super(B, self).__init__() print \u0026quot;entering B\u0026quot; print \u0026quot;leaving B\u0026quot; class C(A,B): def __init__(self): print \u0026quot;entering c\u0026quot; super(C, self).__init__() print \u0026quot;leaving c\u0026quot; if __name__ == '__main__': c = C()  Có một số điều khá thú vị xoay quanh điều này sau khi ta thử nghiệm hoán vị trình tự kế thừa, trình tự định nghĩa lớp:\n Trong mỗi hàm phải khai báo super(ClassName, self).__init__() thì việc gọi các hàm khởi tạo từ các lớp cha mới thực hiện được. Không phụ thuộc vào trình tự kế thừa. Trình tự hàm khởi tạo được gọi dựa them alphabet.  Practices  Để kiểm tra một biến có phải là 1 thể hiện của lớp không, sử dụng hàm isinstance, tuy nhiên khuyến khích không xài. Vì Python là Duck Type mà. Khai báo một thứ na ná struct trong C/C++: {% highlight python %} class ClassName: pass {% endhighlight%}  Sau đó thì có thể tha hồ thêm thuộc tính nào vào cũng được.\nReferences  https://docs.python.org/2/tutorial/classes.html  P.s: Các chủ đề hại não và nâng cao có thể được đề cập là Iterators, Generators, \u0026hellip;\n","href":"/vi/docs/oop-python/","title":"Lập Trình Hướng Đối Tượng Trong Python"},{"content":"Và thế là ẻm laptop cũ của đã ra đi theo tiếng gọi của một tên hay một tập đoàn trộm nào đó mà mình không biết được. Dành chút thời gian thương tiếc em nó vậy. Cũng đã 4 năm rồi.\nNgày xưa đi mua laptop cứ nghĩ máy nào cấu hình mạnh là ngon cơm, mà thực ra ẻm Dell mình mua trâu bò lắm. Có những lúc chạy thực nghiệm mình để máy chạy liên tục trong mấy ngày liền. Có đợt rảnh rảnh ngồi vọc Linux, mà tụi này hỗ trợ card màn hình rời AMD không tốt lắm, máy nóng kinh. Thế là mình để quả trứng gần quạt tản nhiệt, thế mà nó cũng làm chín được đống lòng trắng. Lúc mới mua về, mình từng hổ báo cài tất cả đống game đang hot lúc đó về chơi thử. Nó chạy ầm ầm, mượt là đằng khác. Từ dạo đó luôn hổ báo về độ gấu của em nó.\nHồi năm nhất còn dán quanh màn hình hình nền Assasssin\u0026rsquo;s Creed nữa mới máu. Lên năm hai thấy nó hơi màu màu nên quyết định gỡ ra, nhưng mà keo dính lâu quã, gỡ ra nó bong ra cả lớp nhựa nên nhìn không còn xinh tươi nữa. Cộng thêm sự vụ nào đó khiến cho bản lề phía bên trái của màn hình bị gãy mất, mở màn hình mạnh tay là đi luôn. Theo trí nhớ của mình thì chỉ có 2 vụ liên quan: (1) hồi năm 1 ngủ chung với mấy đứa có lúc đạp cái chân vô cái bàn làm rớt laptop, (2) lúc đi vệ sinh máy có đông chí bên BKComputer làm hư. Vì vụ đó mà máy thường xuyên bị nóng: một số mảnh nhựa phần bản lề bị vỡ văng qua chỗ quạt tản nhiệt làm quạt quay chậm hẳn đi, mà máy nóng quá thì nó lại tắt đột ngột.\nChuyện gì tới cũng tới, đến cái ngày phát hiện ra card rời bị hư cũng đau lòng không kém. Kể từ đó là khỏi chơi những game xịn mà chuyển hệ chơi những game ngày xưa, đã thế máy nó lại như tới tháng, không biết được sức khoẻ ra sao.\nEm nó bị thay bàn phím 2 lần, 1 lần lanh chanh ở trong lớp khui Coca và thế là ga tràn ra ngoài, đổ hết lên bàn phím. Một lần nữa thì không nhớ thế nào, nhưng có kinh nghiệm hơn đợt trước nhiều. Vì bàn phím \u0026ldquo;rời\u0026rdquo; nên rất dễ tháo lắp, chứ như con Macbook mà bị vô nước thì ăn hành.\nThực ra sau lần mua máy và sử dụng thế này, có kha khá nhiều kinh nghiệm được rút ra. Điển hình như là vụ pin, cho dù có cẩn thận thế nào thì một ngày đẹp trời pin nó cũng sẽ chai. Cứ xài bình thường là ok rồi. Từ năm 3 trở đi cái máy không thể xài nếu không có nguồn điện gần đó, mà mình cũng không dám đặt em nó lung tung, chỗ nào nguồn không bị lỏng mới dám cắm.\nEm nó chính thức bị mất dữ liệu 2 lần: (1) năm nhất khi nghe lời dụ dỗ của thằng bạn cùng trọ trong lúc cài Linux và (2) khi mới xách ẻm Mac về và thể hiện độ nguy hiểm khi chép dữ liệu. Cả 2 lần không có gì quá nghiêm trọng, lần hồi năm 1 tuy chưa kịp sao lưu dữ liệu nhưng trong đó cũng không có gì riêng tư lắm, dễ dàng lên mạng down về. Lần hai thì có kinh nghiệm hơn, sao lưu hết trên đám mây. Số lần nhập viện của em nó tầm 4 lần, chủ yếu sửa cái bản lề và card màn hình. Đáng ra em ấy cũng không tới nỗi bị thay thế hoàn toàn, nhưng khi phải làm các project dài hơn mà lap cứ lên bờ xuống ruộng thì rất là oải. Có lần mình liều mình khui máy ra để coi thực hư nó bị gì.\nĐiều kinh dị đó là tháo ra lắp vô và dư mấy con vít. Linh kiện chi chít nhưng không quá khó để tháo, nhờ sự vụ hôm đó mà mình tìm hiểu thêm được cấu hình phần cứng bên dưới. Thiệt là tinh vi. Từ dạo đó mình tự tin hẳn lên, thực ra mỗi lần phải xách máy đi sửa là khi mình có cảm giác cần phải thay linh kiện, chứ nếu không có gì thì mình cũng có thể tự sửa được.\nEm nó bị cài lại Windows không biết bao nhiêu chục lần và bị làm thí nghiệm cho những ý tưởng \u0026hellip; táo tợn của mình với số lần không kể hết. Có những lần truy cập sâu đến hệ thống dẫn đến mém đi thay chip hay thay cả ổ cứng, may mà lúc đó tay nghề \u0026ldquo;khám phá\u0026rdquo; của mình hơi cao nên em nó cũng không đến nỗi liệt toàn phần.\nẺm cũng đã đi theo mình trong suốt quá trình mình đi Pháp, Singapore và Nhật. Và hầu như những lúc mình cần ẻm thì ẻm không đến nỗi khiến cho mình quá thất vọng. Giờ chuyển qua xài MacBook thì không dám mạnh tay với ẻm mới này. Một phần vì sợ, một phần vì dạo này dữ liệu quan trọng đã nhiều lên, lanh chanh làm gì thì đi tong mất đống projects. Thời gian cũng không dư dả để nghịch công nghệ như hồi trước.\nẤy vậy mà đã 4 năm gắng bó với em ấy, còn mấy ngày nữa là bảo vệ luận văn.\nLại kể, mình dần già rồi.\n","href":"/vi/docs/em-laptop-yeu-dau/","title":"Thôi đành chia tay "},{"content":" Sau thời gian đắng lòng vì cái luận văn và phải lên bờ xuống ruộng với nhiều tình huống éo le cây me. Cũng thêm vào đó, sau cái sự vụ này rút ra được nhiều kinh nghiệm xương máu hơn bao giờ hết. Hiện giờ công việc dù vấn đang ngập mặt, nhưng có vẻ thư thả hơn, kèm theo đó kết quả thực nghiệm khá tốt, công việc trên lab cũng dần ổn định khiến tinh thần phấn chấn và có nhiều kế hoạch loạn xị ngầu hơn trong thời gian tới. Nhưng vẫn muốn viết tí tí cho vui.\nDùng phần mềm phiên bản ổn định Mình đã phải lên bờ xuống ruộng với Mac Office 2016 Preview. Dù giao diện rất đẹp, UI\u0026amp;UX tốt hơn so với bản trước đó. Nhưng điều đắng lòng là mình không thể chèn công thức toán sử dụng MathType vô được. Chưa kể là một phần mềm khác để quản lý tài liệu tham khảo cũng không thể cài trên WORD 2016. Nên dù sao đi nữa, trong những công việc quan trọng và các phần mềm cần thiết không phải lúc nào cũng update lên hàng xịn là tốt.\nTự động hoá các công việc đánh số Trong này bao gồm cả: đánh số trang, đánh chỉ mục hình ảnh, chỉ mục bảng biểu và chương. Điểm thuận lợi có thể kể đến như:\n Không phải nhức não khi phải cập nhật lại chỉ mục khi thay đổi nội dung. Với những thành phần có sẵn trong Word, chỉ cần Ctrl+A và F9 hay F11 là nó đã tự động cập nhật lại rồi. Dễ dàng trỏ đến các phần tử này mà không mất thời gian. Nếu tự chèn thì không làm được trò này rồi. Quản lý các thành phần (công thức, tài liệu tham khảo, hình ảnh) khá là dễ dàng. Định nghĩa style của nó cũng dễ hơn nữa.  Dĩ nhiên, lúc đầu xài thì cảm thấy khá là nhọc, vì không quen là chính. Nhưng đó là điều rất nên làm.\nMình có một số kinh nghiệm có thể kể đến như\n Với công thức, luôn dùng hệ thống đánh số của MathType. Và như vậy, mỗi khi kết chương hay kết mục, phải chèn kí tự ngắt chương hoặc mục của MathType vô. Khi muốn tham chiếu đến 1 công thức nào đó cũng phải chèn bằng lệnh của MathType.\n Với trích dẫn khoa học, một công cụ hay ho mà mình tìm được đó là Mendeley Desktop ( Download ). Nó có thể tìm kiếm tài liệu, lưu lại thông tin và cho phép chèn tham khảo, chèn danh mục tham khảo với nhiều định dạng khác nhau. Nó còn hỗ trợ Refman nên việc lấy citation từ Google Scholar về và chén vô cũng rất dễ, công cụ này hoạt động khá là thông minh nên xài khá thoải mái. Hầu như mình không cần phải lo lắng về chuyện trích dẫn nữa. Một tính năng bá đạo của nó là có thể lấy được thông tin bài báo bằng cách import vào file pdf. so cool\n  Nếu được, sử dụng Latex Latex có lẽ là công cụ tốt nhất để biên tập các tài liệu khoa học. Hệ thống biên soạn công thức phong phú, khả năng quản lý các thành phần, đánh số, \u0026hellip; nhất quán và dễ dùng. Tuy nhiên công cụ này khá là đồ sộ, hiểu nó là một ngôn ngữ cũng được nữa. Nên chính điều đó khiến cho giai đoạn đầu của việc dùng Latex khá là khó khăn. Tuy nhiên với một số text editor có snippet thì việc nhớ các cú pháp chèn hình hay công thức không còn quá khó khăn nữa. Mình chỉ ngại mỗi Latex là khi phải debug những lỗi khi viết, mất rất nhiều thời gian và không phải lúc nào cũng theo ý mình được. Vì lẽ đó mà mình xài Word 2011 cho an toàn.\nĐịnh nghĩa tất cả style trước khi viết Khi buộc phải viết theo một định dạng nào đó, chuyện đầu tiên khi mở một văn bản mới là định nghĩa hết tất cả stule dùng trong đó, từ Heading 1, Heading 2, TOC, đánh số,\u0026hellip; Điều này tạo sự nhất quán trong quá trình viết, không phải đợi tới lúc viết xong mới làm chuyện này sẽ mất thời gian và xuất hiện một số lỗi ngoài ý muốn.\n","href":"/vi/docs/viet-luan-van/","title":"Kinh Nghiệm Viết Tài Liệu Khoa Học"},{"content":" Mưa vẫn hay mưa trên hàng lá nhỏ\n Lâu lắm rồi tôi mới cảm nhận một cơn mưa Sài Gòn khiến tôi nhớ nhà da diết đến vậy. Khác ở quê, mưa ở Sài Gòn thật khó chịu, chợt đến, chợt đi, chả ai hay. Những cơn mưa vội vàng như nhịp sống ở đây vậy.\nMùa này ở quê nhà, hẳn mưa mùa hè đang đến. Những lúc ngồi trong quán cafe quen thuộc nhìn những hàng xe đan nhau trên con đường Nguyễn Văn Cừ, chợt trong tôi hiện về thằng nhóc năm xưa rúc dưới tấm chăn nằm nghe tiếng mưa gõ nhịp trên mái tôn, những cơn mưa dài không dứt, một thời vô tư lự, một thời vô ưu.\nNhững lúc ấy, mây đen kéo từ phía xa, mọi người lo kéo những tấm bạt những thóc, những ớt và đậu vô nhà. Tụi con nít lớn tuổi (là con nít và lớn hơn tôi), chạy ra ngoài sân của nhà thờ Công Giáo đá bóng. Một hai đứa nhóc thích thú thấy trời nổi gió lại xách diều ra thả trong nổ lực thể hiện khả năng của mình. Ngoài việc khiến cho diều quay mòng mòng và không thể lên cao nổi cột điện thì việc chay quanh cả xóm như vậy khiến người lớn nhìn ngao ngán. Những lúc đó, tôi không được ra ngoài vì sắp mưa, chút lại hơi đất xông lên. Đám thanh niên thì bất chấp rồi, tôi lại không thể để hơi đất xông vô người, thể nào tối cũng bị nhức đầu.\nLúc nhỏ, hễ thấy có mây đen là tôi mặc định có mưa. Ba tôi khác, ông có thể biết chính xác chiều đó có mưa không. Tôi còn nhớ những lần nhà đi chơi, ba tôi dự thế nào thì trúng chóc vậy. Vô Sài Gòn, tôi nghĩ siêu năng lực dự đoán của đó không áp dụng được ở đây.\nMưa rào ở quê kéo dài suốt cả buổi chiều. Đợi đến khi mưa to hẳn, tôi mới lon ton chạy ra ngoài chơi. Ngày xưa có chơi cút bắt, đá bóng, chạy ra bờ sông rượt nhau. Thi thoảng có mấy đứa bắt chước các bậc cao thủ võ lâm ngồi ngay dưới máng nước, tưởng tượng mình đang ngồi dưới dòng thác bế quan luyện công. Có cái máng nước ở gần nhà ông Bốn bán sách là cao nhất, đứng dưới đó hứng những dòng nước nặng đến nỗi ong ong cả đầu. Mấy thằng đực rất thích chơi trò này lấy le với con gái trong xóm.\nNgay chỗ ngả ba là vùng thấp, mưa một chút là ngập ngay. Có những lúc mưa lớn ngập ngang bụng tụi con nít chúng tôi, cả đám lại háo hức như là lụt đã đến, lặn hụp bơi lội thích thú. Nghĩ lại, tôi biết vì sao lúc nhỏ mình lại nổi ghẻ vậy.\nTrời tạnh mưa và trong xanh lạ. Tôi nhớ đâu đó trong những cuốn văn nào đã đọc, trời sau mưa đẹp lắm, lúc đó tôi cũng thấy đẹp, nhưng chả biết tả sao.\nBây giờ cũng vậy, chả biết tả sao. Như là tinh khôi đến thăm một xóm nhỏ. Mọi thứ xung quanh trở nên sáng hơn, tươi hơn và đẹp hơn. Tôi cùng những đứa trong xóm lấy giấy ra gấp thuyền nan thả. Một lúc sau ngồi xổm mò theo con thuyền trôi.\nNhững kỉ ức cứ trôi về, nhưng dòng nước ngày nào còn chảy. Trong kí ức nào, con thuyền trôi không điểm dừng.\n Giờ xa vắng thuyền em bước trên con đường Giờ xa vắng thuyền trôi mình em trên phố vắng\n Tối đến là \u0026ldquo;đại chiến giữa những vì sao\u0026rdquo; giữa tụi thanh niên trong xóm, tụi nít trong xóm, tụi thanh niên khác xóm, tụi nít khác xóm. Quy mô lớn nhỏ phụ thuộc vào nhà nào sáng đèn nhất, tôi háo hức muốn bắt những con dế. Thường mỗi \u0026ldquo;team\u0026rdquo; con nít chỉ có khoảng 2, 3 đứa. Đến hạ màn bao giờ cũng chả còn mống nào, vì thế náo chỉ vì một con dế mà chia rẻ nội bộ. Đám thanh niên bắt dế để nhậu. Còn tụi nít thì đứa đem về nuôi, đứa đem về chiên mắm ớt, đứa cột lại quay mòn mòn rồi đem đá với nhau.\nThời gian trôi nhanh quá, giờ ngồi nhớ lại tôi không thể nào nhớ được chính xác mùa vị thế nào. Nhưng cái không khí của những đêm hè ấy, lại vang vọng khắp nơi.\n Có người con gái đã hỏi tôi, vì sao đất miền Trung khó sống vậy. Nhưng người ở đây vẫn bám đất, bám lấy cái eo của đất nước đầy biến động. Ở đó, trong từng thớ đất, mang hồn quê.\n Những đứa con tha hương luôn đau đáu ngày trở về.\n","href":"/vi/docs/mua-van-hay-mua/","title":"Mưa Vẫn Hay Mưa"},{"content":"  I don\u0026rsquo;t need sex, because OpenCV and XCode (LLVM) f*ck me whole day.\n Một ngày đầy kinh khủng với OpenCV cài trên MAC OSX, đây là mới cài để xài cho Python, Qt và C++, chưa đá động đến CUDA hay OpenNI hay trên iOS nữa, vậy mà nó đã khiến mình tốn nguyên 1 ngày kinh khủng.\nBài này, mình viết dưới dạng tutorial nâng cao. Tức là không còn style step by step nữa, thay vào đó chỉ hướng dẫn sơ lược cũng như các trick cần nhớ để dễ cài hơn. Và lần này là hướng dẫn cài cho cross-platform. Để sure rằng đụng trên OS nào mình sẽ không còn bị ngán. (Yeah!!)\nGhi chú Một số ghi chú mà mình đã rút được một cách đầy xương máu, đầy kinh dị. Theo mình nhớ, cách đây 4 năm lần đầu cài OpenCV mình cũng đã mất gần 2 ngày, giờ cài trên MAC OSX mất tầm 1 ngày. Hú hồn.\n Best pratice: Tập sử dụng CMAKE hoặc Makefile. Cả 2 đều rất được việc khi config lúc build opencv hay lúc chạy chương trình. Dù muốn hay không, thì CMake vẫn là interface trên cả 3 nền tảng. Chính vì điều đó nên phải biết \u0026hellip; tập mà xài. Ưu điểm có thể kể đến như sau:\n Config được cấu hình của OpenCV. Điều này những bản build sẵn không làm được. Cấu hình phù hợp với máy. CMake sẽ tự động tìm các package và cố gắng config khi có thể. Dễ sử dụng, nếu dùng CMake GUI thì rất dễ dùng.  Sau mỗi lẫn thay đổi cấu hình trên CMake thì nhấn Configure lại để CMake cập nhật.\n Với bản MAC OSX, nên chọn compiler là Unix Makefile, mọi lựa chọn khác tớ đều không chịu trách nhiệm.\n Chuyện kinh dị đêm khuya, chọn compiler là XCode. Khi build các source khác ( 1 tool rút trích đặc trưng chẳng hạn), thế là nó dính ngay lỗi undefined symbols for architecture x86_64, lỗi này khắc phục bằng cách thêm flags -lstdc++ vô trình biên dịch, nhưng đắng lòng tiếp theo là sau khi compile thì hàng mớ lỗi xảy đến vì sự khác nhau trong hệ thống standard library của XCode và GNU. Lúc đó, chắc chắn chả ai còn hứng thú để mà sửa lỗi tiếp.\n Nên có 1 sổ ghi chú, hoặc note ghi lại quá trình cài đặt, không là fail dài dài. Mà thậm chí là cứ làm lặp đi lặp lại mọi thứ.\n  Cài đặt Trong phần này gồm các bước cài đặt OpenCV sử dụng CMake. Dùng mà thấy mình cứ như là hacker\n Tải source OpenCV về. a. Tải từ website. b. Tải từ github. Giải nén và tạo thư mục build\nmkdir build  Mở CMake, chọn đường dẫn đến.\n Nhấn Configure và chọn compiler tương ứng.\n Bên Linux, theo mình nhớ là GNU. Bên Windows, khuyến khích chọn Visual Studio. Tuy nhiên, số phiên bản của VS khác với số năm của Visual Studio (Tức là Visual Studio 2013 thì không phải có v13). Sau bao đau thương, MAC OS X thì chọn Unix Makefile.  Trong lúc nó run, thì tranh thủ đọc về sự khác nhau của static lib và shared lib\n Config các tham số cấu hình, mình thì quan tâm đến vài thứ sau: Qt, Python, Cuda. Vì hôm nữa chắc sẽ có 1 tut khác liên quan đến mấy cái này. Để ý output coi có báo lõi gì không.\n Nhấn Configure đến bao giờ trên phần tham số không còn đỏ nữa thì thôi. Lúc đó nhấn build.\n Build OpenCV thôi. a. Với các bé họ nhà Unix (Mac OSX, Linux \u0026hellip;):\ncd path/to/build/dir make -j4 # jk với k là số thread để chạy sudo make install  b. Với các bé nhà Windows:\nChịu khó xem lại bài post cũ của mình, mình sẽ update bản mới trong thời gian đến\n  UPDATE 1: Vẫn chưa cài được Opencv 3 lên trên python sau bao nhiêu nỗ lực thực hiện với MAC OS X. Mình sẽ cài đặt nó lên trên Linux để test xem sao.\nUPDATE 2: Chắc hôm nào sẽ viết tutorial trên cả 3 nền tảng step-by-step.\nP/S: Bạn nào muốn share bài của mình thì vô tư, nhưng nhớ ghi rõ nguồn.\n","href":"/vi/docs/opencv-tips/","title":"Ghi chú hướng dẫn cài đặt OpenCV"},{"content":"Không còn gì sung sướng hơn sau 2 ngày ngồi cài cái khỉ gió sparse coding lib cho python, link cái thằng khỉ gió nó ở đây: Spams lib. Mặc dù đã cố gắng nhưng phải mất mấy tiếng đồng hồ mình mới xong được cu cậu này.\nSau đây là một số kinh nghiệm xương máu mình có thể rút ra như sau:\n Không giống như cu Linux hay các bản distro của nó. Trên Mac có 2 cái package manager: MacPorts và HomeBrew. Mà 2 cái này nó lại đẻ ra một số chuyện linh ta linh tinh:\n Chúng cài đặt các phần mềm ở những chỗ khác nhau, như cu MacPorts nhét trong /opt/local/bin/, cu kia thì kinh dị hơn, nhét trong /usr/local/Cellar/ làm mình chả biết đường nào mà lần.\n Tất cả các đồng chí trên đều đưa đường dẫn đến $PATH, và rồi hầm bà lằng các conflict xuất hiện khiến mình muốn điên đầu.\n Bài học tổng kết: chỉ nên xài 1 trong 2 cu\n  Không nên tin tưởng hàng của Apple cho lắm, cu cậu chế ra các thứ quá là điên:\n Trình biên dịch của Apple chế ra một số options mà ta phải kể đến như cái -arch chết dịch, ngoài ra còn có cu warning -Wshorten64-to-32. Python tự generate ra những option dựa trên hệ điều hành đang dùng, khổ một cái, cái compiler mình dùng lại không support cho mấy cái chuyện đó.\n Ngoài ra, clang của Apple còn không hỗ trợ cả OpenMP, mà cái này bắt buộc phải có trong cái sparse coding lib này. Đại khái nó cứ luẩn quẩn.\n Chưa hết, trong setup.py cu này để option mặc định là -m32, tức là sử dụng kiến trúc 32bit. Máy mình lại là 64bit. Sửa lại thì được nhưng lại phải chọn kiến trúc trong file thực thi của python.\n   Đại khái là xoắn. Giờ thì mình đã biết cách giải quyết:\n Cài python từ trang chủ.\n Xác định đường dẫn chính thức của nó, mò xem nó ở đâu và add vô trong $PATH.\n Sử dụng Superpack để cài các gói liên quan trong scipy. link nó đây. Trong này thì lưu ý cái biên $PIP, sửa lại cho phù hợp với cái máy của mình.\n Đối với cu numpy và scipy thì cài đặt thông qua pip.\n  ","href":"/vi/docs/spams-lib/","title":"Spams Lib và Những Tâm Sự"},{"content":"","href":"/vi/tags/c++/","title":"C++"},{"content":"","href":"/vi/categories/","title":"Categories"},{"content":"","href":"/vi/tags/computer-vision/","title":"Computer Vision"},{"content":"","href":"/vi/tags/machine-learning/","title":"Machine Learning"},{"content":"","href":"/vi/page/","title":"Pages"},{"content":"","href":"/vi/publication_types/","title":"Publication_types"},{"content":"","href":"/vi/page/search/","title":"Search"},{"content":"","href":"/vi/tags/","title":"Tags"},{"content":"","href":"/vi/tags/algorithms/","title":"algorithms"},{"content":"","href":"/vi/tags/android/","title":"android"},{"content":"","href":"/vi/tags/books/","title":"books"},{"content":"","href":"/vi/tags/computer-science/","title":"computer science"},{"content":"","href":"/vi/tags/computer-vision/","title":"computer vision"},{"content":"","href":"/vi/tags/computer-vison/","title":"computer vison"},{"content":"","href":"/vi/tags/courses/","title":"courses"},{"content":"","href":"/vi/tags/cpp/","title":"cpp"},{"content":"","href":"/vi/tags/cvpr/","title":"cvpr"},{"content":"","href":"/vi/tags/deep-learning/","title":"deep learning"},{"content":"","href":"/vi/tags/documentary/","title":"documentary"},{"content":"","href":"/vi/tags/font/","title":"font"},{"content":"","href":"/vi/tags/games/","title":"games"},{"content":"","href":"/vi/tags/gaming/","title":"gaming"},{"content":"","href":"/vi/tags/history/","title":"history"},{"content":"","href":"/vi/tags/machine-learning/","title":"machine learning"},{"content":"","href":"/vi/tags/memories/","title":"memories"},{"content":"","href":"/vi/tags/misc/","title":"misc"},{"content":"","href":"/vi/tags/movies/","title":"movies"},{"content":"","href":"/vi/tags/notes/","title":"notes"},{"content":"","href":"/vi/tags/opencv/","title":"opencv"},{"content":"","href":"/vi/tags/programming/","title":"programming"},{"content":"","href":"/vi/tags/python/","title":"python"},{"content":"","href":"/vi/tags/research/","title":"research"},{"content":"","href":"/vi/tags/review/","title":"review"},{"content":"","href":"/vi/tags/singapore/","title":"singapore"},{"content":"","href":"/vi/tags/software-engineer/","title":"software engineer"},{"content":"","href":"/vi/tags/taocp/","title":"taocp"},{"content":"","href":"/vi/tags/travel/","title":"travel"},{"content":"","href":"/vi/tags/tutorial/","title":"tutorial"},{"content":"","href":"/vi/tags/vietnam/","title":"vietnam"},{"content":"","href":"/vi/tags/visual-studio/","title":"visual studio"}]
