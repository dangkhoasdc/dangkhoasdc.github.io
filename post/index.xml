<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Dang-Khoa&#39;s blog </title>
    <link>http://dangkhoasdc.github.io/post/</link>
    <description>Recent content in Posts on Dang-Khoa&#39;s blog </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Dang-Khoa</copyright>
    <lastBuildDate>Tue, 26 Sep 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="/post/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Why Ubuntu on Windows?</title>
      <link>http://dangkhoasdc.github.io/post/ubuntu_on_windows/</link>
      <pubDate>Tue, 26 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/ubuntu_on_windows/</guid>
      <description>

&lt;p&gt;For programming purposes, I prefer Linux to Windows. However, Windows is really good at entertaining and office works. I admit that Microsoft Office is the best office suited I ever have experienced. Besides, OneNote is one of my favorite note-taking software, not to mention my beloved Bilizzard games such as Diablo, Starcraft.&lt;/p&gt;

&lt;p&gt;One solution to combine Windows and Linux is to install dual-boot in the machine. However, I am tired of switching between 2 OSs. In addition, we have to configure the systems so that it can easily transfer files between 2 different partition formats.&lt;/p&gt;

&lt;p&gt;Another workaround is to run Windows or Linux on a virtual machine. Since I usually play video games, I could not use Windows as a client. Running Linux virtually seems promising. Unfortunately, my laptop is not strong enough to run the virtual machine smoothly.&lt;/p&gt;

&lt;p&gt;Finally, M$ comes up with a new feature in Windows 10 which is &amp;lsquo;Windows Subsystem for Linux&amp;rsquo;. Suprisingly, it works flawlessly except several minor issues.&lt;/p&gt;

&lt;h1 id=&#34;settings&#34;&gt;Settings&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Turn Windows Sybsystem on: (1) find &lt;code&gt;Windows features&lt;/code&gt; and select &lt;code&gt;Windows Subsystem for Linux&lt;/code&gt; , wait for the installation and restart the machine.&lt;/li&gt;
&lt;li&gt;Open Windows Store and install Ubuntu. I also saw OpenSuse on the store. Hopefully, there will be more distros adapted in future, especially Arch Linhx/Manjaro which is my favorite.&lt;/li&gt;
&lt;li&gt;After working around with Ubuntu and Tmux in &lt;code&gt;cmder&lt;/code&gt; , I found out that &lt;a href=&#34;https://github.com/mintty/wsltty&#34; target=&#34;_blank&#34;&gt;wsltty&lt;/a&gt; is the best solution to avoid fonts broken, key arrow issues. Besides, it run faster than &lt;code&gt;cmder&lt;/code&gt; although &lt;code&gt;cmder&lt;/code&gt; has many useful features.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Here is the result:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://static.notion-static.com/67ecfe6abf0242199ffec19dd227a000/Untitled&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;There are several tips:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Change the cursor to block.&lt;/li&gt;
&lt;li&gt;Turn off the mouse support feature in vim (&lt;code&gt;:set mouse=&lt;/code&gt;) in order to copy
text from Windows to vim.&lt;/li&gt;
&lt;li&gt;Copy from vim to Windows applications:

&lt;ol&gt;
&lt;li&gt;Install xsel/xclip on Ubuntu.&lt;/li&gt;
&lt;li&gt;Install &lt;a href=&#34;https://sourceforge.net/projects/xming/&#34; target=&#34;_blank&#34;&gt;Xming&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Set &lt;code&gt;export DISPLAY=:0&lt;/code&gt; in the bashrc or zshrc&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Đọc &#34;Nghệ Thuật Lập Trình&#34; (TAoCP)</title>
      <link>http://dangkhoasdc.github.io/post/taocp/howto/</link>
      <pubDate>Mon, 25 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/taocp/howto/</guid>
      <description>

&lt;p&gt;Phải thành thật, mình là fanboy của Donald Knuth. Có thể có rất nhiều giáo sư có
tầm ảnh hưởng lớn đến các hướng mà mình quan tâm (khoa học máy tính/ trí tuệ
nhân tạo hay thị giác máy tính) như Hinton, Li Fei-Fei, Zisserman, Pascal Fua.
Nhưng có rất ít nhà khoa học mà mình dành trọn thời gian để có thể tìm hiểu và
&amp;ldquo;cuồng&amp;rdquo; như Donald Knuth. Và mong ước của mình từ khi bước chân vào giảng đường
đại học, theo đuổi đam mê với Khoa Học Máy Tính, rằng mình sẽ chinh phục cuốn
&amp;ldquo;Kinh Thánh&amp;rdquo; này. Đó là một cuộc hành trình, và còn thử thách hơn cả tất cả
những hành trình mình từng trải nghiệm.&lt;/p&gt;

&lt;p&gt;Ngày sinh nhật vào năm đầu tiên đi làm, mình đã tự thưởng cho bản thân bản &lt;a href=&#34;https://www.amazon.com/Computer-Programming-Volumes-1-4A-Boxed/dp/0321751043/ref=sr_1_1?ie=UTF8&amp;amp;qid=1506337149&amp;amp;sr=8-1&amp;amp;keywords=the+art+of+computer+programming&#34; target=&#34;_blank&#34;&gt;full
set của bộ
sách&lt;/a&gt;
.  Trước giờ mình chỉ dùng với mục đích tham khảo là chính. Nhưng vừa sau đợt
sinh nhật 24 của mình, mình quyết định phải &amp;ldquo;chinh phục&amp;rdquo; bằng được cuốn sách.
Mà theo plan của mình Volume 1 sẽ tốn tầm &amp;hellip; 1-2 năm. Và có lẽ, mình sẽ mất
chừng chục năm để chinh phục Volume 4A 😆. Chưa kể, phần 4B cực kì khó nhằn
vì có cả Satistiability trong đó. Có lẽ riêng Volume 4 không thôi thì đã trở
thành tượng đài mất rồi.&lt;/p&gt;

&lt;h1 id=&#34;taocp-liệu-có-khó-đọc&#34;&gt;TAoCP liệu có khó đọc?&lt;/h1&gt;

&lt;p&gt;Theo mình thì không. Nhiều người khi nhìn vào cuốn sách với hàng đống công thức
toán và những bài tập khó nhằng cũng như code mã máy MIX khiến họ nghĩ đây là
một cuốn sách rất khó đọc. Nhưng ngay từ đoạn giới thiệu, Don Knuth đã hướng dẫn
cách đọc và ông đã chỉ rõ những vấn đề mà người đọc thắc mắc.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Với MIX - mình đồng ý quan điểm của Don Knuth, nếu ông viết chương trình theo
C/C++ hay Java hay Python, một thời gian sau chắc chắn nó sẽ có vấn đề. Kể cả
những ngôn ngữ bậc cao càng khiến ta khó phân tích chính xác số lượng tính
toán trong thuật toán đó. Mà theo phân tích của Knuth, đó phải là những phân
tích chính xác. Ngôn ngữ của MIX cũng rất dễ đọc, không đến nối rắc rối như
mọi người tưởng. Đồng thời, việc đọc code bằng mã máy khuyến khích người đọc
&amp;ldquo;vọc&amp;rdquo; với thuật toán được ghi. Thêm nữa, &amp;ldquo;ngôn ngữ bậc cao&amp;rdquo; mà Knuth dùng
chính là tiếng Anh.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Trong biểu đồ sử dụng sách của mình, Knuth có nói rằng nếu các công thức toán
&amp;ldquo;is all Greek to you&amp;rdquo; ta chỉ cần xem qua và nắm được kết quả cơ bản mà
phần đó đề cập, và hầu như các kết quả đó được nói ở đầu mục hoặc cuối mục.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Với bài tập của TAoCP, Knuth đề xuất hệ thống phân loại. Hơn hết, hệ thống
này nhằm giúp cho người đọc, với thời lượng cho phép của mình, lựa chọn và
làm những bài bản thân nghĩ là phù hợp. Bởi thật sự những bài với độ khó lớn
hơn 45, dù là không dính đến toán, M hay HM đều cần rất nhiều thời gian
nghiên cứu. Bản thân mình nghĩ nếu giải được những bài đó thì có thể hoàn
thành được PhD của Computer Science rồi. Nhưng mình vẫn nghĩ người đọc nên
xem qua các câu hỏi này,  &lt;strong&gt;vì nó chính là biên giới tri thức trong khoa học
máy tính.&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Knuth nêu rõ trong cuốn sách của mình, mục đích của cuốn sách phục vụ: (1) là
tài liệu tham khảo chính xác và chi tiết về phân tích thuật toán, (2) là một
sách giáo khoa  &lt;strong&gt;tự học&lt;/strong&gt;  dành cho những người đam mê về thuật toán cũng như Khoa
Học Máy Tính. Nếu bạn mua TAoCP chỉ với giá trị tham khảo thì đó hoàn toàn là
mục đích chính xác của bộ sách: mình đặc biệt thích phần tra khảo về lịch sử.
Đúng ra, Don Knuth rất quan tâm đến lịch sử của Khoa Học Máy Tính, đó là lí
do vì sao trong sách đề cập các thông tin lịch sử lại chi tiết đến như vậy.
Nhưng ngoài ra, phần bài tập lẫn lời giải, mà thường chiếm đến &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt; cuốn sách,
nói lên rằng Knuth mong mỏi cuốn sách này sẽ là một tài liệu học tốt dành cho
mọi người.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Kế hoạch của mình rất đơn giản: Chinh phục TAoCP đồng thời giúp mọi người dễ
dàng tiếp cận với tài liệu quý giá này. Quá nhiều bạn đọc dường như sợ tiếp cận
cuốn sách bởi những &amp;ldquo;myth&amp;rdquo; vừa nêu, đồng thời, chinh phục TAoCP là một hành
trình thực sự thú vị. Mình đã học được rất nhiều điều thông qua cuốn sách. Những
ngày đầu đại học khi lần đầu cầm trong tay Volume 1, mình mới thực sự hiểu
&amp;ldquo;computer science&amp;rdquo; là một khoa học đầy hấp dẫn, và nó cũng rất &amp;ldquo;art&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Mình đồng ý với quan điểm của Knuth, người làm về phân tích thuật toán hạnh phúc
gấp đôi những ngành khác: họ chiêm nghiệm được những công thức toán phức tạp để
tính toán độ phức tạp, phân tích thuật toán, đồng thời họ cảm nhận được tính
hiệu quả của thuật toán đó trong thực tế. Ta chắc chắn không cần bận tâm đến câu
&amp;ldquo;học toán để làm gì&amp;rdquo;, bởi khi tiếp cận với phân tích thuật toán, ta cảm nhận
ngay được ích lợi của toán học, thuật toán cũng như vẻ đẹp của thuật toán khi ta
cài đặt và sử dụng trong thực tiễn.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;một-chút-về-dự-án-này&#34;&gt;Một chút về dự án này&lt;/h1&gt;

&lt;p&gt;Ngoài những chi tiết ở trên, một phần khiến TAoCP khó đọc ở chỗ thông tin được
Knuth viết tương đối cô đặc. Chính vì lẽ đó mà đôi khi có những phần tương đối
khó hiểu đối với những bạn tìm hiểu về khoa học máy tính và chưa có nhiều kiến
thức trước đó. Mục tiêu của project này nhằm giúp các bạn dễ tiếp cận hơn với
sách, đồng thời giải thích các phần bài tập, bởi mình thấy Knuth viết phần
Solutions cực kì gọn, và đôi khi cũng không biết là từ đâu lại có những đáp số
đó. Ngoài ra, tìm hiểu về TAoCP cũng chính là tìm hiểu các thuật toán kinh điển,
các bài toán làm trên nền tảng của Khoa Học Máy Tính cũng như đây là nguồn tài
liệu rất quý giá để mài dũa &amp;ldquo;algorithmic thinking&amp;rdquo;. Một lý do nữa khiến mình có
hứng thú để làm đó là hiện nay tuy có khá nhiều blog, repo trên Github note lại
TAoCP nhưng chưa có ai viết đầy đủ, hoặc chi tiết.&lt;/p&gt;

&lt;p&gt;Loạt bài viết cùa mình yêu cầu người đọc đã đọc qua trước chương hoặc phần mình
đề cập trong bài viết, trong các bài viết mình sẽ chú trọng đến các chi tiết
sau:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Các chi tiết tương đối khó hiểu.&lt;/li&gt;
&lt;li&gt;Phần bài tập.&lt;/li&gt;
&lt;li&gt;Các state-of-the-art hiện nay.&lt;/li&gt;
&lt;li&gt;Các thông tin lý thú liên quan đến chủ đề đó.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Mình có tích hợp plugin Hypothesis giúp các bạn có thể highlight, viết note trên
blog của mình, đồng thời phần comment để mọi người thuận tiện trao đổi với nhau
cũng như giúp mình update các lỗi có trong bài viết.&lt;/p&gt;

&lt;h1 id=&#34;kinh-nghiệm-cá-nhân&#34;&gt;Kinh nghiệm cá nhân&lt;/h1&gt;

&lt;p&gt;Một số kinh nghiệm bản thân khi mình đọc TAoCP, thực ra đến tận bây giờ bản thân
mình mới dành thời gian với cuốn sách, trước đây mình chủ yếu dùng tham khảo là
chính:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Luôn có giấy và bút bên cạnh để có thể:

&lt;ul&gt;
&lt;li&gt;Chạy &amp;ldquo;chay&amp;rdquo; các thuật toán.&lt;/li&gt;
&lt;li&gt;Làm bài tập.&lt;/li&gt;
&lt;li&gt;Hiểu công thức đang muốn nói điều gì.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Có một sổ tay ghi chú. Một số chỗ Knuth viết rất cô đọng và mình nghĩ chỉ có
cách ghi note lại mới thực sự nhớ và hiểu được.&lt;/li&gt;
&lt;li&gt;Thử implement thuật toán bằng một ngôn ngữ ưa thích. Quan điểm của mình thì
C hoặc C++ là phù hợp nhất. C thì có thể gần với mục đích nhất,
trong khi đó C++ sẽ tiện hơn.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;một-chút-về-phần-preface-volume-i&#34;&gt;Một chút về phần Preface (Volume I)&lt;/h1&gt;

&lt;p&gt;Tuy chỉ là phần lời nói đầu, nhưng tác giả đã đề cập đến khá nhiều câu chuyện
hay ho mà mình có thể tóm lượt như sau:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Thuở xa xưa khi Khoa học máy tính mới hình thành, có 3 ngành chính thịnh hành
lúc bấy giờ: numerical analysis, artificial intelligent và language theory.
Chính Knuth là người đã khai sinh ra nhánh &amp;ldquo;analysis of algorithms&amp;rdquo;. Trước đó
đã có các công trình của Alan Turing, Jon von Neumann tuy nhiên đó là những
nghiên cứu rời rạc và không có một hệ thống hoàn chỉnh.&lt;/li&gt;
&lt;li&gt;Trong phần preface, Knuth đề cập rằng những phân tích của mình &amp;ldquo;non-numerical&amp;rdquo;
bởi vì nó quan tâm đến các đối tượng rời rạc nhiều hơn.
Nếu chọn &amp;ldquo;nonnumerical analysis&amp;rdquo; thì lại hơi mang tính tiêu cực
(có lẽ do tiền tố &amp;ldquo;non&amp;rdquo; trong đó). Trong khi đó &amp;ldquo;programming techniques&amp;rdquo; thì
lại quá hẹp về 1 phần trong lĩnh vực. Đó là lí do mà ông chọn từ
&amp;ldquo;analysis of algorithms&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Việc chọn mã máy MIX cũng được ông phân tích khá rõ trong phần này.
Thực sự những lý do đó hoàn toàn thuyết phục. Mình nghĩ một ngôn ngữ gần
nhất ông có thể dùng đó là C. Nhưng nếu như vậy ông phải định nghĩa số chỉ
thị cho từng câu lệnh trong C, điều này mình nghĩ không đơn giản lắm.&lt;/li&gt;
&lt;li&gt;Người đồng hành với ông trong cuốn sách này là &lt;a href=&#34;https://en.wikipedia.org/wiki/Robert_W._Floyd&#34; target=&#34;_blank&#34;&gt; Robert W. Floyd &lt;/a&gt;,
ông chính là tác giả thuật toán &amp;ldquo;Floyd-Warshall&amp;rdquo;, thuật toán phát hiện
vòng trong danh sách liên kết cũng như những đóng góp tiêu biểu của ông
trong &amp;ldquo;program verificaition&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ghi-chú&#34;&gt;Ghi chú&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Một bài nói của Don Knuth về mối quan tâm của ông với
lịch sử khoa học máy tính: [&lt;a href=&#34;https://youtu.be/gAXdDEQveKw&#34; target=&#34;_blank&#34;&gt;link&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;Phỏng vấn Don Knuth. Có khá nhiều chi tiết thú vị về suốt cuộc đời làm
nghiên cứu của ông (Ông mất chỉ 1 giờ để hoàn thành luận án
tiến sĩ của mình). [&lt;a href=&#34;https://youtu.be/vUJ01nRE7r0&#34; target=&#34;_blank&#34;&gt;link&lt;/a&gt;].
Mình sẽ có một bài tóm tắt về cuộc phỏng vấn đầy hấp dẫn này.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Tai nghe dành programmer</title>
      <link>http://dangkhoasdc.github.io/post/headphones/</link>
      <pubDate>Sun, 24 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/headphones/</guid>
      <description>&lt;p&gt;Thực ra câu chuyện mình sắp kể không liên quan là mấy đến tai nghe dành cho programmer. Nó ít nhiều liên quan đến chuyện: &lt;strong&gt;ra quyết định tối ưu&lt;/strong&gt; và không cần đắn đo đến nó nữa.&lt;/p&gt;

&lt;p&gt;Tuy nhiên, vì đang nói đến tai nghe dành cho programmer. Nên tiện thể mình đề cập. Chuyện là mình đang cần một tai nghe có tính năng noise cancelling tốt, vì tiếng xì xầm cũng như âm thanh văn phòng khiến mình khó tập trung, bản thân vừa làm research vừa programming, đôi khi mình cần không gian rất yên tĩnh để có thể dành toàn bộ neural cho 1 task nào đó. Một cái nữa là noise isolation - mình cần 1 tai nghe không rò rỉ âm quá, vì như vậy khiến người xung quanh cũng khó chịu.&lt;/p&gt;

&lt;p&gt;Sau một hồi research, mình cũng tìm được kha khá ứng viên:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.com/dp/B01MSZSL4I/_encoding=UTF8?coliid=IYBMB4TLNEFDG&amp;amp;colid=3NKUCAXZDPGHJ&#34; target=&#34;_blank&#34;&gt;Sennheiser HD 4.50&lt;/a&gt; (over-ear)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.com/gp/product/B001EZYMF4/ref=oh_aui_detailpage_o00_s00?ie=UTF8&amp;amp;psc=1&#34; target=&#34;_blank&#34;&gt;Sennheiser CX 300 II&lt;/a&gt; (earbud)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.com/Bose-QuietComfort-Wireless-Headphones-Cancelling/dp/B01E3SNO1G/ref=sr_1_5?ie=UTF8&amp;amp;qid=1506169318&amp;amp;sr=8-5&amp;amp;keywords=headphone+bose&#34; target=&#34;_blank&#34;&gt;Bose QuietComfort 35&lt;/a&gt; (over-ear).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Có một trang khá hay là RTINGS, trong đó có hẳn mục sử dụng tai nghe trong văn phòng ( &lt;a href=&#34;http://www.rtings.com/headphones/reviews/bose/quietcontrol-30-qc30-noise-cancelling-earphones&#34; target=&#34;_blank&#34;&gt;link&lt;/a&gt; ), mình nghĩ rất đáng để lướt qua. Đại khái lướt qua thị trường thì có Bose và Sennheiser là có tai nghe khá tốt cho việc dùng ở văn phòng. Ngoài ra còn có cả Jaybird, tuy nhiên mình không thích design của hãng này lắm.&lt;/p&gt;

&lt;p&gt;Một số trang dưới đây cũng rất đáng để xem xét, như một nguồn tham khảo khi quyết định mua tai nghe:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://codingsupply.com/best-headphones-programming/&#34; target=&#34;_blank&#34;&gt;Coding Supply&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.pixelmonkey.org/2016/09/11/headphones&#34; target=&#34;_blank&#34;&gt;Pixel Monkey&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.stuff.tv/features/best-noise-cancelling-headphones-every-budget/sennheiser-pxc-550&#34; target=&#34;_blank&#34;&gt;Stuff&lt;/a&gt; : tai nghe noise cancelling giá mềm.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Giờ mới là câu chuyện chính. Mình mất tầm 5 tiếng đồng hồ để xác định mình nên mua cái nào. Nhưng rốt cuộc, lại chọn đúng cái đã chọn trước đó. Bực bội hơn, mình cứ xem đi xem lại những cái tai nghe đã xem qua trước đó và thấy rằng nó hiện không phù hợp với nhu cầu của mình. Nó liên quan cả đến decision making lẫn optimization: tìm tai nghe tốt nhất trong những ràng buộc nhất định, đồng thời quyết định xem chọn mua cái nào. Sau một thời gian ngẫm nghĩ, mình đành tự propose một &amp;ldquo;framework&amp;rdquo; cho việc shopping và cố gắng không để tình trạng này diễn ra thêm lần nào nữa:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Xác định khoảng tiền mình bỏ ra. Và đây là là ràng buộc có trọng số cao nhất. Nó hạn chế mình tiêu quá tay, đồng thời giúp bản thân quản lý tài chính tốt, giảm thời gian shopping lại bởi mình có thể giảm không gian tìm kiếm xuống khá nhiều. Dĩ nhiên trước đó nên coi xem món hàng cần mua thường có khoảng giá bao nhiêu.&lt;/li&gt;
&lt;li&gt;Thời gian bỏ ra shopping tỉ lệ thuận với số tiền ước tính. Có thể mua 1 món hàng 800-1000 usd thì mình cần 1 ngày để tìm hiểu cái mình cần mua chẳng hạn. Với những món 10-15 usd có thể chỉ cần 30 phút quyết định.&lt;/li&gt;
&lt;li&gt;Bắt đầu tìm hiểu, nhất thiết phải ghi note lại, ghi chú các ưu nhược điểm mà những món hàng mình có dự định mua (potential items). Việc này giúp mình không phải đắn đo lại 1 món hàng hay xem đi xem lại. Theo mình thấy, nhiều link cùng đề cập đến 1 món và hầu như lúc nào mình cũng mở link để xem lại đúng mô tả của món hàng đó.&lt;/li&gt;
&lt;li&gt;Liệt kê đầy đủ các nhu cầu, ràng buộc, Liên tục cập nhật vào ghi chép.&lt;/li&gt;
&lt;li&gt;Nên cài đặt một &amp;ldquo;hàng đợi ưu tiên&amp;rdquo; (priority queue) theo tiêu chí của riêng mình và chỉ giữ top K phần tử tốt nhất (vd: top 3, top 5). Nếu nhưng list đó full và cần thêm 1 item nữa, thì chắc chắn mình sẽ cần bỏ đi 1 item. Nhờ vậy ta sẽ luôn phân tích ưu nhược điểm các item đó, để cuối cùng có quyết định chuẩn hơn.&lt;/li&gt;
&lt;li&gt;Mua hàng: đơn giản là chọn &lt;code&gt;top()&lt;/code&gt; ra khỏi và mua thôi. List &lt;code&gt;k-1&lt;/code&gt; item còn lại có thể dùng để &amp;hellip; mua sau đó hoặc có thể giữ làm Wish List chẳng hạn. Tuy nhiên mình nghĩ trước đó nên re-ranking trở lại.&lt;/li&gt;
&lt;li&gt;Nếu có nhiều items có cùng trọng số thì sao? Chuyện này có thể diễn ra, và likely diễn ra khá cao, ta có thể apply một số hypothesis sau:

&lt;ul&gt;
&lt;li&gt;Hỏi ý kiến người thân/bạn bè.&lt;/li&gt;
&lt;li&gt;Random.&lt;/li&gt;
&lt;li&gt;Dựa vào lượt review trên Amazon.&lt;/li&gt;
&lt;li&gt;Chọn cái nào rẻ hơn.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Matlab</title>
      <link>http://dangkhoasdc.github.io/post/matlab/</link>
      <pubDate>Mon, 18 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/matlab/</guid>
      <description>

&lt;h1 id=&#34;general&#34;&gt;General&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Show the information of a variable. It is very useful when we the code takes
so much memory: &lt;code&gt;whos &amp;lt;variable name&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Sum of squared of elements: &lt;code&gt;sumsqr(X)&lt;/code&gt;. Use &lt;code&gt;sum(sum(A.^2, 1))&lt;/code&gt; instead
if you want to use less memory.&lt;/li&gt;
&lt;li&gt;Memory optimizations tips and tricks:
[&lt;a href=&#34;http://undocumentedmatlab.com/blog/internal-matlab-memory-optimizations&#34; target=&#34;_blank&#34;&gt;Undocumented Matlab&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;Use column-based representation instead of the row-based one. For example, to
represent a list of items from 1 to 5, use &lt;code&gt;[1 2 3 4 5]&lt;/code&gt; (not &lt;code&gt;[1; 2; 3; 4; 5]&lt;/code&gt;).
It becomes convient because MATLAB supports &lt;code&gt;foreach&lt;/code&gt;-like statement:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-matlab&#34;&gt;for element = list
    % &amp;lt;statements&amp;gt;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If &lt;code&gt;list&lt;/code&gt; is a matrix, the above statement will assign each column of &lt;code&gt;list&lt;/code&gt; to
&lt;code&gt;element&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;code-optimization&#34;&gt;Code Optimization&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Replace &lt;code&gt;isempty(find(&amp;lt;expr&amp;gt;))&lt;/code&gt; by &lt;code&gt;isempty(find(&amp;lt;expr&amp;gt;, 1))&lt;/code&gt; to
improve performance.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;libraries&#34;&gt;Libraries&lt;/h1&gt;

&lt;h2 id=&#34;vlfeat&#34;&gt;VLFeat&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Use &lt;code&gt;vl_imreadjpeg&lt;/code&gt; instead of &lt;code&gt;imread&lt;/code&gt;. It could speed up reading image files.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>The Vietnam War - Dejavu</title>
      <link>http://dangkhoasdc.github.io/post/vietnam_war-dejavu/</link>
      <pubDate>Mon, 18 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/vietnam_war-dejavu/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.pbs.org/kenburns/the-vietnam-war/watch/episode-1/&#34; target=&#34;_blank&#34;&gt;[Link from PBS]&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Một bộ phim tài liệu lịch sử xuất sắc về chiến Tranh Việt Nam. Với sự tham gia phỏng vấn của nhà văn Bảo Ninh, nhà báo Huy Đức.
Điều làm nên bộ phim chính là tính chân thực và nhìn nhận đa chiều ở tất cả các bên tham gia vào cuộc chiến. Khác với &amp;ldquo;cuộc chiến 10k ngày&amp;rdquo;, bộ phim tài liệu trước đó &amp;ldquo;tránh&amp;rdquo; nói nhiều đến nội bộ việt nam cũng như quan hệ với Pháp. Ở seri phim này, ta có một cái nhìn rộng hơn, trung lập hơn.&lt;/p&gt;

&lt;p&gt;Tập 1 với tên Deja vu (bóng ma quá khứ) được xây dựng với hai mốc thời gian đan xen, như sự ẩn dụ đoán trước được sự thất bại của người Mỹ cũng sẽ giống những gì đã diễn ra ở Pháp. Deja vu, là hiện tượng tâm lý về ảo giác một trải nghiệm tưởng như bản thân từng trải qua ở một môi trường và hoàn cảnh hoàn toàn khác được nhà biên kịch khéo léo đặt cho tượng đề của tập 1: nước Mỹ chưa từng trải qua chiến tranh với Việt Nam, nhưng sau mấy chục năm nhìn lại, họ đáng ra đã &amp;ldquo;cảm nhận&amp;rdquo; được kết cục đó.&lt;/p&gt;

&lt;p&gt;Ngoài những thước phim đáng giá và những nhận định chi tiết cả hai phía, điều làm tôi cực kì ấn tượng là âm nhạc. Không chỉ thể hiện nội dung truyền tải, âm nhạc trong phim mang đến hơi thở văn hóa và xã hội những năm đó. Tôi rất thích các bản của Bob Dylan vầ Rosemary Clooney. Làm tôi nhớ đến cái đài radio quen thuộc của Fallout trong một &amp;ldquo;alternative history&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Điều có tôi thích nhất chính là những diễn biến leo thang về chính trị và phản ứng của hai bên trong bối cảnh thế giới. Thêm vào đó, có những diễn biến chưa bao giờ được hai bên kể trước đó, ít nhất là theo trí nhớ của tôi. Đó là câu chuyện bức thư chưa bao giờ được gửi đến Tổng Thống Truman của Cụ Hồ. Đó là những động thái chính trị cực đoan của cả hai phía. Tôi thích nhất là giai đoạn ông Diệm thành lập chính quyền, Lê Duẩn thành Bí Thư Thứ Nhất và sự phức tạp về chính trị trên thế giới. Cảm giác bạn được xem Game Of Thrones phiên bản lịch sử vậy.&lt;/p&gt;

&lt;p&gt;Những hình ảnh thì khỏi phải nói, giàu tính lịch sử và biểu tượng. Tôi phải thốt lên vậy khi xem những bức hình đầy ám ảnh.
&lt;div&gt;
&lt;blockquote class=&#34;imgur-embed-pub&#34; lang=&#34;en&#34; data-id=&#34;a/DXTC1&#34;&gt;&lt;a href=&#34;//imgur.com/DXTC1&#34;&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src=&#34;//s.imgur.com/min/embed.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;/div&gt;
Tập 1 đầy hấp dẫn, từ biên kịch phim, lối dẫn chuyện, hình ảnh và âm thanh.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Một vòng Henderson Waves và Haw Par Villa</title>
      <link>http://dangkhoasdc.github.io/post/henderson_waves-haw_par_villa/</link>
      <pubDate>Sun, 17 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/henderson_waves-haw_par_villa/</guid>
      <description>&lt;div&gt;
    &lt;a data-flickr-embed=&#34;true&#34; data-header=&#34;true&#34; data-footer=&#34;true&#34; href=&#34;https://www.flickr.com/photos/99093593@N07/albums/72157686733328033&#34; title=&#34;Henderson Waves&#34;&gt;&lt;img src=&#34;https://farm5.staticflickr.com/4400/37105032192_caa9b33971_c.jpg&#34; width=&#34;800&#34; height=&#34;534&#34; alt=&#34;Henderson Waves&#34;&gt;&lt;/a&gt;&lt;script async src=&#34;//embedr.flickr.com/assets/client-code.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;p&gt;Lâu lâu tôi lại đi dạo một vòng ở Sin chơi. Một phần thường ngày cuối tuần chỉ cắm đầu trên lab, một phần thì muốn đi đông cho vui. Chứ thực ra, nếu đi chơi một mình, hay đi với hai thằng thì rất chán. Tôi nghĩ đi chơi trừ khi đi với bạn gái hoặc bạn khác giới, còn lại đực rựa đi chung với nhau thì 3-4 người là phù hợp. Tôi chưa đi Henderson Waves bao giờ, nghe đồn đâu ban đêm ở đó đẹp lắm. Nếu search trên mạng thì sẽ thấy rất nhiều kết quả gợi ý đi đến nơi đây vào ban đêm.&lt;/p&gt;

&lt;p&gt;Ghé ở Vivo City, cả đám theo đường ngay phía trước ở Vivo City để leo lên núi (hay đồi). Tựa như là một khu rừng nguyên sinh vậy. Nghe cu Vinh kể là nơi đây có cả khỉ và động vật hoang dã. Rất nhiều người xài chai xịt tránh côn trùng, thành ra mùi xả lan khắp nơi làm tôi nghĩ nơi đây trồng nhiều.
    &lt;div&gt;
    &lt;a data-flickr-embed=&#34;true&#34; data-header=&#34;true&#34; data-footer=&#34;true&#34; href=&#34;https://www.flickr.com/photos/99093593@N07/37105032192/in/album-72157686733328033/&#34; title=&#34;IMG_6352&#34;&gt;&lt;img src=&#34;https://farm5.staticflickr.com/4400/37105032192_caa9b33971_c.jpg&#34; width=&#34;800&#34; height=&#34;534&#34; alt=&#34;IMG_6352&#34;&gt;&lt;/a&gt;&lt;script async src=&#34;//embedr.flickr.com/assets/client-code.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
    &lt;/div&gt;
Lâu rồi không đi đó lại nên lúc leo lên mệt đến đứt hơi. Tuy nhiên góc nhìn ở lại thật độc nhất, từ đây ta có thể nhìn ra phía cảng, một hướng khác có thể nhìn phía trung tâm. Đi một đoạn là tới Henderson Waves là một cây cầu gỗ với kiến trúc uốn lượn. Mình nghĩ đúng là khu này khi lên đèn hẳn là sẽ rất đẹp.
    &lt;div&gt;
    &lt;a data-flickr-embed=&#34;true&#34; data-header=&#34;true&#34; data-footer=&#34;true&#34; href=&#34;https://www.flickr.com/photos/99093593@N07/37134741271/in/album-72157686733328033/&#34; title=&#34;IMG_6354&#34;&gt;&lt;img src=&#34;https://farm5.staticflickr.com/4372/37134741271_95c849d899_c.jpg&#34; width=&#34;800&#34; height=&#34;534&#34; alt=&#34;IMG_6354&#34;&gt;&lt;/a&gt;&lt;script async src=&#34;//embedr.flickr.com/assets/client-code.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
    &lt;/div&gt;
Sau khi đi mỏi giò, cả bọn quyết định ghé một nơi tên là Haw Par Villa, ở khá gần NUS. Để đi tới đây thì chỉ cần lên line màu vàng ở MRT, ở đó có luôn một trạm tên là Haw Par Villa. Nơi đây là một công viên với kiến trúc cổ ở trên đường Pasir Panjang với gần 1000 bức tượng và tranh vẽ. Chủ đề chính là câu chuyện văn hóa xã hội Trung Quốc, nhưng thực ra cái chính là nói về các &lt;a href=&#34;http://tinhhoa.net/nhung-hinh-phat-rung-ron-o-18-tang-dia-nguc.html&#34; target=&#34;_blank&#34;&gt; tầng điện ngục&lt;/a&gt; theo quan điểm của người Trung Quốc.
    &lt;div&gt;
    &lt;a data-flickr-embed=&#34;true&#34; data-header=&#34;true&#34; data-footer=&#34;true&#34; href=&#34;https://www.flickr.com/photos/99093593@N07/36439726764/in/album-72157686733328033/&#34; title=&#34;IMG_6366&#34;&gt;&lt;img src=&#34;https://farm5.staticflickr.com/4376/36439726764_9fdb07e66f_c.jpg&#34; width=&#34;800&#34; height=&#34;534&#34; alt=&#34;IMG_6366&#34;&gt;&lt;/a&gt;&lt;script async src=&#34;//embedr.flickr.com/assets/client-code.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
    &lt;/div&gt;
Điểm thú vị ở đây là những người dựng lên công viên này chính là &lt;a href=&#34;https://en.wikipedia.org/wiki/Haw_Par_Villa#History&#34; target=&#34;_blank&#34;&gt;cha đẻ của dầu cao hổ &lt;/a&gt; . Lúc đầu mình cũng hơi nghi nghi, vì lâu lâu lại thấy mây cái tượng xung quanh với 1 khối hình rất giống mấy chai cao hổ, khi đi về google thì đúng ra là vậy. Xem ra cái công viên này cũng gần 100 năm rồi. Các tượng ở đây có style khá là lạ và hơi dị, nhưng mình nghĩ nó xuất phát từ sự lai giữa phong cách Trung Quốc và các nước lân cận.&lt;/p&gt;

&lt;p&gt;Sau khi bị nhầm tùng phèo bởi các trạm Bus để đến SMU, mà thực ra chỉ cần đi tàu đến quán &amp;ldquo;Kim Korean BBQ&amp;rdquo;, quán buffet thịt nướng khá ngon với giá tương đối ổn (29 SGD với người lớn, sinh viên có giảm giá). Phải nói là lần đầu tiên được đi ăn buffet nướng ở Sin sau gần 2 năm làm ở đây. Ngẫm lại mới thấy trải nghiệm ở Sin của mình ít thật. Hy vọng có nhiều dịp được đi nữa.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bài toán chuyển ngày sang thứ</title>
      <link>http://dangkhoasdc.github.io/post/sakamoto_method/</link>
      <pubDate>Sat, 16 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/sakamoto_method/</guid>
      <description>

&lt;p&gt;Đôi khi có những thuật toán chỉ khiến bạn thốt lên: &amp;ldquo;xuất sắc, thông minh vãi cả đxx&amp;rdquo;
Bài toán: Cho ngày, tháng, năm bất kì theo lịch Gregorian (lịch hiện nay), cho biết hôm đó rơi vào thứ mấy, tương ứng 0 -&amp;gt; Chủ Nhật, 1 -&amp;gt; Thứ Hai &amp;hellip;
Tôi đang muốn nói tới phương pháp của Sakamoto được đề xuất năm 1992. (Code theo chuẩn K&amp;amp;R C).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;dayofweek(y, m, d) {
    static int t[] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};
    y -= m &amp;lt; 3;
    return (y + y/4 - y/100 + y/400 + t[m-1] + d) % 7;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quá đơn giản, quá thông minh. Nhưng hiểu được 3 dòng code này ta mới cảm nhận được tác giả &amp;ldquo;ranh&amp;rdquo; đến mức nào. Giả sử gọi ngày 1 tháng 1 trong 1 năm bất kì làm mốc, để biết được ngày 1 tháng tiếp theo rơi vào đâu, ta có 31 = 7*4+3. Tức là ngày 1 tháng 2 rơi sau 3 ngày so với &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1&lt;/sub&gt; (Nếu ngày &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1&lt;/sub&gt; là thứ Hai thì &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; sẽ là thứ 5). &lt;code&gt;t[]&lt;/code&gt; chính là offset cho ngày đầu tiên của tháng so với ngày &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1&lt;/sub&gt;, như vậy ta có &lt;code&gt;t[] = {0, 3, 3, 6, 1, 4, 6, 2, 5, 0, 3, 5}&lt;/code&gt; (Hơi khác so với code). Chuyện tiếp theo là cộng offset đó với ngày (d-1) - khoảng cách từ ngày muốn tính đến đầu tháng , xong module cho 7 là ra được.&lt;/p&gt;

&lt;p&gt;Tuy nhiên đây mới là trong 1 năm. Bởi vì 1 năm (ko nhuận) có 365 = 52*7+1. Tức là cứ mỗi năm trôi qua là có thêm 1 ngày dôi ra, vậy ta có năm &lt;code&gt;y&lt;/code&gt;, ta phải cộng thêm &lt;code&gt;y&lt;/code&gt; ngày dôi ra đó. Nhưng đây mới là tính những năm không nhuận.&lt;/p&gt;

&lt;p&gt;Những năm nhuận, ta lại phải thêm cái ngày &lt;sup&gt;29&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; vào trong, tức là nó sẽ thêm 1 ngày nữa, trong &lt;code&gt;y&lt;/code&gt; năm? nếu có &lt;code&gt;y&lt;/code&gt; năm nhuận thì sẽ có thêm &lt;code&gt;x&lt;/code&gt; ngày được dồn vậy, $x = y/4 - y/100 + y/400$ (công thức tuy nhìn giống Inclusion-Exclusion Principle nhưng rốt cuộc ứ phải). Đơn giản là: những năm nhuận là năm (1) chia hết cho 4 nhưng không chia hết cho 100 hoặc (2) chia hết cho 400.&lt;/p&gt;

&lt;p&gt;Nhưng vẫn còn vấn đề, cái ngày thêm vào của năm nhuận là ngày &lt;sup&gt;29&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;, tức là nếu năm đó là năm nhuận nhưng ngày và tháng thuộc tháng 1 hoặc 2 thì ta không được tính vào (ví dụ 10/1/2016). Tác giả giải quyết siêu đơn giản : &lt;code&gt;y -= m &amp;lt; 3&lt;/code&gt;. Cứ hễ input tháng 1, 2 thì đẩy về năm trước đó. Và lúc đó thì năm nhuận sẽ hết nhuận.&lt;/p&gt;

&lt;p&gt;Nhưng vẫn còn vấn đề, rốt cuộc toán tử đó áp dụng cho cả những năm không nhuận. Tức tháng 1, 2 năm nào cũng bị đẩy về trước đó 1 năm. Lúc này mảng &lt;code&gt;t[]&lt;/code&gt; lại được dùng bằng cách bù cho tháng 1, 2, ta cộng 1 vào &lt;code&gt;t[0]&lt;/code&gt; và &lt;code&gt;t[1]&lt;/code&gt; và giữ nguyên các &lt;code&gt;t[]&lt;/code&gt; còn lại Sau đó chuyển -1 trong &lt;code&gt;d-1&lt;/code&gt; vào offset, lúc đó ta sẽ được mảng &lt;code&gt;t[]&lt;/code&gt; như trong code gốc.&lt;/p&gt;

&lt;p&gt;Ta còn một vấn đề là xác định ngày ban đầu để làm mốc và độ lệch &lt;code&gt;c&lt;/code&gt; của ngày gốc đó so với ngày Chủ Nhật với &lt;code&gt;index = 0&lt;/code&gt;. Nhưng bằng kiểm chứng, người ta phát hiện ra &lt;code&gt;c = 0&lt;/code&gt;. Wow. 😲&lt;/p&gt;

&lt;p&gt;Một thuật toán hay và đẹp, không chỉ tận dụng khả năng của ngôn ngữ lập trình, mà mỗi câu lệnh thể hiện được sự thông minh và khéo léo của tác giả.&lt;/p&gt;

&lt;p&gt;Bonus Problem: Chứng minh tính đúng của thuật toán bằng quy nạp.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Determination_of_the_day_of_the_week&#34; target=&#34;_blank&#34;&gt;Wiki: Determination of the day of the week&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://groups.google.com/forum/#!msg/comp.lang.c/GPA5wwrVnVw/hi2wB0TXGkAJ&#34; target=&#34;_blank&#34;&gt;Source&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Hậu Tây Du Kí</title>
      <link>http://dangkhoasdc.github.io/post/hau_tay_du_ky/</link>
      <pubDate>Sat, 16 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/hau_tay_du_ky/</guid>
      <description>&lt;p&gt;Ngày xưa mình mê coi phim này cực kì. Cứ mỗi lần đài lên sóng là rống họng lên hát: &amp;ldquo;quoài oa xinh xiên&amp;rdquo;. Đoạn nhạc phim mở đầu phải nói rất ấn tượng và mình nhớ mãi đến bây giờ. Hôm nay tình cờ được nghe bản lời Việt của 1 bài trong Hậu Tây Du Kí từ chế Bích Phương, tuổi thơ bỗng nhiên trào về.&lt;/p&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/bkrhB-KyC6s&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34; title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;p&gt;Mới nghe là mình đã biết ngay rằng đây là bài nhạc phim bất hủ hôm nào. Thế là hứng chí lên tìm bản mở đầu, cái bản &amp;ldquo;quoài oa xinh xiên&amp;rdquo; đó&lt;/p&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/WujVQocNprY&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34; title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;p&gt;Lúc nhỏ coi phim này khá là vui. Chuyện đầu tiên là mấy viên xá lợi, mình thì cứ nghĩ là &amp;ldquo;xí lị&amp;rdquo;, hoặc &amp;ldquo;xá xị&amp;rdquo; gì đó. Phim này thì đánh đấm quá ảo, chưa kể là câu chuyện tam giới phức tạp hơn trong Tây Du Kí bản gốc. Mình vẫn còn nhớ có những chi tiết liên kết với phần trước như vụ &amp;ldquo;Tôn Hành Giả - Giả Hành Tôn&amp;rdquo;, &amp;ldquo;Vô Thiên&amp;rdquo;, rồi cả chuyện hồi sinh của Phật Tổ, các yếu tố thần thoại và fantasy được đề cập nhiều hơn. Mặc dù tạo hình không thân quen như trước nhưng cũng rất đáng xem nếu xét những phim ra sau bộ kinh điển 1986.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Good Will Hunting và những bài toán đồ thị </title>
      <link>http://dangkhoasdc.github.io/post/review_good_will_hunting/</link>
      <pubDate>Sun, 10 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/review_good_will_hunting/</guid>
      <description>&lt;p&gt;Lâu lắm rồi tôi mới được xem một bộ phim hay đến vậy, có lẽ từ khi xem La La Land, đó là những bộ phim buộc bạn phải ngẩn ngơ một lồi lâu và không ngừng suy nghĩ về nhân vật và những lời thoại. Không có những kĩ xảo tráng lệ hay cốt truyện hại não, bộ phim đơn giản chỉ là câu chuyện của một thanh niên với bộ óc thiên tài trải nghiệm những thay đổi trong cuộc đời. Điều hại não nhất chăng chính là những bài toán được đề cập trong bộ phim, một phần làm tôi rất thích thú.&lt;/p&gt;

&lt;p&gt;Có lẽ nhiều người sẽ quan tâm nhiều hơn về những biến đổi của nhân vật Will, còn với tôi, tôi lại thích hình tượng hai giáo sư Sean và Lambeau. Cả hai là sự nhân cách hóa lựa chọn của Will. Khi cả hai giáo sư nói chuyện với nhau, mà đa phần cãi nhau vì bất đồng quan điểm, những gì thảo luận cho thấy họ từng là những gã thiên tài với đam mê toán học, nhưng Lambeau trở thành một “mathematical god” - với giải Field danh giá, còn Sean thì chọn một hướng đi hoàn toàn khác. Cả hai đều dù trái ngược nhau nhưng lại là phần bù của nhau. Hình ảnh hai người, và cả Will khiến tôi ám ảnh. Một phần trong con người tôi giống Lambeau: Lambeau ám ảnh bởi sự thành công, ám ảnh bởi Field danh giá, ám ảnh bởi vinh quang trong nghiên cứu. Tôi từng, và có lẽ cũng đang có những suy nghĩ tương tự, nỗi ám ảnh phải làm mọi thứ để trở thành “expert” trong lĩnh vực mình làm và lúc nào cũng ép bản thân tới hạn của công việc, như cách mà Lambeau nói về chính mình:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I am what I am today because I was pushed and because I learned to push myself&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Nhưng ấn tượng hơn cả là Sean, Sean đã đưa tôi một bài học khi nói: “There&amp;rsquo;s more to life
than a fuckin&amp;rsquo; Field&amp;rsquo;s medal.” Chính Lambeau thừa nhận Sean thông minh hơn ông, chính Lambeau cũng thừa nhận Sean từng có thể có Field, nhưng ông đã không làm, ông đã không hối hận về quyết định của mình.&lt;/p&gt;

&lt;p&gt;Bộ phim có rất nhiều đoạn hội thoại rất ý nghĩa, nhưng có lẽ đoạn hay nhất là khi Sean nói chuyện với Will, về sự khác nhau giữa kiến thức và sự thông thái: bạn có thể có được kiến thức bằng cách đọc rất nhiều sách và sở hữu một bộ óc của thiên tài; nhưng bạn không có được sự thông thái nếu không thực sự cảm nhận.&lt;/p&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/qM-gZintWDc&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34; title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;p&gt;Điều đặc biệt ấn tượng với tôi là khi Sean liên tục hỏi Will: “What do you wanna do?” được lặp đi lặp lại, như sự ẩn dụ của bộ phim dành cho người xem, đó chính là câu hỏi dành cho người xem. Đoạn cãi nhau của Sean và Lambeau và chính câu hỏi : “What do you wanna do?” khiến tôi luôn bần thần sau bộ phim, rốt cuộc, điều gì là điều tôi thực sự muốn làm?&lt;/p&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/zKQBHkzOYvw&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34; title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;p&gt;Mỗi phân cảnh trong phim có lẽ là một câu chuyện đầy ý nghĩa về cuộc sống. Và những đoạn hội thoại ấy sẽ còn lưu lại trong tâm trí người xem thời gian dài.&lt;/p&gt;

&lt;p&gt;Một bộ phim quá hay, và thật không ngờ là Matt Demon và Ben Affleck viết kịch bản xuất sắc đến vậy, đồng thời diễn xuất của các diễn viên hết sức thuyết phục. Từ bối cảnh, kịch bản, biên kịch, tất cả tạo nên một bộ phim giàu tính nghệ thuật và ý nghĩa, đó cũng chính là lí do mà bộ phim có 9 đề cừ Oscar và giành được tượng vàng cho hạng mục Nam Diễn Viên Phụ Xuất Sắc (Robin William) và Kịch Bản Gốc Hay Nhất (Matt và Ben).&lt;/p&gt;

&lt;p&gt;Về những câu hỏi toán trong bộ phim, điều thú vị là Lambeau đạt giải Field trong toán tổ hợp, và đó là lí do mà mấy câu hỏi thách thức để tìm ra thiên tài toán học mới đều liên quan đến mảng này. Các câu hỏi khá hay về đồ thị: từ ma trận cạnh kề và tính chất của nó, từ hàm sinh đến phương pháp đếm đến bài toán tô màu đồ thị. Câu chuyện về các nhà toán học được đề cập trong phim cũng rất thú vị: Ranamujan (có lẽ cuộc đời và trí tuệ của ông thú vị đến nỗi tôi thường xuyên thấy bóng dáng của ông trong các lĩnh vực mình tìm hiểu: trong Hỗn Độn và Hài Hòa của gs. Trịnh Xuân Thuận, trong Volume 1 của The art of computer programming đến bộ phim The Man Who Knew Infinity trên chuyến bay đi Hawaii), Ted Kaczynki: một giáo sư toán học Berkeley, đồng thời cũng là một tên khủng bố. Có lẽ cần đến một post hàng toàn khác để có thể nói về lịch sử thú vị của những bài toán trong phim này.&lt;/p&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/N7b0cLn-wHU&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34; title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>La La Land</title>
      <link>http://dangkhoasdc.github.io/post/la_la_land/</link>
      <pubDate>Sun, 10 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/la_la_land/</guid>
      <description>&lt;p&gt;Tuổi trẻ, tình yêu và khát vọng. Đó là La La Land. Một tựa phim đầy mơ hồ. Nhưng không phải, có lẽ âm &amp;ldquo;La La Land&amp;rdquo; vang lên như một thứ âm nhạc của tuổi trẻ, vượt qua những rào cản của ngôn ngữ, đó là chốn thiên đường mà những kẻ khao khát từng chìm đắm và mơ mộng.&lt;/p&gt;

&lt;p&gt;Xem La La Land tôi nhớ đến &lt;a href=&#34;http://www.imdb.com/title/tt0947798/?ref_=nv_sr_1&#34; target=&#34;_blank&#34;&gt;Black Swan&lt;/a&gt; và &lt;a href=&#34;http://www.imdb.com/title/tt0947798/?ref_=nv_sr_1&#34; target=&#34;_blank&#34;&gt;Whiplash&lt;/a&gt;, cũng là câu chuyện về những người trẻ với khát vọng và niềm đam mê của mình.&lt;/p&gt;

&lt;p&gt;Black Swan nói về đam mê đến ám ảnh, đến những vũ điệu balê và tác phẩm Hồ Thiên Nga nổi tiếng. Đó là câu chuyện về nghệ thuật, về bản ngã và cái giá của nghệ thuật. Cô gái (Nina - Natalie Portman) trong phim ám ảnh vai diễn đến nỗi trong tưởng tượng đã giết chết bạn diễn của mình, thoát khỏi vỏ bọc bé bỏng mỏng manh của thiên nga trắng đến hoàn toàn hóa thân thành Thiên Nga Đen với sự lôi cuốn và khao khát mãnh liệt. Nina Thoát khỏi giới hạn và khuôn khổ của bản thân để đạt đến sự hoàn hảo.&lt;/p&gt;

&lt;p&gt;Whiplash lại là câu chuyện về chàng trai Andrew đam mê chơi trống. Giống Black Swan, chàng trai khi muốn vượt đến một tầm cao mới phải trả giá bằng tổn thương cả thể xác và tinh thần và cố gắng thoát khỏi vùng an toàn của chính bản thân. Tôi nghĩ hai bộ phim trên bao giờ cũng mang lại động lực cho người trẻ tìm đến sự toàn mỹ, cái đích đến của một tài năng được công nhận không bao giờ là dễ dàng.&lt;/p&gt;

&lt;p&gt;La La Land chính là thành quả của tuổi trẻ và đam mê của &lt;a href=&#34;https://en.wikipedia.org/wiki/Damien_Chazelle&#34; target=&#34;_blank&#34;&gt;Damien Chazelle&lt;/a&gt;.
La La Land là jazz, La La Land là sự tri ân của chàng sinh viên Harvard với khát vọng điện ảnh đã viết nên trong suốt thời gian ở trường. Đó là câu chuyện của chính chàng trai, gói gém trong những bản nhạc jazz trữ tình, kể về thổn thức của tuổi trẻ của anh.&lt;/p&gt;

&lt;p&gt;Đó cũng là thổn thức của những người trẻ.&lt;/p&gt;

&lt;p&gt;Jazz là phương tiện để chàng mang đến nỗi khắc khoải về tuổi trẻ. Như chính nhân vật Sebastian trong phim khi kể về nguồn gốc của jazz, jazz là sự tương tác của những con người ở các tầng lớp với nhau với ngôn ngữ khác biệt, họ có câu chuyện của riêng họ. Chính sự tương tác của những cảnh đời vậy tạo nên jazz. Còn phương tiện nào tuyệt hơn để nhà biên kịch truyền tải về tuổi trẻ của mình.&lt;/p&gt;

&lt;p&gt;La La Land rất đẹp, đẹp từ dựng hình, từ âm thanh đến trang phục. Đó cũng chính là con mắt của người trẻ với cuộc đời, đầy ước mơ. Và đó chính là những gì đẹp đẽ nhất mà tuổi trẻ mong có được. Rất khó để diễn tả gam màu chủ đạo của bộ phim. Rực rỡ, tươi tắn. Jazz. Hollywood. Bồng bột và nhiệt huyết. Ồ, đó là màu sắc của điện ảnh.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://cdn.empireonline.com/jpg/80/0/0/1000/563/0/north/0/0/0/0/0/t/films/313369/images/nadTlnTE6DdgmYsN4iWc2a2wiaI.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Với tôi La La Land không phải là cả bộ phim, La La Land thực sự chính là trường đoạn kết thúc phim. Mọi thứ đều đẹp, mọi giấc mơ đều chạm tới, và hạnh phúc tràn ngập. Tất cả cuộn trong chất nhạc, gam màu sắc tươi tắng và lãng mạn. Và đúng như những gì dự tính, La La Land được miêu tả bằng jazz, bằng hình ảnh và tuyệt nhiên không một lời thoại. Bởi trong giấc mơ nào, đó là lời tự tình của đạo diễn, của người xem với chính họ. Đạo diễn đưa bàn tay đễn dẫn lối người xem đến La La Land của riêng họ.&lt;/p&gt;

&lt;p&gt;Nhưng cái tài của đạo diễn chính là khiến người xem thổn thức với La La Land, họ cay đắng nhận ra, rốt cuộc, tên tác giả láo cá  đã kể 1 câu chuyện khác suốt hai tiếng đồng hồ. Ở đó nhân vật của chúng ta luôn hoài nghi về năng lực của mình, và họ buộc phải làm những việc họ không muốn làm, phải chọn con đường thực tâm không muốn đi. Tôi rất thích hai nhân vật chính, hoàn cảnh của họ, động lực của họ phần nào giống bản thân tôi: lạc lõng giữa những quyết định, với mục tiêu và hoài bão của bản thân. Đó là lí do tôi không chê trách gì quyết định của Mia lẫn Sebastian, tấm vé đến La La Land không dành cho mọi người. Vé đôi lại càng kham hiếm.&lt;/p&gt;

&lt;p&gt;Giấc mơ tuyệt mỹ năm nào dần dần rời xa như cái ánh sáng xanh phía bên kia hồ dần rời xa Gatsby.  Phải chăng, tất cả cũng đều là giấc mơ. Gatsby chạy theo giấc mơ về sự vương giả và tình yêu, mà không gì khác là hình tượng của giấc mơ Mỹ. Mia và Sebastian cũng đuổi bám theo giấc mơ nghệ thuật riêng mình, chính là hình tượng của kinh đô Hollywood mà Sebastian nói:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;L.A. worships everything and values nothing&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Để rồi đọng lại, La La Land tuy rất đẹp, nhưng rất buồn. Bởi vùng đất ấy mãi mãi chỉ nằm trong hồi ức một thời xa lắm.&lt;/p&gt;

&lt;p&gt;Có lẽ tôi không nói nhiều về sự thành công của phim. 11 đề cử giải Oscar và 5 giải thưởng được trao đã nói lên điều đó. Nhưng điều tôi đặc biệt thích, đó có lẽ là âm nhạc và hình ảnh. Hơn hết hai yếu tố trên đã trở thành một người kể chuyện trong phim. Và sự kiện trao nhầm giải ở Oscar có lẽ cũng là điều thú vị cho bộ phim. Dù rằng tình huống này thạt oái ăm cho cả đoàn phim của La La Land lẫn Moonlight.&lt;/p&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/rvK-g1rehpU&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34; title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;p&gt;Honest Trailer có một video xuất sắc về vụ này :lol:&lt;/p&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/C39YJymGp3Q&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34; title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>rand() is harmful</title>
      <link>http://dangkhoasdc.github.io/post/rand/</link>
      <pubDate>Wed, 06 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/rand/</guid>
      <description>

&lt;h1 id=&#34;rand&#34;&gt;rand()&lt;/h1&gt;

&lt;p&gt;Bài talk khá hay về việc sinh số ngẫu nhiên (trong trường hợp này là ngôn ngữ C++). Làm mình nhớ đến 1 bài tập trong The Art of Computer Programming (TAOCP - Vol 2): &amp;ldquo;hãy thử thay đổi random generator trong máy tính bằng một thuật toán tốt hơn, và quan sát điều kì diệu sẽ xảy ra&amp;rdquo;
Bài talk duy chỉ nói về việc dùng hàm &lt;code&gt;rand()&lt;/code&gt; và đặc biệt sử dụng chung với &lt;code&gt;%&lt;/code&gt; (mod) hay floating point scale là thực sự &lt;em&gt;sai lầm&lt;/em&gt;  và &lt;em&gt;nghiêm trọng&lt;/em&gt; . Đặc biệt, nó không hề tạo ra uniform distribution như ta thường nghĩ, thậm chí nó khiến cho 1 số giá trị đặc biệt hiếm khi xảy ra 😄&lt;/p&gt;

&lt;p&gt;Bản chất hàm &lt;code&gt;rand&lt;/code&gt; được implement khá đơn giản &lt;a href=&#34;https://en.wikipedia.org/wiki/Linear_congruential_generator&#34; target=&#34;_blank&#34;&gt; linear congruential &lt;/a&gt; nhờ tận dụng tính chất của số căn nguyên thủy (xem &lt;a href=&#34;https://en.wikipedia.org/wiki/Lehmer_random_number_generator&#34; target=&#34;_blank&#34;&gt;Lehmer random generator&lt;/a&gt;). Điều thú vị nằm ở chỗ 1 tính chất không liên quan mấy bên lý thuyết số lại hỗ trợ cho việc sinh số ngẫu nhiên.
Btw, TAOCP Vol 2 nói khá kĩ về vấn đề này. Một kỹ thuật để check xem empirical results có đúng với probabilities không (uniform distribution với biến ngẫu nhiên rời rạc), đó là dùng Chi squared test.&lt;/p&gt;

&lt;p&gt;Link:
&lt;a href=&#34;https://channel9.msdn.com/Events/GoingNative/2013/rand-Considered-Harmful&#34; target=&#34;_blank&#34;&gt;https://channel9.msdn.com/Events/GoingNative/2013/rand-Considered-Harmful&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Các thuật toán ngẫu nhiên</title>
      <link>http://dangkhoasdc.github.io/post/randalgs_ex/</link>
      <pubDate>Sun, 23 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/randalgs_ex/</guid>
      <description>

&lt;h1 id=&#34;các-ví-dụ-về-thuật-toán-ngẫu-nhiên&#34;&gt;Các ví dụ về thuật toán ngẫu nhiên&lt;/h1&gt;

&lt;p&gt;Tiếp tục seri về thuật toán ngẫu nhiên, trong bài viết này mình ghi lại 3 ví dụ điển hình trong họ bài toán này. Tất cả các ví dụ đều nằm trong cuốn sách &lt;a href=&#34;https://www.amazon.com/Randomized-Algorithms-Rajeev-Motwani/dp/0521474655&#34; target=&#34;_blank&#34;&gt;Randomized Algorithms&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;randomized-quicksort&#34;&gt;Randomized Quicksort&lt;/h1&gt;

&lt;p&gt;Thuật toán quicksort có lẽ là một trong những thuật toán khá dễ hiểu khi tìm hiểu về các thuật toán ngẫu nhiên. Thử tưởng tượng ta cho quicksort thông thường chạy 10 lần với dữ liệu đã sắp xếp với randomized-quicksort cũng với cấu hình như vậy, ta sẽ thấy sự khác biệt lớn.&lt;/p&gt;

&lt;h2 id=&#34;thuật-toán&#34;&gt;Thuật toán&lt;/h2&gt;

&lt;h2 id=&#34;chứng-minh&#34;&gt;Chứng minh&lt;/h2&gt;

&lt;p&gt;Cho dữ liệu đầu vào gồm $n$ phần tử khác nhau. Gọi $S_i, 1 \leq i \leq n$ là phần tử &lt;em&gt;rank i&lt;/em&gt; (phần tử nhỏ thứ &lt;em&gt;i&lt;/em&gt;) trong mảng, đồng thời ta có $X_{ij}$ biến ngẫu nhiên bằng 1 nếu xuất hiện phép so sánh của 2 phần tử $S_i$ và $S_j$ trong quá trình thực thi, bằng không nếu không xuất hiện phép so sánh nào.&lt;/p&gt;

&lt;p&gt;Như vậy, độ phức tạp của &lt;code&gt;randomized-quicksort&lt;/code&gt; được tính thông qua quá trình sắp xếp mảng theo pivot mà chi phí chính nằm ở phép so sánh các phần tử, tổng chi phí chính là&lt;/p&gt;

&lt;p&gt;$$ \sum_{i=1}^n \sum_{j&amp;gt;i} X_{ij} $$&lt;/p&gt;

&lt;p&gt;Tuy nhiên, điều ta quan tâm hơn ở đây là &lt;em&gt;kì vọng&lt;/em&gt; chi phí trong các lần thực thi:&lt;/p&gt;

&lt;p&gt;$$E \left [ \sum_{i=1}^n \sum_{j&amp;gt;i} X_{ij} \right ] = \sum_{i=1}^n \sum_{j&amp;gt;i} E[X_{ij}]$$&lt;/p&gt;

&lt;p&gt;Công thức trên được xây dựng dựa vào một tính chất của kì vọng: &lt;a href=&#34;https://brilliant.org/wiki/linearity-of-expectation/&#34; target=&#34;_blank&#34;&gt;tính tuyến tính của kì vọng&lt;/a&gt;. Như vậy kì vọng của tổng các chi phí so sánh chính bằng tổng của từng kì vọng của biến ngẫu nhiên $ X_{ij}$. Gọi $p_{ij}$ là xác suất để $X_{ij}=1$. Ta có:&lt;/p&gt;

&lt;p&gt;$$ E[X_{ij}] = p_{ij} * 1 + (1-p) * 0 = p_{ij} $$
$$ E \left [ \sum_{i=1}^n \sum_{j&amp;gt;i} X_{ij} \right ] = \sum_{i=1}^n \sum_{j&amp;gt;i} p_{ij} $$&lt;/p&gt;

&lt;p&gt;Bài toán được qui về việc tính xác suất khi nào phép so sánh giữa hai phần tử $S_i$ và $S_j$ xuất hiện.&lt;/p&gt;

&lt;p&gt;Nếu ta xem quá trình thực thi của &lt;code&gt;randomized-quicksort&lt;/code&gt; là quá trình xây dựng cây nhị phân: với mỗi node chính là 1 pivot tại thời điểm gọi hàm &lt;code&gt;partition&lt;/code&gt;, kết quả hàm &lt;code&gt;partition&lt;/code&gt; ta có được 2 cây con bên trái và phải của node pivot dùng để so sánh. Nếu $S_i$ và $S_j$ nằm ở hai nhánh con trái-phải thì phép so sánh giữa hai phần tử này chắc chắn không xảy ra. Như vậy $S_i$ và $S_j$ có quan hệ cha con - một trong hai phần tử phải thuộc node cấp lớn hơn của node kia. Một giả thuyết khác cần xem xét đó là xác suất các số được chọn làm pivot phải bằng nhau (uniform distribution) - có được giả thuyết này ta mới tính được độ phức tạp trong thời gian trung bình được.&lt;/p&gt;

&lt;p&gt;Như vậy, để $X_{ij}=1$ khi và chỉ khi một trong hay vị trí $S_i$ hoặc $S_j$ được chọn, và đó là $p_{ij} = \frac{2}{j - i + 1} $ (Xác suất này được tính khi loại đi xác suất chọn phải những pivot nằm bên trái của $S_i$ hoặc nằm bên phải của $S_j$)&lt;/p&gt;

&lt;p&gt;Như vậy ta có:&lt;/p&gt;

&lt;p&gt;$$E \left [ \sum_{i=1}^n \sum_{j&amp;gt;i} X_{ij} \right ] = \sum_{i=1}^n \sum_{j&amp;gt;i} \frac{2}{j - i + 1}$$&lt;/p&gt;

&lt;p&gt;Đặt $k = j - i + 1$, ta được:&lt;/p&gt;

&lt;p&gt;$$\sum_{i=1}^n \sum_{j&amp;gt;i} p_{ij} \leq \sum_{i=1}^n \sum_{k=1}^{n-i+1} \frac{1}{k}$$&lt;/p&gt;

&lt;p&gt;$$\leq 2 \sum_{i=1}^n \sum_{k=1}^{n} \frac{1}{k}$$&lt;/p&gt;

&lt;p&gt;$$= 2n \sum_{k=1}^{n} \frac{1}{k}$$&lt;/p&gt;

&lt;p&gt;$\sum_{k=1}^{n} \frac{1}{k}$ chính là &lt;a href=&#34;https://en.wikipedia.org/wiki/Harmonic_series_(mathematics)#Rate_of_divergence&#34; target=&#34;_blank&#34;&gt;chuỗi harmony&lt;/a&gt; và tổng này sẽ hội tụ về xấp xỉ của $ln(n)$. Và như vậy&lt;/p&gt;

&lt;p&gt;$$E \left [ \sum_{i=1}^n \sum_{j&amp;gt;i} X_{ij} \right ] \leq 2n\log{n}$$&lt;/p&gt;

&lt;h1 id=&#34;random-mincut&#34;&gt;Random Mincut&lt;/h1&gt;

&lt;h2 id=&#34;ví-dụ&#34;&gt;Ví dụ&lt;/h2&gt;

&lt;p&gt;Giả sử ta có dữ liệu facebook của đám bạn cấp 3 và đang tò mò xem trong chục năm qua, những đứa bạn đó có lập thành nhóm chơi thân nào không. Dữ liệu đầu vào là danh sách các bạn trong lớp cấp 3 và mỗi quan hệ từng người với nhau (quan hệ bạn cấp 3, bạn đại học, đồng nghiệp, quan hệ nam nữ, vợ chồng).&lt;/p&gt;

&lt;p&gt;Giả sử ta tạo một đồ thị với đỉnh là một người trong lớp, &lt;code&gt;a&lt;/code&gt; có thể nối với &lt;code&gt;b&lt;/code&gt; thông qua các cạnh nối:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Bạn cấp 3 (cái này chắc chắn)&lt;/li&gt;
&lt;li&gt;Bạn đại học&lt;/li&gt;
&lt;li&gt;Đồng nghiệp&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Việc tìm ra nhóm bạn &lt;em&gt;thân&lt;/em&gt; - tức gắng bó với nhau sau thời gian cấp 3 chính là việc tìm cách tách đồ thị lớn này thành những đồ thị con.&lt;/p&gt;

&lt;p&gt;Những bài toán &lt;em&gt;chia cắt&lt;/em&gt; đồ thị gọi là &lt;em&gt;graph cut&lt;/em&gt;, nếu trong bài toán yêu cầu tìm ra đoạn cắt nào có chi phí thấp nhất: cắt ít số cạnh nhất - thì đó chính là bài toán tìm &lt;em&gt;mincut&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Trong ví dụ này ta xét đồ thị là một &lt;a href=&#34;http://mathworld.wolfram.com/Multigraph.html&#34; target=&#34;_blank&#34;&gt;multigraph&lt;/a&gt; - tức đồ thị có thể có nhiều cạnh cùng nối chung hai điểm. Một số định nghĩa cho phép &lt;em&gt;multigraph&lt;/em&gt; là đồ thị có các cạnh lặp (self-loop). Để thuận tiện cho việc chứng minh và minh hoạ, các đồ thị được đề cập trong bài là các đồ thị vô hướng.&lt;/p&gt;

&lt;h2 id=&#34;karger-mincut-https-en-wikipedia-org-wiki-karger-27s-algorithm&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Karger%27s_algorithm&#34; target=&#34;_blank&#34;&gt;Karger Mincut&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/e/e7/Single_run_of_Karger%E2%80%99s_Mincut_algorithm.svg&#34; alt=&#34;Minh hoạ thuật toán Karger&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Một quá trình quan trọng trong thuật toán Karger là &lt;em&gt;Edge Contraction&lt;/em&gt; - gộp cạnh. Cho một cạnh $ e = {u, v}$, sau phép gộp cạnh ta sẽ có được một &lt;em&gt;đỉnh&lt;/em&gt; mới là $uv$ trong đó tất cả các cạnh nối từ $u$ đến $v$ hay ngược lại đều bị loại bỏ, đồng thời các cạnh lặp (self-loop) cũng bị xoá bỏ.&lt;/p&gt;

&lt;p&gt;Với các cạnh khác $ e’ = {u, w}$ hay $e’={v, w}$ đều trở thành $e’={uv,w}$.&lt;/p&gt;

&lt;p&gt;Một cách đơn giản: phép gộp cạnh sẽ nhập 2 đỉnh lại với nhau - xoá toàn bộ các cạnh nối 2 cạnh cũ và giữ lại những cạnh nối 2 đỉnh đó với các đỉnh khác trong đồ thị.&lt;/p&gt;

&lt;p&gt;Thuật toán được mô tả như sau:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. Chọn ngẫu nhiên (theo phân phối đều) một cạnh trong đồ thị.
2. Thực hiện phép gộp cạnh vừa chọn.
3. Lặp lại bước (1) cho đến khi số đỉnh trong đồ thị còn lại 2.
4. Output: min-cut là các cạnh còn lại trong đồ thị
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;tính-đúng-đắng-của-giải-thuật&#34;&gt;Tính đúng đắng của giải thuật&lt;/h2&gt;

&lt;p&gt;Để có thể tính được độ phức tạp trong thời gian trung bình, ta cần quay lại một chút về các tính chất của đồ thị. Cho đa đồ thị (multigraph) $G=(V, E)$ gồm các đỉnh $V$ và các cạnh $E$. Gọi $d(v)$ là bậc của đỉnh $v$ là tổng số các cạnh liên thuộc với $v$. Ta có tính chất sau:&lt;/p&gt;

&lt;p&gt;$$\sum_{v \in V} d(v) = 2 | E |$$&lt;/p&gt;

&lt;p&gt;Gọi $C$ là lát cắt có kích thước nhỏ nhất $k$ - tức số lượng các cạnh trong lát cắt đó là $k$. Do đó, bậc tối thiểu của mỗi cạnh trong đồ thị này là $k$. Bởi nếu tồn tại một đỉnh có bậc nhỏ hơn $k$ thì lắt cắt $k$ không phải là lát cắt nhỏ nhất.&lt;/p&gt;

&lt;p&gt;Như vậy ta có:&lt;/p&gt;

&lt;p&gt;$$nk \leq \sum_{v \in V} d(v) = 2 | E |$$
$$|E| \geq \frac{nk}{2}$$&lt;/p&gt;

&lt;p&gt;Ta thấy xác suất để thuật toán gộp cạnh chọn đúng ngay 1 cạnh trong C chính là&lt;/p&gt;

&lt;p&gt;$$\frac{k}{|E|}$$&lt;/p&gt;

&lt;p&gt;kết hợp với bất đẳng thức phía trên, ta được:&lt;/p&gt;

&lt;p&gt;$$\frac{k}{|E|} \leq \frac{2k}{nk} = \frac{2}{n}$$&lt;/p&gt;

&lt;p&gt;Như vậy, xác suất để thuật toán gộp cạnh không chọn phải các cạnh của $C$ là $p_n $.&lt;/p&gt;

&lt;p&gt;Ta có $p_n \leq (1-\frac{2}{n})p_{n-1} $ .&lt;/p&gt;

&lt;p&gt;Đồng thời ta cũng có $ p_2 = 1 $ lí do là bởi Karger chỉ chọn cạnh để gộp khi $ \vert V \vert &amp;gt; 2 $&lt;/p&gt;

&lt;p&gt;Nên khi $ n=2 $ thì biến cố chọn phải cạnh để gộp nằm trong $ C $ chắc chắn không xảy ra.&lt;/p&gt;

&lt;p&gt;Xác suất $p_n$ có cận như sau:&lt;/p&gt;

&lt;p&gt;$$p_n \geq \prod_{i=0}^{n-3} \left (1 - \frac{2}{n-i} \right ) = \frac{2}{n(n-1)}$$&lt;/p&gt;

&lt;p&gt;Để dễ tưởng tượng hơn, ta có thể phân tích một chút về trường hợp Karger không tìm ra được mincut, rõ ràng xác suất đó chính là $ 1 - \frac{2}{n(n-1)}$, để tăng độ chính xác, ta có thể cho Karger chạy $k$ lần. Lúc này, xác suất Karger không tìm ra được mincut là: $ \left (1 - \frac{2}{n(n-1)} \right )^k$. Có một bất đẳng thức thú vị ở đây:&lt;/p&gt;

&lt;p&gt;$$\frac{1}{4} \leq \left (1 - \frac{1}{x} \right )^ x \leq \frac{1}{e}$$&lt;/p&gt;

&lt;p&gt;Giả sử $k = \frac{n(n-1)}{2}\ln n$ ta có được kết quả khá đẹp như sau:&lt;/p&gt;

&lt;p&gt;$$\left (1 - \frac{2}{n(n-1)} \right )^{\frac{n(n-1)}{2}\ln n} \leq \left (\frac{1}{e} \right )^{\frac{n(n-1)}{2}\ln n} = \left (\frac{1}{e} \right ) ^{\ln n} = \frac{1}{n}$$&lt;/p&gt;

&lt;h1 id=&#34;binary-planar-partitions&#34;&gt;Binary Planar Partitions&lt;/h1&gt;

&lt;h2 id=&#34;giới-thiệu&#34;&gt;Giới thiệu&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/cGwRyxq.png&#34; alt=&#34;Một ví dụ về cây BSP&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Binary Planar Partitions (trong trường hợp tổng quát là &lt;em&gt;Binary Space Partitions&lt;/em&gt;) là một phương pháp phổ biến được sử dụng nhằm chia cắt không gian thành các tập lồi (convex set) chứa các siêu phẳng - hyperplane. Sự chia cắt này tạo nên một cấu trúc dữ liệu được gọi là cây BSP.&lt;/p&gt;

&lt;p&gt;BSP có nhiều ứng dụng, đặc biệt là trong các bài toán về đồ hoạ. Điển hình như trong bài toán dựng hình (xác định đối tượng nào được dựng trong khung hình từ góc một góc nhìn nào đó), trong hệ thống CAD, phát hiện va chạm trong robotics, cũng như trong các bài toán chứa các cấu trúc không gian phức tạp.&lt;/p&gt;

&lt;p&gt;Trong trường hợp tổng quát, cây BSP, từ mỗi node của mình sẽ chia không gian thành hai nửa siêu phẳng, từ mỗi nửa siêu phẳng đó sẽ tiếp tục được chia cắt thành các nửa siêu phẳng nhỏ hơn sao cho những node lá cuối cùng sẽ chứa 1 đối tượng mà thuộc không gian. Có thể thấy cây BSP là trường hợp tổng quát của cây &lt;a href=&#34;https://en.wikipedia.org/wiki/K-d_tree&#34; target=&#34;_blank&#34;&gt;k-d&lt;/a&gt;, và &lt;a href=&#34;https://en.wikipedia.org/wiki/Quadtree&#34; target=&#34;_blank&#34;&gt;Quadtree&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;ví-dụ-1&#34;&gt;Ví dụ&lt;/h2&gt;

&lt;p&gt;Để đơn giản bài toán ta xét trường hợp mặt phẳng với dữ liệu đầu vào là tập các đoạn thẳng sao cho từng cặp trong tập không giao nhau $S={s_1, s_2, \dots, s_n}$, output của bài toán là một cây BSP mà mỗi vùng trong mỗi node lá chỉ chứa 1 một đoạn thẳng.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Chọn ngẫu nhiên (theo phân phối đều) một hoán vị $\pi$ trong tập hoá vị của ${1, 2, \dots, n }$ (gồm $n!$ phần tử).&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tồn tại một vùng chứa nhiều hơn 1 đoạn thẳng:&lt;/p&gt;

&lt;p&gt;2.a Cắt vùng này bởi &lt;em&gt;đường thẳng&lt;/em&gt; $l(s_i)$ trong đó $i$ là phần tử đầu tiên trong hoán vị (ở đây đường thẳng $l$ sẽ chứa $s_i$) $\pi$ sao cho $s_i$ cắt vùng đang xét.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;phân-tích&#34;&gt;Phân tích&lt;/h2&gt;

&lt;p&gt;Gọi biến $X_{ij}$ là biến ngẫu nhiên và $X_{ij}=1$ khi đường thẳng chứa $s_i$ cắt $s_j$ trong một vòng gọi đệ quy nào đó, $X_{ij}=0$ trong trường hợp ngược lại.&lt;/p&gt;

&lt;p&gt;Ở đây ta muốn xét xem kì vọng số lần thuật toán này cắt phải một đoạn thẳng trong tập đầu vào $S$.&lt;/p&gt;

&lt;p&gt;$$\mathbf{E} (X) = \mathbf{E} \left [ \sum_{i=1}^{n} \sum_{i=1}^{n} X _ {ij} \right ]$$
$$= \sum_{i=1}^{n} \sum_{i=1}^{n} \mathbf{E} [X _ {ij} ]$$
$$= \sum_{i=1}^{n} \sum_{i=1}^{n} Pr [X _ {ij} = 1 ]$$&lt;/p&gt;

&lt;p&gt;Bài toán được quy về việc tính xác suất $Pr[X_{ij}=1]$. Gọi $t$ là giao điểm của $s_i$ và $s_j$, $index(i,j)=t$ nếu $s_i$ cắt $t-1$ đoạn thẳng trước khi giao với $s_j$, như ví dụ bên dưới $s_{ij}=4$. Trường hợp hai đoạn thẳng không cắt nhau thì $S_{ij}=\infty$.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/kyaZ5CL.png&#34; alt=&#34;Ví dụ về giá trị index(i, j)&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Bởi đường thẳng chứa $s_i$ bất kì có thể tiến vô cùng về hai phía nên tồn tại hai đoạn sao cho $index(s_i, s_j) = index(s_i, s_k)$. Nếu $index(s_i, s_j)=t$ ta gọi $s_{i1}, s_{i2}, \dots, s_{it}$ là những đoạn thẳng mà $s_i$ sẽ cắt trước khi giao với $s_j$, xác suất đề sự kiện này xảy ra là $\frac{1}{t+1}$&lt;/p&gt;

&lt;p&gt;Cho một đoạn $s_k$ cố định và $m \in {0, 1, 2, dots, n-2 }$ tồn tại tối đa hai đoạn thẳng $s_l$ sao cho $index(s_l, s_k)=m$&lt;/p&gt;

&lt;p&gt;Cận trên được tính như sau:&lt;/p&gt;

&lt;p&gt;$$\mathbf{E}[X] = \sum_{i=1}^{n} \sum_{j=1}^{n} Pr [X _ {ij} = 1 ]$$
$$\leq \sum_{i=1}^{n} \sum_{j=1}^{n} \frac{1}{index(i, j) + 1}$$
$$\sum_{i=1}^{n} \sum_{k=2}^{n} \frac{2}{k}$$
$$= 2n \ln n$$&lt;/p&gt;

&lt;h1 id=&#34;tài-liệu-tham-khảo&#34;&gt;Tài liệu tham khảo.&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.csee.wvu.edu/~ksmani/courses/fa01/random/lecnotes/lecture2.pdf&#34; target=&#34;_blank&#34;&gt;Introduction to Randomized Algorithms&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cs.au.dk/~gudmund/Documents/randompearlnotes.pdf&#34; target=&#34;_blank&#34;&gt;Randomised Algorithms&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Cảm nhận Star Wars VII: The Force Awakens</title>
      <link>http://dangkhoasdc.github.io/post/startwars-vii-review/</link>
      <pubDate>Sun, 23 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/startwars-vii-review/</guid>
      <description>&lt;p&gt;Từ nhỏ, tôi luôn thích những cuộc phiêu lưu và những câu chuyện giả tưởng. Từ cuộc phiêu lưu của Robinson đến con tàu chu du hai mươi ngàn dặm dưới đáy biển của Jules Verne hay cuộc chiến ngoài vũ trụ trong Starcraft. Star Wars cũng không phải là ngoại lệ, dĩ nhiên tôi không phải fan cuồng đến mức đọc từng trang wiki về từng nhân vật, thậm chí đến những nhân vật xuất hiện trong phim có vài giây cũng có hẳn &lt;a href=&#34;https://www.youtube.com/watch?v=bsb9ZTmbSKQ&amp;amp;feature=youtu.be&amp;amp;t=38s&#34; target=&#34;_blank&#34;&gt;trang wiki riêng cơ mà&lt;/a&gt;. Và dù biết đến Star Wars khá muộn màng vào những năm đại học, câu chuyện về cuộc chiến trong dải thiên hà xa xôi luôn khiến tôi thích thú.&lt;/p&gt;

&lt;p&gt;Hôm nay tôi dành ngày nghỉ lễ để xem &lt;em&gt;Star Wars VII: The Force Awakens&lt;/em&gt;. Cảm nhận của tôi không gì ngoài một từ: &lt;em&gt;xuất sắc&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/wiYUg5a.jpg&#34; alt=&#34;Người trong mộng trong các thế hệ fan Star Wars&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Trước khi vào rạp, tôi không mong nhân vật nữ mới sẽ mang đến cảm giác như &lt;a href=&#34;https://www.youtube.com/watch?v=KSYValHWNOs&#34; target=&#34;_blank&#34;&gt;công chúa Leia&lt;/a&gt; từng mang đến. Nàng mang một vẻ đẹp nhẹ nhàng với tính cách vừa là của một nàng công chúa kiêu kì vừa là một người tướng của quân Kháng Chiến. Ngoài ra nàng còn rất thông minh và bá đạo, đôi lúc nàng “chơi lầy” khiến thanh niên Han Solo nhiều lúc cứng cả họng. Với việc xây dựng nhân vật nữ mới Rey xuất thân không phải tầng lớp quí tộc, một phần mang hơi hướng hiện đại khiến tôi có cảm giác bất an cho nhân vật này. Tôi cũng không biết cách tiếp cận của đạo diễn sẽ thế nào. Trong khi các tập IV, V và VI là những tượng đài kinh điển của điện ảnh và là biểu tượng của văn hoá Pop, tập I, II, III đã khiến khán giả thất vọng vì kịch bản sơ sài, hiệu ứng hình ảnh sử dụng thừa thãi và nhân vật trẻ trâu Anakin xứng đáng được liệt vào danh sách những đứa trẻ trâu nhất trong lịch sử điện ảnh, áp lực đè lên tập VII không hề nhỏ. Họ phải làm vừa lòng những fan trung thành nhất, khôi phục lại hình ảnh mang tính chất biểu tượng, và hơn thế nữa là tạo nên một thế hệ những khán giả mới.&lt;/p&gt;

&lt;p&gt;Theo quan điểm của tôi, Star Wars 7 đã thành công ngoài mong đợi.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/G8Nxl0E.jpg&#34; alt=&#34;Các figures đội quân stormstrooper và tàu chiến tại sân bay Changi&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Tính đến thời điểm hiện tại, nói về mặt doanh thu toàn cầu đã là một minh chứng hùng hồn về việc Star Wars 7 đã chinh phục trái tim người hâm mộ. Với điểm IMDB và điểm Tomatoes khá cao đã phản ảnh được chất lượng của bộ phim trong mắt những nhà phê bình. Và nếu có dịp, tôi vẫn sẽ ra rạp và xem lại bộ phim đầy hấp dẫn này.&lt;/p&gt;

&lt;p&gt;Với những người đã xem các tập trước, đặc biệt là tập IV, V và VI thì Star Wars VII như một cầu nối kí ức. Chúng ta được gặp lại Han Solo và Chewbacca, được gặp lại Leia và các droid C-3PO, R2-D2. Tính cách của họ vẫn vậy, chàng cao bồi Han Solo vẫn tưng tửng như ngày nào, nàng Leia vẫn đẹp (lão) rạng ngời. C-3PO vẫn nhiều chuyện như xưa, R2-D2 thì vẫn “nghiêm túc” với sứ mệnh của mình. Luke giờ thì là phiên bản 2 của Obi-wan Kenobi. Những tàn tích của cuộc chiến tranh với xác tàu chiến và cỗ máy AT-AT nằm la liệt, đội quân stormstrooper vẫn là bia tập bắn cho phe chính nghĩa, cùng rất nhiều thiết bị vũ trụ làm fan cảm thấy bồi hồi xúc động.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/SoGieNB.jpg&#34; alt=&#34;Đám này vẫn mãi là bia đỡ đạn&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Và chúng ta cũng được gặp những con người của thế hệ sau: Rey, Ren, Finn và Poe. Cuộc đời và số phận của họ đang dần được hé lộ cùng với bộ phim. Điểm hay của bộ phim chính là việc kế thừa và tôn trọng những gì thuộc về “truyền thống” của Star Wars như đoạn mở đầu phim (khiến bản thân mình khi nghe nhạc còn rùng mình vì thích thú) hay cũng những con quái vật trên màn chiếu hologram, hệ thống chiến đầu trên tàu Falcon hay những cảnh rượt nhau sát sườn hệ thống vũ khí của phe Bóng Tối. Star Wars vừa là một câu chuyện nối tiếp, vừa là bản cover (tôi không gọi nó là remake) tuyệt vời. Giữ lại cái chất trong Star Wars và mang một luồng gió mới cho dòng phim kinh điển.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/ck9UNAJ.jpg&#34; alt=&#34;Đoạn Opening kinh điển&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Âm thanh và nhạc nền đóng một phần không nhỏ trong thành công của bộ phim. Cả những kĩ thuật sử dụng hiệu ứng ánh sáng và hoá trang, Star Wars 7 đã tránh được vết xe đổ của bộ prequel trước đó. Hình ảnh hành tinh sa mạc và những chủng tộc hành tinh xuất hiện, đống tàn tích sau cuộc chiến tranh đã thể hiện rõ nét hơn về những gì sau sự kiện “Return of The Jedi”. Khi các phần prequel bị thiên hạ thém cà chua vì lạm dụng kĩ xảo, chúng ta càng không mong đợi Star Wars 7 mang đến sự đột phá về cách làm phim, nhưng cách mà Star Wars 7 đã làm đầy thông thinh, kết hợp yếu tố hiệu ứng hình ảnh với practical effect, vừa mô tả được sự hùng vĩ cả các hành tinh, tàu vũ trụ, những trận chiến khốc liệt, vừa tạo nên những thước phim rất chân thật.&lt;/p&gt;

&lt;p&gt;Tôi không rõ Kylo Ren vì sao lại quá lo lắng vì không đạt được sức mạnh như ông ngoại mình. Nhưng tôi đảm bảo độ trẻ trâu của nhân vật này đã bằng với Darth Vader lúc còn là Anakin. Thật sự tôi cũng không hiểu sao mấy ông đạo diễn thích làm nhân vật phản diện trẻ trâu đến thế. Nhưng điểm cộng cho Ren đó là khi anh tức giận, thay vì bóp phát chết luôn tướng của mình như ông ngoại làm, anh ta lấy kiếm chém búa lua xua - ít ra anh còn biết bảo vệ nguồn nhân lực và người có tài. Đoạn đầy nước mắt của Ren theo mình nghĩ là do chả diễn sâu để ông bố không đề phòng. Coi như là một điểm cộng trong sự thủ đoạn của anh ấy. Finn và Rey rất dễ thương - nhưng bản thân mình thấy độ dễ thương và khùng không bằng Leia và Han. Rey thì cứng cỏi và mạnh mẽ hơn Leia nhiều, một phần là do nàng có thần lực. Mình rất thích Poe, chàng phi công xuất sắc và cũng hơi tưng tửng này. Tuy nhiên so về độ điên và bảnh thì không thể bằng Han Solo rồi.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/WN3WoYU.jpg&#34; alt=&#34;Tội nghiệp Luke&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Tóm lại, câu chuyện từ phần 1 đến phần 7 rốt cuộc xoay quanh “gia đình bá đạo” Skywalker cho cả thiên hà ăn hành ngập mặt và gánh chịu bao nhiêu tai ương. Con gái nhà này thì khùng khùng thất thường lại chảnh (đắng lòng khi phải nhận xét về Leia yêu dấu như vậy), con trai thì đứa nào cũng nhăm nhe sát hại cha mình, nếu không về mặt sáng thì cũng về mặt tối, thằng không bị chặt tay cũng bị ngâm mình trong dung nham, và điển hình là gen trẻ trâu di truyền qua nhiều thế hệ. Và tốt hơn hết, nếu bạn sống trong vũ trụ này, vào một ngày đẹp trời nào đó có ai đưa cho bạn thanh gươm ánh sáng màu xanh lá thì tốt nhất là trả lại gươm, xách tàu chạy 500 parsec tới vùng Vành Đai và chịu khó sống cuộc đời yên bình. Còn không …&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;May The Force Be With You&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;====&lt;/p&gt;

&lt;p&gt;1: &lt;a href=&#34;http://kenh14.vn/mot-phim/star-wars-the-force-awakens-bo-phim-can-moc-1-ty-usd-doanh-thu-nhanh-nhat-moi-thoi-dai-20151228124025985.chn&#34; target=&#34;_blank&#34;&gt;http://kenh14.vn/mot-phim/star-wars-the-force-awakens-bo-phim-can-moc-1-ty-usd-doanh-thu-nhanh-nhat-moi-thoi-dai-20151228124025985.chn&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2: &lt;a href=&#34;http://www.imdb.com/title/tt2488496/?ref_=nv_sr_1&#34; target=&#34;_blank&#34;&gt;http://www.imdb.com/title/tt2488496/?ref_=nv_sr_1&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dẫn nhập thuật toán ngẫu nhiên</title>
      <link>http://dangkhoasdc.github.io/post/intro_randalgs/</link>
      <pubDate>Sun, 23 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/intro_randalgs/</guid>
      <description>

&lt;p&gt;Hôm rồi học course &lt;em&gt;Introduction to Algorithm (2006-MIT)&lt;/em&gt; mình được biết qua khái niệm &lt;em&gt;Randomized Algorithms&lt;/em&gt;, dành một buổi tìm hiểu về họ thuật toán thú vị này vậy.&lt;/p&gt;

&lt;h1 id=&#34;định-nghĩa&#34;&gt;Định nghĩa&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Randomized Algorithms&lt;/em&gt; (viết gọn là &lt;code&gt;randalgs&lt;/code&gt;) là những thuật toán mà trong các bước xử lý có sử dụng số ngẫu nhiên để quyết định cho các bước tính toán tiếp theo.&lt;/p&gt;

&lt;p&gt;Điểm thú vị của &lt;code&gt;randalgs&lt;/code&gt; chính là nó không quan tâm đến trường hợp xấu nhất mà chỉ quan tâm đến &lt;em&gt;kì vọng trong trường hợp xấu nhất&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Tưởng tượng ta có một hệ thống nghiêm trọng, nếu như hệ thống đó bị crash thì sẽ kích hoạt &lt;a href=&#34;https://en.wikipedia.org/wiki/Cheget&#34; target=&#34;_blank&#34;&gt;Cheget&lt;/a&gt; và &lt;a href=&#34;https://en.wikipedia.org/wiki/Nuclear_football&#34; target=&#34;_blank&#34;&gt;Nuclear football&lt;/a&gt; cùng một lúc. Hệ thống quá lớn và phức tạp, quan trọng hơn, nó sẽ không hoạt động được khi liên tục phải chạy &lt;code&gt;quicksort&lt;/code&gt; trong $\mathcal{O}(n^2)$ - dữ liệu đầu vào là mảng được sắp xếp sẵn.&lt;/p&gt;

&lt;p&gt;Hacker, bằng một cách nào đó biết được điều này và tấn công hệ thống bằng cách đưa vào hệ thống những mảng đã sắp xếp sẵn. Và bùm, apocalyptic diễn ra.&lt;/p&gt;

&lt;p&gt;Và để ngăn chặn thảm hoạ đó xảy đến, ta tạo ra một phiên bản gọi là &lt;code&gt;randomized quicksort&lt;/code&gt;: trước khi được xử lý, mảng đầu vào sẽ được xáo trộn. Và cho dù hacker có cố tình tấn công bằng chuỗi đã sắp xếp thì sau bước tiền xử lý này , mảng được sắp xếp ngẫu nhiên.&lt;/p&gt;

&lt;p&gt;Nếu một input có trật tự ngẫu nhiên, sau khi xáo trộn trở thành một chuỗi thứ tự thì sao? &lt;a href=&#34;https://en.wikipedia.org/wiki/Murphy%27s_law&#34; target=&#34;_blank&#34;&gt;Murphy’s law&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Nếu đã xui, thì hẳn phải xui nhất có thể.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;ví-dụ&#34;&gt;Ví dụ&lt;/h1&gt;

&lt;p&gt;Một biến thế nổi tiếng của &lt;em&gt;Quick sort&lt;/em&gt; chính là &lt;em&gt;Randomized Quicksort&lt;/em&gt;, có hai phiên bản chính:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Chọn ngẫu nhiên pivot để xử lý.&lt;/li&gt;
&lt;li&gt;Xáo trộn mảng đầu vào trước khi sắp xếp.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;Randomized Quicksort&lt;/em&gt; được tạo ra nhằm tránh trường hợp xấu nhất của thuật toán &lt;em&gt;quicksort&lt;/em&gt; là $\mathcal{O}(n^2)$.&lt;/p&gt;

&lt;h1 id=&#34;phân-loại&#34;&gt;Phân loại&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;In Las Vegas, the dealer can tell you whether you’ve won or lost, but in Monte Carlo, le croupier ne parle que Français, so you have no idea what he’s saying&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;las-vegas-algorithm&#34;&gt;Las Vegas algorithm&lt;/h2&gt;

&lt;p&gt;Thuật toán nằm trong họ &lt;em&gt;Las Vegas&lt;/em&gt; &lt;em&gt;luôn luôn&lt;/em&gt; đảm bảo kết quả trả ra đúng với mong muốn. Quicksort là một ví dụ điển hình.&lt;/p&gt;

&lt;p&gt;Nói cách khác, &lt;em&gt;Las Vegas&lt;/em&gt; không chơi hên xui ở kết quả trả về, nó chỉ sử dụng yếu tố ngẫu nhiên trong các phép tính toán để cho ra kết quả đúng.&lt;/p&gt;

&lt;h2 id=&#34;monte-carlo-algorithm&#34;&gt;Monte Carlo algorithm&lt;/h2&gt;

&lt;p&gt;Khác với &lt;em&gt;Las Vegas&lt;/em&gt;, &lt;em&gt;Monte Carlo&lt;/em&gt; không đảm bảo kết quả sẽ luôn luôn đúng. Nhưng &lt;em&gt;Monto Carlo&lt;/em&gt; có xác suất kết quả sai thấp có thể.&lt;/p&gt;

&lt;p&gt;Thay vì sử dụng xác suất như một trong những quá trình tính toán, &lt;em&gt;Monte Carlo&lt;/em&gt; hên xui ngay cả kể quả trả về.&lt;/p&gt;

&lt;h2 id=&#34;phân-biệt&#34;&gt;Phân biệt&lt;/h2&gt;

&lt;h3 id=&#34;bài-toán&#34;&gt;Bài toán&lt;/h3&gt;

&lt;p&gt;Cho một chuỗi có độ dài &lt;code&gt;2n&lt;/code&gt; trong đó có &lt;code&gt;n&lt;/code&gt; kí tự &lt;code&gt;a&lt;/code&gt; và &lt;code&gt;n&lt;/code&gt; kí tự &lt;code&gt;b&lt;/code&gt;. Nhiệm vụ là tìm ra một vị trí bất kì trong chuỗi chứa kí tự a&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    import sys
    import random

    # Las Vegas version
    def find_a_lv(string):
        while True:
            pos = random.randint(0, len(string)-1)
            if string[pos] == &#39;a&#39;: return pos

    # Monte Carlo version
    def find_a_mc(string, k):
        pos = 0
        while k and string[pos] != &#39;a&#39;:
            k = k -1
            pos = random.randint(0, len(string)-1)

        return pos

    if __name__ == &#39;__main__&#39;:
        string = sys.argv[1]
        if len(string) % 2 == 1:
            raise ValueError(&amp;quot;Wrong input&amp;quot;)

        print find_a_lv(string)
        print find_a_mc(string, len(string)/2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ta dễ dàng nhận thấy &lt;code&gt;find_a_lv&lt;/code&gt; luôn luôn cho ra kết quả, tuy nhiên đôi khi nó lại không thực sự hiệu quả. Ví dụ như nếu ta có chuỗi đầu vào là “ab” và &lt;code&gt;find_a_lv&lt;/code&gt; mất 2 triệu vòng lặp mới pick đúng &lt;code&gt;pos=0&lt;/code&gt;.Dĩ nhiên xác suất để xảy ra chuyện đó rất thấp, nhưng không có nghĩa là nó không xảy ra.&lt;/p&gt;

&lt;p&gt;Còn trong trường hợp &lt;code&gt;find_a_mc&lt;/code&gt;, kết quả sẽ sai với xác suất khá dễ tính: $\frac{1}{2^k}$ - khi trong &lt;code&gt;k&lt;/code&gt; lần thử để chọn đúng vị trí chứa &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;các-kĩ-thuật-cơ-bản&#34;&gt;Các kĩ thuật cơ bản&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/0YSlgjJ.png&#34; alt=&#34;Methodologies&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Avoiding adversarial inputs:

&lt;ul&gt;
&lt;li&gt;Trong các thuật toán online.&lt;/li&gt;
&lt;li&gt;Hashing.&lt;/li&gt;
&lt;li&gt;Trong các thuật toán sắp xếp.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Verification:

&lt;ul&gt;
&lt;li&gt;Phát sinh số ngẫu nhiên trong các bài toán kiểm thực.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Random sampling:

&lt;ul&gt;
&lt;li&gt;Trong các bài toán tìm kiếm (tìm median..)&lt;/li&gt;
&lt;li&gt;Trong các thuật toán geometry.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Load balancing:

&lt;ul&gt;
&lt;li&gt;Parallel algorithms.&lt;/li&gt;
&lt;li&gt;Hashing problems.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Symmetry breaking:

&lt;ul&gt;
&lt;li&gt;Dùng trong hệ thống distributed.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Probabilistic existence proofs:

&lt;ul&gt;
&lt;li&gt;Thông qua các thực nghiệm.&lt;/li&gt;
&lt;li&gt;Đảm bảo trong bài toán tìm kiếm đối tượng cần tìm tồn tại.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;tài-liệu&#34;&gt;Tài liệu&lt;/h1&gt;

&lt;h2 id=&#34;khoá-học&#34;&gt;Khoá học&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://courses.cs.washington.edu/courses/cse525/13sp/&#34; target=&#34;_blank&#34;&gt;Randomized Algorithms and Probabilistic Analysis - Washington&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cs.brown.edu/courses/cs155/slides/slides.html&#34; target=&#34;_blank&#34;&gt;Probabilistic Methods in Computer Science&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Hướng dẫn cài đặt OpenCV trên Windows</title>
      <link>http://dangkhoasdc.github.io/post/install_opencv_vs/</link>
      <pubDate>Sun, 23 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/install_opencv_vs/</guid>
      <description>

&lt;h2 id=&#34;biên-dịch-thư-viện-opencv&#34;&gt;Biên dịch thư viện OpenCV&lt;/h2&gt;

&lt;p&gt;Điểm thuận lợi của việc tự cài đặt và biên dịch thư viện có thể kể đến như sau:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Hỗ trợ IDE mới nhất, như trong bản OpenCV 3.0 (22/11/2015) thì chưa có bản biên dịch sẵn dành cho VS 2015.&lt;/li&gt;
&lt;li&gt;Customize được các thư viện khác liên quan như Kinect, OpenCL, Python…&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;http://downloads.sourceforge.net/project/opencvlibrary/opencv-win/3.0.0/opencv-3.0.0.exe?r=http%3A%2F%2Fopencv.org%2F&amp;amp;ts=1448134045&amp;amp;use_mirror=nchc&#34; target=&#34;_blank&#34;&gt;Link Download thư viện OpenCV cho HĐH Windows&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Bước 1: Giải nén thư viện vào thư mục được định sẵn. Giả sử đường dẫn của mã nguồn là &lt;code&gt;C:\opencv&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/rwpgj0b.png&#34; alt=&#34;Giải nén mã nguồn thư viện OpenCV&#34; /&gt; Bước 2: Tải và cài đặt &lt;a href=&#34;https://cmake.org/files/v3.4/cmake-3.4.0-win32-x86.exe&#34; target=&#34;_blank&#34;&gt;CMake&lt;/a&gt;. Thư mục &lt;code&gt;build&lt;/code&gt; chứa những tập tin của phần mã nguồn được biên dịch sẵn. Phần &lt;code&gt;sources&lt;/code&gt; được sử dụng cho cài đặt manual.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/iFzMg6J.png&#34; alt=&#34;Danh sách thư mục OpenCV&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Bước 3: Mở CMake. Trong phần &lt;code&gt;Where is the source code&lt;/code&gt; sẽ trỏ đến thư mục &lt;code&gt;sources&lt;/code&gt; đã đề cập lúc trước. Phần &lt;code&gt;Where to build the binaries&lt;/code&gt; là nơi chứa phần thư viện được biên dịch. Trong ví dụ này đường dẫn là &lt;code&gt;C:\opencv\source\build&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/BGpSwUO.png&#34; alt=&#34;Giao diện CMake&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Bước tiếp theo nhấn Configure, sau đó chọn bộ generator cho project, trong phần này sẽ chọn tương ứng với IDE/Compiler mà mã nguồn mình sử dụng. Đồng thời, nếu máy tính đang ở kiến trúc x86 thì chọn các phiên bản IDE với tùy chọn là x86 (Ví dụ Visual Studio 14 2015). Đối với các máy tính kiến trúc x64 thì chọn phiên bản có hậu tố là Win64. Nhấn Finish để kết thúc cấu hình.&lt;/p&gt;

&lt;p&gt;Sau khi configure xong thì danh sách các tùy chọn khi biên dịch để hiện ra với rất nhiều tùy biến đi kèm. Phần này trong tutorial này sẽ bỏ qua vì mục tiêu chỉ cần cài đặt bộ thư viện ở mức mặc định là thành công rồi. Nếu không có gì thay đổi ta nhấn chọn Generate.&lt;/p&gt;

&lt;p&gt;Sau khi quá trình phát sinh mã nguồn hoàn tất, trong thư mục build sẽ xuất hiện các Project/Solution khác nhau.&lt;/p&gt;

&lt;p&gt;Bước 4: Dùng Visual Studio để mở solution có tên là OPENCV. Lưu ý: khi bản VS này phải trùng với bản VS đã configure trong cmake.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/nfvzGPb.png&#34; alt=&#34;Target và Architecture của Visual Studio&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Quá trình biên dịch cần thực hiện qua 2 bước: (1) biên dịch thư viện cho quá trình Debug và (2) biên dịch chương trình trong quá trình Release. Để thực hiện các bước này đơn giản chỉ cần click chọn Target sẽ build rồi sau đó nhấn F7 và ngồi đợi (Mất khoàng 10-15 phút cho quá trình biên dịch trên Debug/Release). Kết quả trong quá trình biên dịch sẽ có khoảng 50 projects biên dịch thành công, 17 cái bị skip và 2 cái bị fail. Sau khi biên dịch, ta sẽ có 2 thư mục cần quan tâm nằm trong build. Đó là thư mục lib chứa toàn bộ dữ liệu cần thiết cho quá trình lập trình; thư mục là dữ liệu cần thiết để chương trình sau khi build có thể chạy được.&lt;/p&gt;

&lt;h2 id=&#34;cấu-hình-opencv-trên-visual-studio&#34;&gt;Cấu hình Opencv trên Visual Studio&lt;/h2&gt;

&lt;p&gt;Bước 1: Tạo một Project (Empty Project).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/OR6H08N.png&#34; alt=&#34;Tạo Empty Project&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Trước khi thực hiện tiếp các công việc cấu hình cho project. Ta cần xác định rõ sẽ cần cấu hình những thông tin gì:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Nơi chứa header file của OpenCV. Dĩ nhiên ta cần làm điều này để include các đối tượng, hàm… của OpenCV.&lt;/li&gt;
&lt;li&gt;Cấu hình các file cần thiết khi lập trình.&lt;/li&gt;
&lt;li&gt;Cấu hình các file cần thiết cho quá trình thực thi. Bởi trong Visual Studio có 2 target khi run bao gồm Debug và Release, nên ta cần phải cấu hình riêng biệt cho mỗi target đó.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;cấu-hình-header-file&#34;&gt;Cấu hình header file&lt;/h3&gt;

&lt;p&gt;Click chuột phải vào tên project (InstallOpencv) chọn Properties (Hoặc nhấn Alt + F7).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/GB9Dd20.png&#34; alt=&#34;Config additional header file&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Phía bên phần Sidebar chọn C/C++, General, mục Additional Include Directories ta trỏ đến thư mục &lt;code&gt;opencv\build\include&lt;/code&gt; (không phải &lt;del&gt;&lt;code&gt;sources\build\include&lt;/code&gt;&lt;/del&gt;). Để đảm bảo ta có thể check bằng cách kiểm tra xem thư mục include đó có các header file không. Xong nhấn OK.&lt;/p&gt;

&lt;h3 id=&#34;cấu-hình-thư-viện-cho-quá-trình-lập-trình&#34;&gt;Cấu hình thư viện cho quá trình lập trình&lt;/h3&gt;

&lt;p&gt;Nhấn Alt + F7 để vào phần Properties của Project. Chọn Thẻ Linker, mục Additional Library Directories ta trỏ đến thư mục lib\Debug (trong ví dụ này là: &lt;code&gt;C:\oepncv\sources\build\lib\Debug&lt;/code&gt;). Vì đang cấu hình cho target là Debug nên phần Configuration phải là Debug&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/kAG7ftJ.png&#34; alt=&#34;Configuration&#34; /&gt; &lt;img src=&#34;http://i.imgur.com/QBpuB7C.png&#34; alt=&#34;Libs&#34; /&gt; Chuyển đến thẻ Input, mục Additional Dependencies ta nhập các file sau:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;opencv_calib3d300d.lib
opencv_core300d.lib
opencv_features2d300d.lib
opencv_flann300d.lib
opencv_hal300d.lib
opencv_highgui300d.lib
opencv_imgcodecs300d.lib
opencv_imgproc300d.lib
opencv_ml300d.lib
opencv_objdetect300d.lib
opencv_photo300d.lib
opencv_shape300d.lib
opencv_stitching300d.lib
opencv_superres300d.lib
opencv_ts300d.lib
opencv_video300d.lib
opencv_videoio300d.lib
opencv_videostab300d.lib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sau khi cấu hình xong, ta chuyển qua target là Release và thực hiện giống hệt như vậy. Tuy nhiên đường dẫn lần này sẽ là sources\build\lib\Release.&lt;/p&gt;

&lt;p&gt;Phần Additional Dependencies sẽ là:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    opencv_calib3d300.lib
    opencv_core300.lib
    opencv_features2d300.lib
    opencv_flann300.lib
    opencv_hal300.lib
    opencv_highgui300.lib
    opencv_imgcodecs300.lib
    opencv_imgproc300.lib
    opencv_ml300.lib
    opencv_objdetect300.lib
    opencv_photo300.lib
    opencv_shape300.lib
    opencv_stitching300.lib
    opencv_superres300.lib
    opencv_ts300.lib
    opencv_video300.lib
    opencv_videoio300.lib
    opencv_videostab300.lib
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cấu-hình-thư-viện-cho-quá-trình-thực-thi&#34;&gt;Cấu hình thư viện cho quá trình thực thi&lt;/h3&gt;

&lt;p&gt;Khi thực hiện build 1 chương trình, VS sẽ tạo ra trong thư mục của Solution một thư mục với cấu trúc như sau: &lt;code&gt;\Debug&lt;/code&gt; và &lt;code&gt;\Release&lt;/code&gt;. Trong ví dụ này là x64\Debug, x64\Release. Ta chép toàn bộ file trong build\bin\Debug vào x64\Debug, tương tự như vậy đối với build\bin\Release và x64\Release.&lt;/p&gt;

&lt;p&gt;Tạo một file cpp và run thử chương trình.&lt;/p&gt;

&lt;p&gt;Mã nguồn:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;
#include &amp;lt;iostream&amp;gt;
using namespace cv;
using namespace std;

int main() {
    Mat img = imread(&amp;quot;demo.jpg&amp;quot;);
    imshow(&amp;quot;show image&amp;quot;, img);
    waitKey(0);
    destroyAllWindows();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Với mã nguồn này lưu ý đặt 1 file tên là demo.jpg vào trong thư mục chứa mã nguồn).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/CtRS1r5.png&#34; alt=&#34;Demo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Kết quả ta được như hình trên.&lt;/p&gt;

&lt;h2 id=&#34;tuy-nhiên&#34;&gt;Tuy nhiên&lt;/h2&gt;

&lt;p&gt;Có một chữ tuy nhiên to đùng như vậy vì với cách cấu hình thế này có khá là nhiều bất cập:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Mỗi lần tạo 1 project OpenCV mới mà ngồi config (Mục 2) thì cũng rất là mất thời gian. Chưa kể trong lúc cấu hình mà quên mất một công đoạn nào thì có khi đi tong cả buổi chỉ để fix lỗi.&lt;/li&gt;
&lt;li&gt;Những file trong sources\bin\Debug hay Release đều xấp xỉ 900MB. Vị chi mỗi lần chép qua bên project thì tốn thêm 1.8GB bộ nhớ. Chỉ cần trong máy chứa dăm ba project dùng OpenCV thì sẽ ngốn dung lượng đến chừng nào.&lt;/li&gt;
&lt;li&gt;Phần Additional Dependencies mỗi phiên bản OpenCV mỗi khác, làm thế nào để lấy được danh sách các file như thế này.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ta sẽ giải quyết từ dễ đến khó trước.&lt;/p&gt;

&lt;h3 id=&#34;additional-dependencies&#34;&gt;Additional Dependencies&lt;/h3&gt;

&lt;p&gt;Sau khi biên dịch xong thư viện ta mở Command Line và trỏ đến thư mục &lt;code&gt;sources\build\lib&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Gõ lệnh sau&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dir Debug\*d.lib /B &amp;gt;..\DependenciesDebug.txt
dir Release\*.lib /B &amp;gt;..\DependenciesRelease.txt

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sau khi gõ xong thì trong thư mục build sẽ xuất hiện 2 file text là DependenciesDebug và DependenciesRelease chứa danh sách tât cả các file libs. Mỗi lần sử dụng chỉ cần mở file lên và chép vào.&lt;/p&gt;

&lt;h3 id=&#34;lib-configuration&#34;&gt;Lib Configuration&lt;/h3&gt;

&lt;p&gt;Mở Command Line (Với quyền Admin - click chuột phải vào biểu tượng Start và chọn Command Promp) và gõ lệnh&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; setx -m OPENCV_DIR C:\opencv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nhấn Windows E để mở Windows Explore&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/8tTY60w.png&#34; alt=&#34;Windows Explorer&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Click vào Computer và chọn Properties&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/NKnfVzz.png&#34; alt=&#34;Advanced System Settings&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Chọn Advanced system settings. Trong thẻ Advanced chọn Environment Variables…&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/HdUETeV.png&#34; alt=&#34;Path Variable Config&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Điền ngay phía sau của phần Variable value giá trị sau: &lt;code&gt;%OPENCV_DIR%\sources\build\bin\Debug;%OPENCV_DIR%\sources\build\bin\Release&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Xong, và từ giờ trở đi ta không cần phải chép các file trong build\bin vào trong project nữa.&lt;/p&gt;

&lt;h3 id=&#34;sao-lưu-config-của-project&#34;&gt;Sao lưu config của project&lt;/h3&gt;

&lt;p&gt;Trong sidebar Property Manager ta thấy danh sách các config tương ứng với từng target
architecture trong project.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/UrkPyJs.png&#34; alt=&#34;Path Variable Config&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Ta sẽ tạo một Property Sheet mới (Click chuột phải vào từng mục và chọn Add New Project Property Sheet…), double click vào mục mới tạo và cấu hình giống hệt với mục 2. Sau đó lưu lại. VS sẽ tạo ra 1 file có định dạng props trong project. Sau này khi tạo ra 1 project mới ta chỉ cần import Property đã tạo mà không cần config lại từ đầu.&lt;/p&gt;

&lt;p&gt;Vì đã set OPENCV_DIR là thư mục của OpenCV nên ta có thể thay đổi đường dẫn của các config thành&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %OPENCV_DIR%\build\include
    %OPENCV_DIR%\source\build\lib\Debug
    %OPENCV_DIR%\source\build\lib\Release

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
