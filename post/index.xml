<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Dang-Khoa&#39;s blog </title>
    <link>http://dangkhoasdc.github.io/post/</link>
    <description>Recent content in Posts on Dang-Khoa&#39;s blog </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016 Dang-Khoa</copyright>
    <lastBuildDate>Sun, 23 Oct 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="/post/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Các thuật toán ngẫu nhiên</title>
      <link>http://dangkhoasdc.github.io/post/blog/randalgs_ex/</link>
      <pubDate>Sun, 23 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/blog/randalgs_ex/</guid>
      <description>

&lt;h1 id=&#34;các-ví-dụ-về-thuật-toán-ngẫu-nhiên&#34;&gt;Các ví dụ về thuật toán ngẫu nhiên&lt;/h1&gt;

&lt;p&gt;Tiếp tục seri về thuật toán ngẫu nhiên, trong bài viết này mình ghi lại 3 ví dụ điển hình trong họ bài toán này. Tất cả các ví dụ đều nằm trong cuốn sách &lt;a href=&#34;https://www.amazon.com/Randomized-Algorithms-Rajeev-Motwani/dp/0521474655&#34; target=&#34;_blank&#34;&gt;Randomized Algorithms&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;randomized-quicksort&#34;&gt;Randomized Quicksort&lt;/h1&gt;

&lt;p&gt;Thuật toán quicksort có lẽ là một trong những thuật toán khá dễ hiểu khi tìm hiểu về các thuật toán ngẫu nhiên. Thử tưởng tượng ta cho quicksort thông thường chạy 10 lần với dữ liệu đã sắp xếp với randomized-quicksort cũng với cấu hình như vậy, ta sẽ thấy sự khác biệt lớn.&lt;/p&gt;

&lt;h2 id=&#34;thuật-toán&#34;&gt;Thuật toán&lt;/h2&gt;

&lt;h2 id=&#34;chứng-minh&#34;&gt;Chứng minh&lt;/h2&gt;

&lt;p&gt;Cho dữ liệu đầu vào gồm $n$ phần tử khác nhau. Gọi $S_i, 1 \leq i \leq n$ là phần tử &lt;em&gt;rank i&lt;/em&gt; (phần tử nhỏ thứ &lt;em&gt;i&lt;/em&gt;) trong mảng, đồng thời ta có $X_{ij}$ biến ngẫu nhiên bằng 1 nếu xuất hiện phép so sánh của 2 phần tử $S_i$ và $S_j$ trong quá trình thực thi, bằng không nếu không xuất hiện phép so sánh nào.&lt;/p&gt;

&lt;p&gt;Như vậy, độ phức tạp của &lt;code&gt;randomized-quicksort&lt;/code&gt; được tính thông qua quá trình sắp xếp mảng theo pivot mà chi phí chính nằm ở phép so sánh các phần tử, tổng chi phí chính là&lt;/p&gt;

&lt;p&gt;$$ \sum_{i=1}^n \sum_{j&amp;gt;i} X_{ij} $$&lt;/p&gt;

&lt;p&gt;Tuy nhiên, điều ta quan tâm hơn ở đây là &lt;em&gt;kì vọng&lt;/em&gt; chi phí trong các lần thực thi:&lt;/p&gt;

&lt;p&gt;$$E \left [ \sum_{i=1}^n \sum_{j&amp;gt;i} X_{ij} \right ] = \sum_{i=1}^n \sum_{j&amp;gt;i} E[X_{ij}]$$&lt;/p&gt;

&lt;p&gt;Công thức trên được xây dựng dựa vào một tính chất của kì vọng: &lt;a href=&#34;https://brilliant.org/wiki/linearity-of-expectation/&#34; target=&#34;_blank&#34;&gt;tính tuyến tính của kì vọng&lt;/a&gt;. Như vậy kì vọng của tổng các chi phí so sánh chính bằng tổng của từng kì vọng của biến ngẫu nhiên $ X_{ij}$. Gọi $p_{ij}$ là xác suất để $X_{ij}=1$. Ta có:&lt;/p&gt;

&lt;p&gt;$$ E[X_{ij}] = p_{ij} * 1 + (1-p) * 0 = p_{ij} $$
$$ E \left [ \sum_{i=1}^n \sum_{j&amp;gt;i} X_{ij} \right ] = \sum_{i=1}^n \sum_{j&amp;gt;i} p_{ij} $$&lt;/p&gt;

&lt;p&gt;Bài toán được qui về việc tính xác suất khi nào phép so sánh giữa hai phần tử $S_i$ và $S_j$ xuất hiện.&lt;/p&gt;

&lt;p&gt;Nếu ta xem quá trình thực thi của &lt;code&gt;randomized-quicksort&lt;/code&gt; là quá trình xây dựng cây nhị phân: với mỗi node chính là 1 pivot tại thời điểm gọi hàm &lt;code&gt;partition&lt;/code&gt;, kết quả hàm &lt;code&gt;partition&lt;/code&gt; ta có được 2 cây con bên trái và phải của node pivot dùng để so sánh. Nếu $S_i$ và $S_j$ nằm ở hai nhánh con trái-phải thì phép so sánh giữa hai phần tử này chắc chắn không xảy ra. Như vậy $S_i$ và $S_j$ có quan hệ cha con - một trong hai phần tử phải thuộc node cấp lớn hơn của node kia. Một giả thuyết khác cần xem xét đó là xác suất các số được chọn làm pivot phải bằng nhau (uniform distribution) - có được giả thuyết này ta mới tính được độ phức tạp trong thời gian trung bình được.&lt;/p&gt;

&lt;p&gt;Như vậy, để $X_{ij}=1$ khi và chỉ khi một trong hay vị trí $S_i$ hoặc $S_j$ được chọn, và đó là $p_{ij} = \frac{2}{j - i + 1} $ (Xác suất này được tính khi loại đi xác suất chọn phải những pivot nằm bên trái của $S_i$ hoặc nằm bên phải của $S_j$)&lt;/p&gt;

&lt;p&gt;Như vậy ta có:&lt;/p&gt;

&lt;p&gt;$$E \left [ \sum_{i=1}^n \sum_{j&amp;gt;i} X_{ij} \right ] = \sum_{i=1}^n \sum_{j&amp;gt;i} \frac{2}{j - i + 1}$$&lt;/p&gt;

&lt;p&gt;Đặt $k = j - i + 1$, ta được:&lt;/p&gt;

&lt;p&gt;$$\sum_{i=1}^n \sum_{j&amp;gt;i} p_{ij} \leq \sum_{i=1}^n \sum_{k=1}^{n-i+1} \frac{1}{k}$$&lt;/p&gt;

&lt;p&gt;$$\leq 2 \sum_{i=1}^n \sum_{k=1}^{n} \frac{1}{k}$$&lt;/p&gt;

&lt;p&gt;$$= 2n \sum_{k=1}^{n} \frac{1}{k}$$&lt;/p&gt;

&lt;p&gt;$\sum_{k=1}^{n} \frac{1}{k}$ chính là &lt;a href=&#34;https://en.wikipedia.org/wiki/Harmonic_series_(mathematics)#Rate_of_divergence&#34; target=&#34;_blank&#34;&gt;chuỗi harmony&lt;/a&gt; và tổng này sẽ hội tụ về xấp xỉ của $ln(n)$. Và như vậy&lt;/p&gt;

&lt;p&gt;$$E \left [ \sum_{i=1}^n \sum_{j&amp;gt;i} X_{ij} \right ] \leq 2n\log{n}$$&lt;/p&gt;

&lt;h1 id=&#34;random-mincut&#34;&gt;Random Mincut&lt;/h1&gt;

&lt;h2 id=&#34;ví-dụ&#34;&gt;Ví dụ&lt;/h2&gt;

&lt;p&gt;Giả sử ta có dữ liệu facebook của đám bạn cấp 3 và đang tò mò xem trong chục năm qua, những đứa bạn đó có lập thành nhóm chơi thân nào không. Dữ liệu đầu vào là danh sách các bạn trong lớp cấp 3 và mỗi quan hệ từng người với nhau (quan hệ bạn cấp 3, bạn đại học, đồng nghiệp, quan hệ nam nữ, vợ chồng).&lt;/p&gt;

&lt;p&gt;Giả sử ta tạo một đồ thị với đỉnh là một người trong lớp, &lt;code&gt;a&lt;/code&gt; có thể nối với &lt;code&gt;b&lt;/code&gt; thông qua các cạnh nối:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Bạn cấp 3 (cái này chắc chắn)&lt;/li&gt;
&lt;li&gt;Bạn đại học&lt;/li&gt;
&lt;li&gt;Đồng nghiệp&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Việc tìm ra nhóm bạn &lt;em&gt;thân&lt;/em&gt; - tức gắng bó với nhau sau thời gian cấp 3 chính là việc tìm cách tách đồ thị lớn này thành những đồ thị con.&lt;/p&gt;

&lt;p&gt;Những bài toán &lt;em&gt;chia cắt&lt;/em&gt; đồ thị gọi là &lt;em&gt;graph cut&lt;/em&gt;, nếu trong bài toán yêu cầu tìm ra đoạn cắt nào có chi phí thấp nhất: cắt ít số cạnh nhất - thì đó chính là bài toán tìm &lt;em&gt;mincut&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Trong ví dụ này ta xét đồ thị là một &lt;a href=&#34;http://mathworld.wolfram.com/Multigraph.html&#34; target=&#34;_blank&#34;&gt;multigraph&lt;/a&gt; - tức đồ thị có thể có nhiều cạnh cùng nối chung hai điểm. Một số định nghĩa cho phép &lt;em&gt;multigraph&lt;/em&gt; là đồ thị có các cạnh lặp (self-loop). Để thuận tiện cho việc chứng minh và minh hoạ, các đồ thị được đề cập trong bài là các đồ thị vô hướng.&lt;/p&gt;

&lt;h2 id=&#34;karger-mincut-https-en-wikipedia-org-wiki-karger-27s-algorithm&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Karger%27s_algorithm&#34; target=&#34;_blank&#34;&gt;Karger Mincut&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/e/e7/Single_run_of_Karger%E2%80%99s_Mincut_algorithm.svg&#34; alt=&#34;Minh hoạ thuật toán Karger&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Một quá trình quan trọng trong thuật toán Karger là &lt;em&gt;Edge Contraction&lt;/em&gt; - gộp cạnh. Cho một cạnh $ e = {u, v}$, sau phép gộp cạnh ta sẽ có được một &lt;em&gt;đỉnh&lt;/em&gt; mới là $uv$ trong đó tất cả các cạnh nối từ $u$ đến $v$ hay ngược lại đều bị loại bỏ, đồng thời các cạnh lặp (self-loop) cũng bị xoá bỏ.&lt;/p&gt;

&lt;p&gt;Với các cạnh khác $ e’ = {u, w}$ hay $e’={v, w}$ đều trở thành $e’={uv,w}$.&lt;/p&gt;

&lt;p&gt;Một cách đơn giản: phép gộp cạnh sẽ nhập 2 đỉnh lại với nhau - xoá toàn bộ các cạnh nối 2 cạnh cũ và giữ lại những cạnh nối 2 đỉnh đó với các đỉnh khác trong đồ thị.&lt;/p&gt;

&lt;p&gt;Thuật toán được mô tả như sau:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. Chọn ngẫu nhiên (theo phân phối đều) một cạnh trong đồ thị.
2. Thực hiện phép gộp cạnh vừa chọn.
3. Lặp lại bước (1) cho đến khi số đỉnh trong đồ thị còn lại 2.
4. Output: min-cut là các cạnh còn lại trong đồ thị
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;tính-đúng-đắng-của-giải-thuật&#34;&gt;Tính đúng đắng của giải thuật&lt;/h2&gt;

&lt;p&gt;Để có thể tính được độ phức tạp trong thời gian trung bình, ta cần quay lại một chút về các tính chất của đồ thị. Cho đa đồ thị (multigraph) $G=(V, E)$ gồm các đỉnh $V$ và các cạnh $E$. Gọi $d(v)$ là bậc của đỉnh $v$ là tổng số các cạnh liên thuộc với $v$. Ta có tính chất sau:&lt;/p&gt;

&lt;p&gt;$$\sum_{v \in V} d(v) = 2 | E |$$&lt;/p&gt;

&lt;p&gt;Gọi $C$ là lát cắt có kích thước nhỏ nhất $k$ - tức số lượng các cạnh trong lát cắt đó là $k$. Do đó, bậc tối thiểu của mỗi cạnh trong đồ thị này là $k$. Bởi nếu tồn tại một đỉnh có bậc nhỏ hơn $k$ thì lắt cắt $k$ không phải là lát cắt nhỏ nhất.&lt;/p&gt;

&lt;p&gt;Như vậy ta có:&lt;/p&gt;

&lt;p&gt;$$nk \leq \sum_{v \in V} d(v) = 2 | E |$$
$$|E| \geq \frac{nk}{2}$$&lt;/p&gt;

&lt;p&gt;Ta thấy xác suất để thuật toán gộp cạnh chọn đúng ngay 1 cạnh trong C chính là&lt;/p&gt;

&lt;p&gt;$$\frac{k}{|E|}$$&lt;/p&gt;

&lt;p&gt;kết hợp với bất đẳng thức phía trên, ta được:&lt;/p&gt;

&lt;p&gt;$$\frac{k}{|E|} \leq \frac{2k}{nk} = \frac{2}{n}$$&lt;/p&gt;

&lt;p&gt;Như vậy, xác suất để thuật toán gộp cạnh không chọn phải các cạnh của $C$ là $p_n $.&lt;/p&gt;

&lt;p&gt;Ta có $p_n \leq (1-\frac{2}{n})p_{n-1} $ .&lt;/p&gt;

&lt;p&gt;Đồng thời ta cũng có $ p_2 = 1 $ lí do là bởi Karger chỉ chọn cạnh để gộp khi $ \vert V \vert &amp;gt; 2 $&lt;/p&gt;

&lt;p&gt;Nên khi $ n=2 $ thì biến cố chọn phải cạnh để gộp nằm trong $ C $ chắc chắn không xảy ra.&lt;/p&gt;

&lt;p&gt;Xác suất $p_n$ có cận như sau:&lt;/p&gt;

&lt;p&gt;$$p_n \geq \prod_{i=0}^{n-3} \left (1 - \frac{2}{n-i} \right ) = \frac{2}{n(n-1)}$$&lt;/p&gt;

&lt;p&gt;Để dễ tưởng tượng hơn, ta có thể phân tích một chút về trường hợp Karger không tìm ra được mincut, rõ ràng xác suất đó chính là $ 1 - \frac{2}{n(n-1)}$, để tăng độ chính xác, ta có thể cho Karger chạy $k$ lần. Lúc này, xác suất Karger không tìm ra được mincut là: $ \left (1 - \frac{2}{n(n-1)} \right )^k$. Có một bất đẳng thức thú vị ở đây:&lt;/p&gt;

&lt;p&gt;$$\frac{1}{4} \leq \left (1 - \frac{1}{x} \right )^ x \leq \frac{1}{e}$$&lt;/p&gt;

&lt;p&gt;Giả sử $k = \frac{n(n-1)}{2}\ln n$ ta có được kết quả khá đẹp như sau:&lt;/p&gt;

&lt;p&gt;$$\left (1 - \frac{2}{n(n-1)} \right )^{\frac{n(n-1)}{2}\ln n} \leq \left (\frac{1}{e} \right )^{\frac{n(n-1)}{2}\ln n} = \left (\frac{1}{e} \right ) ^{\ln n} = \frac{1}{n}$$&lt;/p&gt;

&lt;h1 id=&#34;binary-planar-partitions&#34;&gt;Binary Planar Partitions&lt;/h1&gt;

&lt;h2 id=&#34;giới-thiệu&#34;&gt;Giới thiệu&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/cGwRyxq.png&#34; alt=&#34;Một ví dụ về cây BSP&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Binary Planar Partitions (trong trường hợp tổng quát là &lt;em&gt;Binary Space Partitions&lt;/em&gt;) là một phương pháp phổ biến được sử dụng nhằm chia cắt không gian thành các tập lồi (convex set) chứa các siêu phẳng - hyperplane. Sự chia cắt này tạo nên một cấu trúc dữ liệu được gọi là cây BSP.&lt;/p&gt;

&lt;p&gt;BSP có nhiều ứng dụng, đặc biệt là trong các bài toán về đồ hoạ. Điển hình như trong bài toán dựng hình (xác định đối tượng nào được dựng trong khung hình từ góc một góc nhìn nào đó), trong hệ thống CAD, phát hiện va chạm trong robotics, cũng như trong các bài toán chứa các cấu trúc không gian phức tạp.&lt;/p&gt;

&lt;p&gt;Trong trường hợp tổng quát, cây BSP, từ mỗi node của mình sẽ chia không gian thành hai nửa siêu phẳng, từ mỗi nửa siêu phẳng đó sẽ tiếp tục được chia cắt thành các nửa siêu phẳng nhỏ hơn sao cho những node lá cuối cùng sẽ chứa 1 đối tượng mà thuộc không gian. Có thể thấy cây BSP là trường hợp tổng quát của cây &lt;a href=&#34;https://en.wikipedia.org/wiki/K-d_tree&#34; target=&#34;_blank&#34;&gt;k-d&lt;/a&gt;, và &lt;a href=&#34;https://en.wikipedia.org/wiki/Quadtree&#34; target=&#34;_blank&#34;&gt;Quadtree&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;ví-dụ-1&#34;&gt;Ví dụ&lt;/h2&gt;

&lt;p&gt;Để đơn giản bài toán ta xét trường hợp mặt phẳng với dữ liệu đầu vào là tập các đoạn thẳng sao cho từng cặp trong tập không giao nhau $S={s_1, s_2, \dots, s_n}$, output của bài toán là một cây BSP mà mỗi vùng trong mỗi node lá chỉ chứa 1 một đoạn thẳng.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Chọn ngẫu nhiên (theo phân phối đều) một hoán vị $\pi$ trong tập hoá vị của ${1, 2, \dots, n }$ (gồm $n!$ phần tử).&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tồn tại một vùng chứa nhiều hơn 1 đoạn thẳng:&lt;/p&gt;

&lt;p&gt;2.a Cắt vùng này bởi &lt;em&gt;đường thẳng&lt;/em&gt; $l(s_i)$ trong đó $i$ là phần tử đầu tiên trong hoán vị (ở đây đường thẳng $l$ sẽ chứa $s_i$) $\pi$ sao cho $s_i$ cắt vùng đang xét.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;phân-tích&#34;&gt;Phân tích&lt;/h2&gt;

&lt;p&gt;Gọi biến $X_{ij}$ là biến ngẫu nhiên và $X_{ij}=1$ khi đường thẳng chứa $s_i$ cắt $s_j$ trong một vòng gọi đệ quy nào đó, $X_{ij}=0$ trong trường hợp ngược lại.&lt;/p&gt;

&lt;p&gt;Ở đây ta muốn xét xem kì vọng số lần thuật toán này cắt phải một đoạn thẳng trong tập đầu vào $S$.&lt;/p&gt;

&lt;p&gt;$$\mathbf{E} (X) = \mathbf{E} \left [ \sum_{i=1}^{n} \sum_{i=1}^{n} X _ {ij} \right ]$$
$$= \sum_{i=1}^{n} \sum_{i=1}^{n} \mathbf{E} [X _ {ij} ]$$
$$= \sum_{i=1}^{n} \sum_{i=1}^{n} Pr [X _ {ij} = 1 ]$$&lt;/p&gt;

&lt;p&gt;Bài toán được quy về việc tính xác suất $Pr[X_{ij}=1]$. Gọi $t$ là giao điểm của $s_i$ và $s_j$, $index(i,j)=t$ nếu $s_i$ cắt $t-1$ đoạn thẳng trước khi giao với $s_j$, như ví dụ bên dưới $s_{ij}=4$. Trường hợp hai đoạn thẳng không cắt nhau thì $S_{ij}=\infty$.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/kyaZ5CL.png&#34; alt=&#34;Ví dụ về giá trị index(i, j)&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Bởi đường thẳng chứa $s_i$ bất kì có thể tiến vô cùng về hai phía nên tồn tại hai đoạn sao cho $index(s_i, s_j) = index(s_i, s_k)$. Nếu $index(s_i, s_j)=t$ ta gọi $s_{i1}, s_{i2}, \dots, s_{it}$ là những đoạn thẳng mà $s_i$ sẽ cắt trước khi giao với $s_j$, xác suất đề sự kiện này xảy ra là $\frac{1}{t+1}$&lt;/p&gt;

&lt;p&gt;Cho một đoạn $s_k$ cố định và $m \in {0, 1, 2, dots, n-2 }$ tồn tại tối đa hai đoạn thẳng $s_l$ sao cho $index(s_l, s_k)=m$&lt;/p&gt;

&lt;p&gt;Cận trên được tính như sau:&lt;/p&gt;

&lt;p&gt;$$\mathbf{E}[X] = \sum_{i=1}^{n} \sum_{j=1}^{n} Pr [X _ {ij} = 1 ]$$
$$\leq \sum_{i=1}^{n} \sum_{j=1}^{n} \frac{1}{index(i, j) + 1}$$
$$\sum_{i=1}^{n} \sum_{k=2}^{n} \frac{2}{k}$$
$$= 2n \ln n$$&lt;/p&gt;

&lt;h1 id=&#34;tài-liệu-tham-khảo&#34;&gt;Tài liệu tham khảo.&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.csee.wvu.edu/~ksmani/courses/fa01/random/lecnotes/lecture2.pdf&#34; target=&#34;_blank&#34;&gt;Introduction to Randomized Algorithms&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cs.au.dk/~gudmund/Documents/randompearlnotes.pdf&#34; target=&#34;_blank&#34;&gt;Randomised Algorithms&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Cảm nhận Diablo III</title>
      <link>http://dangkhoasdc.github.io/post/blog/diablo3-review/</link>
      <pubDate>Sun, 23 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/blog/diablo3-review/</guid>
      <description>

&lt;p&gt;Sau gần 4 năm kể từ khi phát hành, mình mới được chơi cái game này. Thực ra do một cách tình cờ mà thấy được cái giá rẻ bất ngờ của em ý, tính ra là 20 USD cho bản Standard. Hoá ra là do đã có bản Expansion nên bản cũ mới rẻ vậy. Thôi thì lượm về chơi vậy.&lt;/p&gt;

&lt;p&gt;Lần đầu tiên chơi game Diablo là bản Diablo 2 Fury Within hồi lớp 6 lớp 7 gì đó. Vậy là cũng gần 10 năm mất rồi. Trước giờ toàn chơi Barbarian và không thèm đếm xỉa đến các nhân vật khác. Phá đảo đánh boss không biết bao nhiêu lần nhưng vẫn không hiểu sao vẫn khoái nó đến vậy.&lt;/p&gt;

&lt;p&gt;Quay trở lại với Diablo 3, với góc nhìn của một đứa chơi game cho vui và không phải là tụi &lt;em&gt;geek&lt;/em&gt; khi chơi game và thuộc lòng các công thức tính demage, defense hay tá lả các thuộc tính khác.&lt;/p&gt;

&lt;p&gt;Nhân tiện về tính &lt;em&gt;Damge per second&lt;/em&gt; (DBP) trong game:&lt;/p&gt;

&lt;script type=&#34;math/tex; mode=display&#34;&gt;\text{dps} = \frac{\text{min} + \text{max}}{2} \times \text{APS} \times \text{Attach Speed} \times ( 1 + \frac{\text{Primary Stat}}{2} ) \times (1 + \text{CritC} \times \text{CritDam}) \times \text{DamMod}&lt;/script&gt;

&lt;p&gt;Sợ rồi chứ. Tuy vẫn chưa kinh dị bằng bọn &lt;a href=&#34;http://bulbapedia.bulbagarden.net/wiki/Experience#Gain_formula&#34; target=&#34;_blank&#34;&gt;pokemon&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Quay trở lại cảm nhận và những kỷ niệm liên quan giữa Diablo III và Diablo II.&lt;/p&gt;

&lt;h2 id=&#34;cốt-truyện&#34;&gt;Cốt truyện&lt;/h2&gt;

&lt;p&gt;Có vẻ gì đó rất ảo lòi ra. Ngày xưa không quan tâm đến cốt truyện vì nhiều lý do. Đa phần là vì dốt tiếng Anh và tốn thời gian đọc thoại, nhưng ngẫm lại thì &lt;a href=&#34;https://www.youtube.com/watch?v=W6pDBXFPa_8&#34; target=&#34;_blank&#34;&gt;không phải là vấn đề của riêng mình&lt;/a&gt;; ngoài ra các bản trên đĩa CD lúc đó bán toàn bị cắt hết những cảnh Cinematic. Nhưng nếu quan tâm thì cốt truyện trông rất là &lt;em&gt;thần thánh&lt;/em&gt;, thuộc thể loại &lt;em&gt;dark fantasy&lt;/em&gt; và rất gần với gothic nên màu sắc đen tối (màu mè hơn ở bản III), liên quan mật thiết tới &lt;a href=&#34;http://www.diablofans.com/forums/diablo-iii-general-forums/diablo-iii-general-discussion/19541-judeo-christian-tradition-in-diablo3&#34; target=&#34;_blank&#34;&gt;ký hiệu Judeo-Christian&lt;/a&gt;. Xét một cách nào đó, cả ba dòng game của Blizzard đều có cái hay trong cốt truyện khá riêng biệt. Nếu Starcraft là câu chuyện của tương lai, hi-tech và các chủng loài ngoài hành tinh cũng như cuộc phiêu lưu ở tít xa các dãy thiên hà, Warcraft là câu chuyện thần thoại mang phong cách Bắc Âu với biên niên sử đồ sộ thì Diablo lại là cuộc đấu tranh của con người với nền là &lt;a href=&#34;http://diablo.wikia.com/wiki/Great_Conflict&#34; target=&#34;_blank&#34;&gt;Cuộc Chiến Bất Tận&lt;/a&gt; giữa &lt;a href=&#34;http://diablo.wikia.com/wiki/High_Heavens&#34; target=&#34;_blank&#34;&gt;thiên đàng&lt;/a&gt; và &lt;a href=&#34;http://diablo.wikia.com/wiki/Burning_Hells&#34; target=&#34;_blank&#34;&gt;địa ngục&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.ytimg.com/vi/6rJPzTTLLfI/maxresdefault.jpg&#34; alt=&#34;The Internal Conflict&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Cuốn &lt;a href=&#34;http://www.amazon.ca/Diablo-III-Book-Cain-Deckard/dp/1608870634&#34; target=&#34;_blank&#34;&gt;Book of Cain&lt;/a&gt; rất hay, dành cho dân nào mê cốt truyện. Mà thật ra, trước giờ toàn thấy thiên hạ click và click thay vì đọc thoại game. Tới đây mình đã hiểu vì sao những game như Fallout 3 lại có &lt;strong&gt;cốt truyện&lt;/strong&gt; hơn, một phần vì người chơi buộc phải theo những thoại, mạch truyện để hoàn thành nhiệm vụ.&lt;/p&gt;

&lt;h2 id=&#34;một-số-cải-tiến&#34;&gt;Một số cải tiến&lt;/h2&gt;

&lt;p&gt;Dưới góc nhìn của một đứa chơi lâu năm Diablo 2, thì một số vấn đề sau được giải quyết khá tốt trong Diablo 3:&lt;/p&gt;

&lt;h3 id=&#34;rương-đồ&#34;&gt;Rương đồ&lt;/h3&gt;

&lt;p&gt;Nếu chơi bản Diablo cũ thì rương đồ rất là tội nghiệp, chưa kể cái Cube cũng tội nghiệp không kém, trong diablo 3 thì kích thước rương đồ và item có cải thiện rõ rệt. Kích thước tối đa của item là $2 \times 1$ khác hẳn với Diablo II là $ 3 \times 2$, ngoài ra thì rương to hơn, có tăng thêm số lượng rương (thực ra là số tab), có thay đổi icon trong mỗi tab tiện cho công cuộc sắp xếp hàng.&lt;/p&gt;

&lt;h3 id=&#34;bản-đồ&#34;&gt;Bản đồ&lt;/h3&gt;

&lt;p&gt;Bản đồ siêu dễ chơi, một phần vì không đánh đố nhưng trong bản 2. Thêm vào đó có mũi tên chỉ dẫn làm nhiệm vụ nên không khó để tìm đến các đích. Ngoài bản đồ trong địa hình hiện tại còn có bản đồ khái quát của ACT. Có cảm giác nó không bự bằng Diablo II, quái trong bản đồ cũng không đông như bản trước. Không thấy có nhiều cave hay đường hầm gì nhiều, hoặc có thể là do mình chưa mò hết.&lt;/p&gt;

&lt;h3 id=&#34;các-cải-tiến-linh-tinh&#34;&gt;Các cải tiến linh tinh&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Khi đi đến cuối hầm hay cave luôn có 1 portal bằng đá để ra ngoài hang nhanh chóng.&lt;/li&gt;
&lt;li&gt;Không cần sách xanh nữa, muốn portal về nhà bao giờ cũng được. Và không cần đến chỗ portal point mới &lt;em&gt;thổ địa phù&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Không hiểu sao bản này dễ quá, Normal đánh không mất tí máu, lên Hard hiện giờ chỉ có boss mới làm mình mất máu được.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Cảm nhận Star Wars VII: The Force Awakens</title>
      <link>http://dangkhoasdc.github.io/post/blog/startwars-vii-review/</link>
      <pubDate>Sun, 23 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/blog/startwars-vii-review/</guid>
      <description>&lt;p&gt;Từ nhỏ, tôi luôn thích những cuộc phiêu lưu và những câu chuyện giả tưởng. Từ cuộc phiêu lưu của Robinson đến con tàu chu du hai mươi ngàn dặm dưới đáy biển của Jules Verne hay cuộc chiến ngoài vũ trụ trong Starcraft. Star Wars cũng không phải là ngoại lệ, dĩ nhiên tôi không phải fan cuồng đến mức đọc từng trang wiki về từng nhân vật, thậm chí đến những nhân vật xuất hiện trong phim có vài giây cũng có hẳn &lt;a href=&#34;https://www.youtube.com/watch?v=bsb9ZTmbSKQ&amp;amp;feature=youtu.be&amp;amp;t=38s&#34; target=&#34;_blank&#34;&gt;trang wiki riêng cơ mà&lt;/a&gt;. Và dù biết đến Star Wars khá muộn màng vào những năm đại học, câu chuyện về cuộc chiến trong dải thiên hà xa xôi luôn khiến tôi thích thú.&lt;/p&gt;

&lt;p&gt;Hôm nay tôi dành ngày nghỉ lễ để xem &lt;em&gt;Star Wars VII: The Force Awakens&lt;/em&gt;. Cảm nhận của tôi không gì ngoài một từ: &lt;em&gt;xuất sắc&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/wiYUg5a.jpg&#34; alt=&#34;Người trong mộng trong các thế hệ fan Star Wars&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Trước khi vào rạp, tôi không mong nhân vật nữ mới sẽ mang đến cảm giác như &lt;a href=&#34;https://www.youtube.com/watch?v=KSYValHWNOs&#34; target=&#34;_blank&#34;&gt;công chúa Leia&lt;/a&gt; từng mang đến. Nàng mang một vẻ đẹp nhẹ nhàng với tính cách vừa là của một nàng công chúa kiêu kì vừa là một người tướng của quân Kháng Chiến. Ngoài ra nàng còn rất thông minh và bá đạo, đôi lúc nàng “chơi lầy” khiến thanh niên Han Solo nhiều lúc cứng cả họng. Với việc xây dựng nhân vật nữ mới Rey xuất thân không phải tầng lớp quí tộc, một phần mang hơi hướng hiện đại khiến tôi có cảm giác bất an cho nhân vật này. Tôi cũng không biết cách tiếp cận của đạo diễn sẽ thế nào. Trong khi các tập IV, V và VI là những tượng đài kinh điển của điện ảnh và là biểu tượng của văn hoá Pop, tập I, II, III đã khiến khán giả thất vọng vì kịch bản sơ sài, hiệu ứng hình ảnh sử dụng thừa thãi và nhân vật trẻ trâu Anakin xứng đáng được liệt vào danh sách những đứa trẻ trâu nhất trong lịch sử điện ảnh, áp lực đè lên tập VII không hề nhỏ. Họ phải làm vừa lòng những fan trung thành nhất, khôi phục lại hình ảnh mang tính chất biểu tượng, và hơn thế nữa là tạo nên một thế hệ những khán giả mới.&lt;/p&gt;

&lt;p&gt;Theo quan điểm của tôi, Star Wars 7 đã thành công ngoài mong đợi.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/G8Nxl0E.jpg&#34; alt=&#34;Các figures đội quân stormstrooper và tàu chiến tại sân bay Changi&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Tính đến thời điểm hiện tại, nói về mặt doanh thu toàn cầu đã là một minh chứng hùng hồn về việc Star Wars 7 đã chinh phục trái tim người hâm mộ. Với điểm IMDB và điểm Tomatoes khá cao đã phản ảnh được chất lượng của bộ phim trong mắt những nhà phê bình. Và nếu có dịp, tôi vẫn sẽ ra rạp và xem lại bộ phim đầy hấp dẫn này.&lt;/p&gt;

&lt;p&gt;Với những người đã xem các tập trước, đặc biệt là tập IV, V và VI thì Star Wars VII như một cầu nối kí ức. Chúng ta được gặp lại Han Solo và Chewbacca, được gặp lại Leia và các droid C-3PO, R2-D2. Tính cách của họ vẫn vậy, chàng cao bồi Han Solo vẫn tưng tửng như ngày nào, nàng Leia vẫn đẹp (lão) rạng ngời. C-3PO vẫn nhiều chuyện như xưa, R2-D2 thì vẫn “nghiêm túc” với sứ mệnh của mình. Luke giờ thì là phiên bản 2 của Obi-wan Kenobi. Những tàn tích của cuộc chiến tranh với xác tàu chiến và cỗ máy AT-AT nằm la liệt, đội quân stormstrooper vẫn là bia tập bắn cho phe chính nghĩa, cùng rất nhiều thiết bị vũ trụ làm fan cảm thấy bồi hồi xúc động.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/SoGieNB.jpg&#34; alt=&#34;Đám này vẫn mãi là bia đỡ đạn&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Và chúng ta cũng được gặp những con người của thế hệ sau: Rey, Ren, Finn và Poe. Cuộc đời và số phận của họ đang dần được hé lộ cùng với bộ phim. Điểm hay của bộ phim chính là việc kế thừa và tôn trọng những gì thuộc về “truyền thống” của Star Wars như đoạn mở đầu phim (khiến bản thân mình khi nghe nhạc còn rùng mình vì thích thú) hay cũng những con quái vật trên màn chiếu hologram, hệ thống chiến đầu trên tàu Falcon hay những cảnh rượt nhau sát sườn hệ thống vũ khí của phe Bóng Tối. Star Wars vừa là một câu chuyện nối tiếp, vừa là bản cover (tôi không gọi nó là remake) tuyệt vời. Giữ lại cái chất trong Star Wars và mang một luồng gió mới cho dòng phim kinh điển.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/ck9UNAJ.jpg&#34; alt=&#34;Đoạn Opening kinh điển&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Âm thanh và nhạc nền đóng một phần không nhỏ trong thành công của bộ phim. Cả những kĩ thuật sử dụng hiệu ứng ánh sáng và hoá trang, Star Wars 7 đã tránh được vết xe đổ của bộ prequel trước đó. Hình ảnh hành tinh sa mạc và những chủng tộc hành tinh xuất hiện, đống tàn tích sau cuộc chiến tranh đã thể hiện rõ nét hơn về những gì sau sự kiện “Return of The Jedi”. Khi các phần prequel bị thiên hạ thém cà chua vì lạm dụng kĩ xảo, chúng ta càng không mong đợi Star Wars 7 mang đến sự đột phá về cách làm phim, nhưng cách mà Star Wars 7 đã làm đầy thông thinh, kết hợp yếu tố hiệu ứng hình ảnh với practical effect, vừa mô tả được sự hùng vĩ cả các hành tinh, tàu vũ trụ, những trận chiến khốc liệt, vừa tạo nên những thước phim rất chân thật.&lt;/p&gt;

&lt;p&gt;Tôi không rõ Kylo Ren vì sao lại quá lo lắng vì không đạt được sức mạnh như ông ngoại mình. Nhưng tôi đảm bảo độ trẻ trâu của nhân vật này đã bằng với Darth Vader lúc còn là Anakin. Thật sự tôi cũng không hiểu sao mấy ông đạo diễn thích làm nhân vật phản diện trẻ trâu đến thế. Nhưng điểm cộng cho Ren đó là khi anh tức giận, thay vì bóp phát chết luôn tướng của mình như ông ngoại làm, anh ta lấy kiếm chém búa lua xua - ít ra anh còn biết bảo vệ nguồn nhân lực và người có tài. Đoạn đầy nước mắt của Ren theo mình nghĩ là do chả diễn sâu để ông bố không đề phòng. Coi như là một điểm cộng trong sự thủ đoạn của anh ấy. Finn và Rey rất dễ thương - nhưng bản thân mình thấy độ dễ thương và khùng không bằng Leia và Han. Rey thì cứng cỏi và mạnh mẽ hơn Leia nhiều, một phần là do nàng có thần lực. Mình rất thích Poe, chàng phi công xuất sắc và cũng hơi tưng tửng này. Tuy nhiên so về độ điên và bảnh thì không thể bằng Han Solo rồi.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/WN3WoYU.jpg&#34; alt=&#34;Tội nghiệp Luke&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Tóm lại, câu chuyện từ phần 1 đến phần 7 rốt cuộc xoay quanh “gia đình bá đạo” Skywalker cho cả thiên hà ăn hành ngập mặt và gánh chịu bao nhiêu tai ương. Con gái nhà này thì khùng khùng thất thường lại chảnh (đắng lòng khi phải nhận xét về Leia yêu dấu như vậy), con trai thì đứa nào cũng nhăm nhe sát hại cha mình, nếu không về mặt sáng thì cũng về mặt tối, thằng không bị chặt tay cũng bị ngâm mình trong dung nham, và điển hình là gen trẻ trâu di truyền qua nhiều thế hệ. Và tốt hơn hết, nếu bạn sống trong vũ trụ này, vào một ngày đẹp trời nào đó có ai đưa cho bạn thanh gươm ánh sáng màu xanh lá thì tốt nhất là trả lại gươm, xách tàu chạy 500 parsec tới vùng Vành Đai và chịu khó sống cuộc đời yên bình. Còn không …&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;May The Force Be With You&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;====&lt;/p&gt;

&lt;p&gt;1: &lt;a href=&#34;http://kenh14.vn/mot-phim/star-wars-the-force-awakens-bo-phim-can-moc-1-ty-usd-doanh-thu-nhanh-nhat-moi-thoi-dai-20151228124025985.chn&#34; target=&#34;_blank&#34;&gt;http://kenh14.vn/mot-phim/star-wars-the-force-awakens-bo-phim-can-moc-1-ty-usd-doanh-thu-nhanh-nhat-moi-thoi-dai-20151228124025985.chn&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2: &lt;a href=&#34;http://www.imdb.com/title/tt2488496/?ref_=nv_sr_1&#34; target=&#34;_blank&#34;&gt;http://www.imdb.com/title/tt2488496/?ref_=nv_sr_1&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dẫn nhập thuật toán ngẫu nhiên</title>
      <link>http://dangkhoasdc.github.io/post/blog/intro_randalgs/</link>
      <pubDate>Sun, 23 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/blog/intro_randalgs/</guid>
      <description>

&lt;p&gt;Hôm rồi học course &lt;em&gt;Introduction to Algorithm (2006-MIT)&lt;/em&gt; mình được biết qua khái niệm &lt;em&gt;Randomized Algorithms&lt;/em&gt;, dành một buổi tìm hiểu về họ thuật toán thú vị này vậy.&lt;/p&gt;

&lt;h1 id=&#34;định-nghĩa&#34;&gt;Định nghĩa&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Randomized Algorithms&lt;/em&gt; (viết gọn là &lt;code&gt;randalgs&lt;/code&gt;) là những thuật toán mà trong các bước xử lý có sử dụng số ngẫu nhiên để quyết định cho các bước tính toán tiếp theo.&lt;/p&gt;

&lt;p&gt;Điểm thú vị của &lt;code&gt;randalgs&lt;/code&gt; chính là nó không quan tâm đến trường hợp xấu nhất mà chỉ quan tâm đến &lt;em&gt;kì vọng trong trường hợp xấu nhất&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Tưởng tượng ta có một hệ thống nghiêm trọng, nếu như hệ thống đó bị crash thì sẽ kích hoạt &lt;a href=&#34;https://en.wikipedia.org/wiki/Cheget&#34; target=&#34;_blank&#34;&gt;Cheget&lt;/a&gt; và &lt;a href=&#34;https://en.wikipedia.org/wiki/Nuclear_football&#34; target=&#34;_blank&#34;&gt;Nuclear football&lt;/a&gt; cùng một lúc. Hệ thống quá lớn và phức tạp, quan trọng hơn, nó sẽ không hoạt động được khi liên tục phải chạy &lt;code&gt;quicksort&lt;/code&gt; trong $\mathcal{O}(n^2)$ - dữ liệu đầu vào là mảng được sắp xếp sẵn.&lt;/p&gt;

&lt;p&gt;Hacker, bằng một cách nào đó biết được điều này và tấn công hệ thống bằng cách đưa vào hệ thống những mảng đã sắp xếp sẵn. Và bùm, apocalyptic diễn ra.&lt;/p&gt;

&lt;p&gt;Và để ngăn chặn thảm hoạ đó xảy đến, ta tạo ra một phiên bản gọi là &lt;code&gt;randomized quicksort&lt;/code&gt;: trước khi được xử lý, mảng đầu vào sẽ được xáo trộn. Và cho dù hacker có cố tình tấn công bằng chuỗi đã sắp xếp thì sau bước tiền xử lý này , mảng được sắp xếp ngẫu nhiên.&lt;/p&gt;

&lt;p&gt;Nếu một input có trật tự ngẫu nhiên, sau khi xáo trộn trở thành một chuỗi thứ tự thì sao? &lt;a href=&#34;https://en.wikipedia.org/wiki/Murphy%27s_law&#34; target=&#34;_blank&#34;&gt;Murphy’s law&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Nếu đã xui, thì hẳn phải xui nhất có thể.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;ví-dụ&#34;&gt;Ví dụ&lt;/h1&gt;

&lt;p&gt;Một biến thế nổi tiếng của &lt;em&gt;Quick sort&lt;/em&gt; chính là &lt;em&gt;Randomized Quicksort&lt;/em&gt;, có hai phiên bản chính:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Chọn ngẫu nhiên pivot để xử lý.&lt;/li&gt;
&lt;li&gt;Xáo trộn mảng đầu vào trước khi sắp xếp.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;Randomized Quicksort&lt;/em&gt; được tạo ra nhằm tránh trường hợp xấu nhất của thuật toán &lt;em&gt;quicksort&lt;/em&gt; là $\mathcal{O}(n^2)$.&lt;/p&gt;

&lt;h1 id=&#34;phân-loại&#34;&gt;Phân loại&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;In Las Vegas, the dealer can tell you whether you’ve won or lost, but in Monte Carlo, le croupier ne parle que Français, so you have no idea what he’s saying&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;las-vegas-algorithm&#34;&gt;Las Vegas algorithm&lt;/h2&gt;

&lt;p&gt;Thuật toán nằm trong họ &lt;em&gt;Las Vegas&lt;/em&gt; &lt;em&gt;luôn luôn&lt;/em&gt; đảm bảo kết quả trả ra đúng với mong muốn. Quicksort là một ví dụ điển hình.&lt;/p&gt;

&lt;p&gt;Nói cách khác, &lt;em&gt;Las Vegas&lt;/em&gt; không chơi hên xui ở kết quả trả về, nó chỉ sử dụng yếu tố ngẫu nhiên trong các phép tính toán để cho ra kết quả đúng.&lt;/p&gt;

&lt;h2 id=&#34;monte-carlo-algorithm&#34;&gt;Monte Carlo algorithm&lt;/h2&gt;

&lt;p&gt;Khác với &lt;em&gt;Las Vegas&lt;/em&gt;, &lt;em&gt;Monte Carlo&lt;/em&gt; không đảm bảo kết quả sẽ luôn luôn đúng. Nhưng &lt;em&gt;Monto Carlo&lt;/em&gt; có xác suất kết quả sai thấp có thể.&lt;/p&gt;

&lt;p&gt;Thay vì sử dụng xác suất như một trong những quá trình tính toán, &lt;em&gt;Monte Carlo&lt;/em&gt; hên xui ngay cả kể quả trả về.&lt;/p&gt;

&lt;h2 id=&#34;phân-biệt&#34;&gt;Phân biệt&lt;/h2&gt;

&lt;h3 id=&#34;bài-toán&#34;&gt;Bài toán&lt;/h3&gt;

&lt;p&gt;Cho một chuỗi có độ dài &lt;code&gt;2n&lt;/code&gt; trong đó có &lt;code&gt;n&lt;/code&gt; kí tự &lt;code&gt;a&lt;/code&gt; và &lt;code&gt;n&lt;/code&gt; kí tự &lt;code&gt;b&lt;/code&gt;. Nhiệm vụ là tìm ra một vị trí bất kì trong chuỗi chứa kí tự a&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    import sys
    import random

    # Las Vegas version
    def find_a_lv(string):
        while True:
            pos = random.randint(0, len(string)-1)
            if string[pos] == &#39;a&#39;: return pos

    # Monte Carlo version
    def find_a_mc(string, k):
        pos = 0
        while k and string[pos] != &#39;a&#39;:
            k = k -1
            pos = random.randint(0, len(string)-1)

        return pos

    if __name__ == &#39;__main__&#39;:
        string = sys.argv[1]
        if len(string) % 2 == 1:
            raise ValueError(&amp;quot;Wrong input&amp;quot;)

        print find_a_lv(string)
        print find_a_mc(string, len(string)/2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ta dễ dàng nhận thấy &lt;code&gt;find_a_lv&lt;/code&gt; luôn luôn cho ra kết quả, tuy nhiên đôi khi nó lại không thực sự hiệu quả. Ví dụ như nếu ta có chuỗi đầu vào là “ab” và &lt;code&gt;find_a_lv&lt;/code&gt; mất 2 triệu vòng lặp mới pick đúng &lt;code&gt;pos=0&lt;/code&gt;.Dĩ nhiên xác suất để xảy ra chuyện đó rất thấp, nhưng không có nghĩa là nó không xảy ra.&lt;/p&gt;

&lt;p&gt;Còn trong trường hợp &lt;code&gt;find_a_mc&lt;/code&gt;, kết quả sẽ sai với xác suất khá dễ tính: $\frac{1}{2^k}$ - khi trong &lt;code&gt;k&lt;/code&gt; lần thử để chọn đúng vị trí chứa &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;các-kĩ-thuật-cơ-bản&#34;&gt;Các kĩ thuật cơ bản&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/0YSlgjJ.png&#34; alt=&#34;Methodologies&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Avoiding adversarial inputs:

&lt;ul&gt;
&lt;li&gt;Trong các thuật toán online.&lt;/li&gt;
&lt;li&gt;Hashing.&lt;/li&gt;
&lt;li&gt;Trong các thuật toán sắp xếp.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Verification:

&lt;ul&gt;
&lt;li&gt;Phát sinh số ngẫu nhiên trong các bài toán kiểm thực.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Random sampling:

&lt;ul&gt;
&lt;li&gt;Trong các bài toán tìm kiếm (tìm median..)&lt;/li&gt;
&lt;li&gt;Trong các thuật toán geometry.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Load balancing:

&lt;ul&gt;
&lt;li&gt;Parallel algorithms.&lt;/li&gt;
&lt;li&gt;Hashing problems.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Symmetry breaking:

&lt;ul&gt;
&lt;li&gt;Dùng trong hệ thống distributed.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Probabilistic existence proofs:

&lt;ul&gt;
&lt;li&gt;Thông qua các thực nghiệm.&lt;/li&gt;
&lt;li&gt;Đảm bảo trong bài toán tìm kiếm đối tượng cần tìm tồn tại.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;tài-liệu&#34;&gt;Tài liệu&lt;/h1&gt;

&lt;h2 id=&#34;khoá-học&#34;&gt;Khoá học&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://courses.cs.washington.edu/courses/cse525/13sp/&#34; target=&#34;_blank&#34;&gt;Randomized Algorithms and Probabilistic Analysis - Washington&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cs.brown.edu/courses/cs155/slides/slides.html&#34; target=&#34;_blank&#34;&gt;Probabilistic Methods in Computer Science&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Hướng dẫn cài đặt OpenCV trên Windows</title>
      <link>http://dangkhoasdc.github.io/post/blog/install_opencv_vs/</link>
      <pubDate>Sun, 23 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/blog/install_opencv_vs/</guid>
      <description>

&lt;h2 id=&#34;biên-dịch-thư-viện-opencv&#34;&gt;Biên dịch thư viện OpenCV&lt;/h2&gt;

&lt;p&gt;Điểm thuận lợi của việc tự cài đặt và biên dịch thư viện có thể kể đến như sau:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Hỗ trợ IDE mới nhất, như trong bản OpenCV 3.0 (22/11/2015) thì chưa có bản biên dịch sẵn dành cho VS 2015.&lt;/li&gt;
&lt;li&gt;Customize được các thư viện khác liên quan như Kinect, OpenCL, Python…&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;http://downloads.sourceforge.net/project/opencvlibrary/opencv-win/3.0.0/opencv-3.0.0.exe?r=http%3A%2F%2Fopencv.org%2F&amp;amp;ts=1448134045&amp;amp;use_mirror=nchc&#34; target=&#34;_blank&#34;&gt;Link Download thư viện OpenCV cho HĐH Windows&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Bước 1: Giải nén thư viện vào thư mục được định sẵn. Giả sử đường dẫn của mã nguồn là &lt;code&gt;C:\opencv&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/rwpgj0b.png&#34; alt=&#34;Giải nén mã nguồn thư viện OpenCV&#34; /&gt; Bước 2: Tải và cài đặt &lt;a href=&#34;https://cmake.org/files/v3.4/cmake-3.4.0-win32-x86.exe&#34; target=&#34;_blank&#34;&gt;CMake&lt;/a&gt;. Thư mục &lt;code&gt;build&lt;/code&gt; chứa những tập tin của phần mã nguồn được biên dịch sẵn. Phần &lt;code&gt;sources&lt;/code&gt; được sử dụng cho cài đặt manual.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/iFzMg6J.png&#34; alt=&#34;Danh sách thư mục OpenCV&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Bước 3: Mở CMake. Trong phần &lt;code&gt;Where is the source code&lt;/code&gt; sẽ trỏ đến thư mục &lt;code&gt;sources&lt;/code&gt; đã đề cập lúc trước. Phần &lt;code&gt;Where to build the binaries&lt;/code&gt; là nơi chứa phần thư viện được biên dịch. Trong ví dụ này đường dẫn là &lt;code&gt;C:\opencv\source\build&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/BGpSwUO.png&#34; alt=&#34;Giao diện CMake&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Bước tiếp theo nhấn Configure, sau đó chọn bộ generator cho project, trong phần này sẽ chọn tương ứng với IDE/Compiler mà mã nguồn mình sử dụng. Đồng thời, nếu máy tính đang ở kiến trúc x86 thì chọn các phiên bản IDE với tùy chọn là x86 (Ví dụ Visual Studio 14 2015). Đối với các máy tính kiến trúc x64 thì chọn phiên bản có hậu tố là Win64. Nhấn Finish để kết thúc cấu hình.&lt;/p&gt;

&lt;p&gt;Sau khi configure xong thì danh sách các tùy chọn khi biên dịch để hiện ra với rất nhiều tùy biến đi kèm. Phần này trong tutorial này sẽ bỏ qua vì mục tiêu chỉ cần cài đặt bộ thư viện ở mức mặc định là thành công rồi. Nếu không có gì thay đổi ta nhấn chọn Generate.&lt;/p&gt;

&lt;p&gt;Sau khi quá trình phát sinh mã nguồn hoàn tất, trong thư mục build sẽ xuất hiện các Project/Solution khác nhau.&lt;/p&gt;

&lt;p&gt;Bước 4: Dùng Visual Studio để mở solution có tên là OPENCV. Lưu ý: khi bản VS này phải trùng với bản VS đã configure trong cmake.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/nfvzGPb.png&#34; alt=&#34;Target và Architecture của Visual Studio&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Quá trình biên dịch cần thực hiện qua 2 bước: (1) biên dịch thư viện cho quá trình Debug và (2) biên dịch chương trình trong quá trình Release. Để thực hiện các bước này đơn giản chỉ cần click chọn Target sẽ build rồi sau đó nhấn F7 và ngồi đợi (Mất khoàng 10-15 phút cho quá trình biên dịch trên Debug/Release). Kết quả trong quá trình biên dịch sẽ có khoảng 50 projects biên dịch thành công, 17 cái bị skip và 2 cái bị fail. Sau khi biên dịch, ta sẽ có 2 thư mục cần quan tâm nằm trong build. Đó là thư mục lib chứa toàn bộ dữ liệu cần thiết cho quá trình lập trình; thư mục là dữ liệu cần thiết để chương trình sau khi build có thể chạy được.&lt;/p&gt;

&lt;h2 id=&#34;cấu-hình-opencv-trên-visual-studio&#34;&gt;Cấu hình Opencv trên Visual Studio&lt;/h2&gt;

&lt;p&gt;Bước 1: Tạo một Project (Empty Project).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/OR6H08N.png&#34; alt=&#34;Tạo Empty Project&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Trước khi thực hiện tiếp các công việc cấu hình cho project. Ta cần xác định rõ sẽ cần cấu hình những thông tin gì:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Nơi chứa header file của OpenCV. Dĩ nhiên ta cần làm điều này để include các đối tượng, hàm… của OpenCV.&lt;/li&gt;
&lt;li&gt;Cấu hình các file cần thiết khi lập trình.&lt;/li&gt;
&lt;li&gt;Cấu hình các file cần thiết cho quá trình thực thi. Bởi trong Visual Studio có 2 target khi run bao gồm Debug và Release, nên ta cần phải cấu hình riêng biệt cho mỗi target đó.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;cấu-hình-header-file&#34;&gt;Cấu hình header file&lt;/h3&gt;

&lt;p&gt;Click chuột phải vào tên project (InstallOpencv) chọn Properties (Hoặc nhấn Alt + F7).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/GB9Dd20.png&#34; alt=&#34;Config additional header file&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Phía bên phần Sidebar chọn C/C++, General, mục Additional Include Directories ta trỏ đến thư mục &lt;code&gt;opencv\build\include&lt;/code&gt; (không phải &lt;del&gt;&lt;code&gt;sources\build\include&lt;/code&gt;&lt;/del&gt;). Để đảm bảo ta có thể check bằng cách kiểm tra xem thư mục include đó có các header file không. Xong nhấn OK.&lt;/p&gt;

&lt;h3 id=&#34;cấu-hình-thư-viện-cho-quá-trình-lập-trình&#34;&gt;Cấu hình thư viện cho quá trình lập trình&lt;/h3&gt;

&lt;p&gt;Nhấn Alt + F7 để vào phần Properties của Project. Chọn Thẻ Linker, mục Additional Library Directories ta trỏ đến thư mục lib\Debug (trong ví dụ này là: &lt;code&gt;C:\oepncv\sources\build\lib\Debug&lt;/code&gt;). Vì đang cấu hình cho target là Debug nên phần Configuration phải là Debug&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/kAG7ftJ.png&#34; alt=&#34;Configuration&#34; /&gt; &lt;img src=&#34;http://i.imgur.com/QBpuB7C.png&#34; alt=&#34;Libs&#34; /&gt; Chuyển đến thẻ Input, mục Additional Dependencies ta nhập các file sau:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;opencv_calib3d300d.lib
opencv_core300d.lib
opencv_features2d300d.lib
opencv_flann300d.lib
opencv_hal300d.lib
opencv_highgui300d.lib
opencv_imgcodecs300d.lib
opencv_imgproc300d.lib
opencv_ml300d.lib
opencv_objdetect300d.lib
opencv_photo300d.lib
opencv_shape300d.lib
opencv_stitching300d.lib
opencv_superres300d.lib
opencv_ts300d.lib
opencv_video300d.lib
opencv_videoio300d.lib
opencv_videostab300d.lib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sau khi cấu hình xong, ta chuyển qua target là Release và thực hiện giống hệt như vậy. Tuy nhiên đường dẫn lần này sẽ là sources\build\lib\Release.&lt;/p&gt;

&lt;p&gt;Phần Additional Dependencies sẽ là:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    opencv_calib3d300.lib
    opencv_core300.lib
    opencv_features2d300.lib
    opencv_flann300.lib
    opencv_hal300.lib
    opencv_highgui300.lib
    opencv_imgcodecs300.lib
    opencv_imgproc300.lib
    opencv_ml300.lib
    opencv_objdetect300.lib
    opencv_photo300.lib
    opencv_shape300.lib
    opencv_stitching300.lib
    opencv_superres300.lib
    opencv_ts300.lib
    opencv_video300.lib
    opencv_videoio300.lib
    opencv_videostab300.lib
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cấu-hình-thư-viện-cho-quá-trình-thực-thi&#34;&gt;Cấu hình thư viện cho quá trình thực thi&lt;/h3&gt;

&lt;p&gt;Khi thực hiện build 1 chương trình, VS sẽ tạo ra trong thư mục của Solution một thư mục với cấu trúc như sau: &lt;code&gt;\Debug&lt;/code&gt; và &lt;code&gt;\Release&lt;/code&gt;. Trong ví dụ này là x64\Debug, x64\Release. Ta chép toàn bộ file trong build\bin\Debug vào x64\Debug, tương tự như vậy đối với build\bin\Release và x64\Release.&lt;/p&gt;

&lt;p&gt;Tạo một file cpp và run thử chương trình.&lt;/p&gt;

&lt;p&gt;Mã nguồn:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;
#include &amp;lt;iostream&amp;gt;
using namespace cv;
using namespace std;

int main() {
    Mat img = imread(&amp;quot;demo.jpg&amp;quot;);
    imshow(&amp;quot;show image&amp;quot;, img);
    waitKey(0);
    destroyAllWindows();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Với mã nguồn này lưu ý đặt 1 file tên là demo.jpg vào trong thư mục chứa mã nguồn).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/CtRS1r5.png&#34; alt=&#34;Demo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Kết quả ta được như hình trên.&lt;/p&gt;

&lt;h2 id=&#34;tuy-nhiên&#34;&gt;Tuy nhiên&lt;/h2&gt;

&lt;p&gt;Có một chữ tuy nhiên to đùng như vậy vì với cách cấu hình thế này có khá là nhiều bất cập:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Mỗi lần tạo 1 project OpenCV mới mà ngồi config (Mục 2) thì cũng rất là mất thời gian. Chưa kể trong lúc cấu hình mà quên mất một công đoạn nào thì có khi đi tong cả buổi chỉ để fix lỗi.&lt;/li&gt;
&lt;li&gt;Những file trong sources\bin\Debug hay Release đều xấp xỉ 900MB. Vị chi mỗi lần chép qua bên project thì tốn thêm 1.8GB bộ nhớ. Chỉ cần trong máy chứa dăm ba project dùng OpenCV thì sẽ ngốn dung lượng đến chừng nào.&lt;/li&gt;
&lt;li&gt;Phần Additional Dependencies mỗi phiên bản OpenCV mỗi khác, làm thế nào để lấy được danh sách các file như thế này.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ta sẽ giải quyết từ dễ đến khó trước.&lt;/p&gt;

&lt;h3 id=&#34;additional-dependencies&#34;&gt;Additional Dependencies&lt;/h3&gt;

&lt;p&gt;Sau khi biên dịch xong thư viện ta mở Command Line và trỏ đến thư mục &lt;code&gt;sources\build\lib&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Gõ lệnh sau&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dir Debug\*d.lib /B &amp;gt;..\DependenciesDebug.txt
dir Release\*.lib /B &amp;gt;..\DependenciesRelease.txt

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sau khi gõ xong thì trong thư mục build sẽ xuất hiện 2 file text là DependenciesDebug và DependenciesRelease chứa danh sách tât cả các file libs. Mỗi lần sử dụng chỉ cần mở file lên và chép vào.&lt;/p&gt;

&lt;h3 id=&#34;lib-configuration&#34;&gt;Lib Configuration&lt;/h3&gt;

&lt;p&gt;Mở Command Line (Với quyền Admin - click chuột phải vào biểu tượng Start và chọn Command Promp) và gõ lệnh&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; setx -m OPENCV_DIR C:\opencv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nhấn Windows E để mở Windows Explore&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/8tTY60w.png&#34; alt=&#34;Windows Explorer&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Click vào Computer và chọn Properties&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/NKnfVzz.png&#34; alt=&#34;Advanced System Settings&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Chọn Advanced system settings. Trong thẻ Advanced chọn Environment Variables…&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/HdUETeV.png&#34; alt=&#34;Path Variable Config&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Điền ngay phía sau của phần Variable value giá trị sau: &lt;code&gt;%OPENCV_DIR%\sources\build\bin\Debug;%OPENCV_DIR%\sources\build\bin\Release&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Xong, và từ giờ trở đi ta không cần phải chép các file trong build\bin vào trong project nữa.&lt;/p&gt;

&lt;h3 id=&#34;sao-lưu-config-của-project&#34;&gt;Sao lưu config của project&lt;/h3&gt;

&lt;p&gt;Trong sidebar Property Manager ta thấy danh sách các config tương ứng với từng target
architecture trong project.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/UrkPyJs.png&#34; alt=&#34;Path Variable Config&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Ta sẽ tạo một Property Sheet mới (Click chuột phải vào từng mục và chọn Add New Project Property Sheet…), double click vào mục mới tạo và cấu hình giống hệt với mục 2. Sau đó lưu lại. VS sẽ tạo ra 1 file có định dạng props trong project. Sau này khi tạo ra 1 project mới ta chỉ cần import Property đã tạo mà không cần config lại từ đầu.&lt;/p&gt;

&lt;p&gt;Vì đã set OPENCV_DIR là thư mục của OpenCV nên ta có thể thay đổi đường dẫn của các config thành&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %OPENCV_DIR%\build\include
    %OPENCV_DIR%\source\build\lib\Debug
    %OPENCV_DIR%\source\build\lib\Release

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Một chút thống kê về các bài báo CVPR16</title>
      <link>http://dangkhoasdc.github.io/post/blog/cvpr16-stat/</link>
      <pubDate>Sun, 23 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/blog/cvpr16-stat/</guid>
      <description>

&lt;p&gt;Hôm nay tình cờ thấy cái link liệt kê &lt;a href=&#34;http://www.cv-foundation.org/openaccess/CVPR2016.py&#34; target=&#34;_blank&#34;&gt;các bài được accept ở CVPR16&lt;/a&gt;, thế là mình ngồi thống kê vài cái cho vui&lt;/p&gt;

&lt;p&gt;Đầu tiên là parse đống html này, sau đó dùng python load một dữ liệu lên, ta có được:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Số bài báo được accept: 643 bài.&lt;/li&gt;
&lt;li&gt;Người có nhiều bài được đăng nhất: Ming-Hsuan Yang với tổng cộng 11 bài.&lt;/li&gt;
&lt;li&gt;Bài có chữ &lt;em&gt;deep&lt;/em&gt; trong tiêu đề: 87 bài, chiếm 13.53% tổng số bài được accept.&lt;/li&gt;
&lt;li&gt;Bài có số tác giả nhiều nhất: &lt;em&gt;Multimodal Spontaneous Emotion Corpus for Human Behavior Analysis&lt;/em&gt; với 13 tác giả đứng tên.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Bài chỉ có 1 tác giả (một mình chống mafia):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/Kobayashi_Structured_Feature_Similarity_CVPR_2016_paper.pdf&#34; target=&#34;_blank&#34;&gt;Structured Feature Similarity With Explicit Feature Map&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/Qi_Hierarchically_Gated_Deep_CVPR_2016_paper.pdf&#34; target=&#34;_blank&#34;&gt;Hierarchically Gated Deep Networks for Semantic Segmentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/Sekii_Robust_Real-Time_3D_CVPR_2016_paper.pdf&#34; target=&#34;_blank&#34;&gt;Robust, Real-Time 3D Tracking of Multiple Objects With Similar Appearances&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/Yang_Semantic_Filtering_CVPR_2016_paper.pdf&#34; target=&#34;_blank&#34;&gt;Semantic Filtering&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://arxiv.org/abs/1603.00560&#34; target=&#34;_blank&#34;&gt;Learnt Quasi-Transitive Similarity for Retrieval From Large Collections of Faces&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;cv-foundation còn hào phóng đính kèm trong source link download các paper, đồng thời có cả bibtex của các bài, nếu kết hợp với arxiv api thì có thể thống kê được nhiều thứ hay ho hơn nữa =))&lt;/p&gt;

&lt;h1 id=&#34;một-số-thống-kê-về-tác-giả&#34;&gt;Một số thống kê về tác giả.&lt;/h1&gt;

&lt;p&gt;Thử xem phân phối số lượng tác giả trên đầu bài của CVPR16 thế nào. Theo như kết quả, số bài ở CVPR16 trung bình có từ 2, 3 hoặc 4 tác giả đứng tên. Nhiều nhất là các bài có 3 tác giả (186 bài). Ngoại trừ gã outlier 13 tác giả thì biểu đồ đã gần giống với &lt;em&gt;phân phối chuẩn&lt;/em&gt; rồi.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/gpHfOTW.png&#34; alt=&#34;Biểu đồ phân bố số lượng tác giả trong một bài báo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Có &lt;em&gt;1843&lt;/em&gt; tác giả có bài trong CVPR16. Ngoài &lt;em&gt;Ming-Hsuan Yang&lt;/em&gt; bá đạo ở trên, trong danh sách tác giả nhiều bài còn có những cái tên nổi bật như: Pascal Fua, Li Fei-Fei. Dưới đây là danh sách các tác giả có nhiều bài nhất trong CVPR16:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Lei Zhang [&lt;a href=&#34;https://scholar.google.com/citations?user=tAK5l1IAAAAJ&#34; target=&#34;_blank&#34;&gt;scholar&lt;/a&gt;] [&lt;a href=&#34;http://www4.comp.polyu.edu.hk/~cslzhang/&#34; target=&#34;_blank&#34;&gt;homepage&lt;/a&gt;]: 7 bài.&lt;/li&gt;
&lt;li&gt;In So Kweon [&lt;a href=&#34;https://scholar.google.com.sg/citations?user=XA8EOlEAAAAJ&amp;amp;hl=en&#34; target=&#34;_blank&#34;&gt;scholar&lt;/a&gt;] [&lt;a href=&#34;http://rcv.kaist.ac.kr/v2/bbs/member_detail.php?mb_id=%20iskweon&#34; target=&#34;_blank&#34;&gt;homepage&lt;/a&gt;]: 7 bài.&lt;/li&gt;
&lt;li&gt;Antonio Torralba [&lt;a href=&#34;https://scholar.google.com/citations?user=8cxDHS4AAAAJ&#34; target=&#34;_blank&#34;&gt;scholar&lt;/a&gt;] [&lt;a href=&#34;http://web.mit.edu/torralba/www/&#34; target=&#34;_blank&#34;&gt;homepage&lt;/a&gt;]: 7 bài.&lt;/li&gt;
&lt;li&gt;Jiashi Feng [&lt;a href=&#34;https://scholar.google.com.sg/citations?hl=en&amp;amp;user=Q8iay0gAAAAJ&amp;amp;view_op=list_works&amp;amp;sortby=pubdate&#34; target=&#34;_blank&#34;&gt;scholar&lt;/a&gt;] [&lt;a href=&#34;https://sites.google.com/site/jshfeng/&#34; target=&#34;_blank&#34;&gt;homepage&lt;/a&gt;]: 7 bài.&lt;/li&gt;
&lt;li&gt;Wangmeng Zuo [&lt;a href=&#34;https://scholar.google.com/citations?user=rUOpCEYAAAAJ&#34; target=&#34;_blank&#34;&gt;scholar&lt;/a&gt;] [&lt;a href=&#34;http://homepage.hit.edu.cn/pages/wangmengzuo&#34; target=&#34;_blank&#34;&gt;homepage&lt;/a&gt;]: 7 bài.&lt;/li&gt;
&lt;li&gt;Anton van den Hengel [&lt;a href=&#34;https://scholar.google.com.sg/citations?user=nMGZ2ZQAAAAJ&amp;amp;hl=en&#34; target=&#34;_blank&#34;&gt;scholar&lt;/a&gt;] [&lt;a href=&#34;https://cs.adelaide.edu.au/~hengel/&#34; target=&#34;_blank&#34;&gt;homepage&lt;/a&gt;]: 8 bài.&lt;/li&gt;
&lt;li&gt;Bernt Schiele [&lt;a href=&#34;https://scholar.google.com/citations?user=z76PBfYAAAAJ&#34; target=&#34;_blank&#34;&gt;scholar&lt;/a&gt;] [&lt;a href=&#34;https://www.mpi-inf.mpg.de/departments/computer-vision-and-multimodal-computing/people/bernt-schiele/&#34; target=&#34;_blank&#34;&gt;homepage&lt;/a&gt;]: 8 bài.&lt;/li&gt;
&lt;li&gt;Luc Van Gool [&lt;a href=&#34;https://scholar.google.com.hk/citations?user=TwMib_QAAAAJ&amp;amp;hl=zh-CN&#34; target=&#34;_blank&#34;&gt;scholar&lt;/a&gt;] [&lt;a href=&#34;http://www.vision.ee.ethz.ch/~vangool/&#34; target=&#34;_blank&#34;&gt;homepage&lt;/a&gt;]: 8 bài.&lt;/li&gt;
&lt;li&gt;Xiaogang Wang [&lt;a href=&#34;https://scholar.google.com.sg/citations?user=-B5JgjsAAAAJ&amp;amp;hl=en&#34; target=&#34;_blank&#34;&gt;scholar&lt;/a&gt;] [&lt;a href=&#34;http://www.ee.cuhk.edu.hk/~xgwang/&#34; target=&#34;_blank&#34;&gt;homepage&lt;/a&gt;]: 9 bài.&lt;/li&gt;
&lt;li&gt;Ming-Hsuan Yang [&lt;a href=&#34;https://scholar.google.com/citations?user=p9-ohHsAAAAJ&#34; target=&#34;_blank&#34;&gt;scholar&lt;/a&gt;] [&lt;a href=&#34;http://faculty.ucmerced.edu/mhyang/&#34; target=&#34;_blank&#34;&gt;homepage&lt;/a&gt;]: 11 bài.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Một điểm mình quan tâm nữa là mối quan hệ giữa các tác giả với nhau &lt;del&gt;đó là lí do mình viết: một mình chống mafia ở đoạn trên&lt;/del&gt;. Ở đây mình dùng &lt;code&gt;graph-tool&lt;/code&gt; để minh hoạ data đã thu thập được. Cách xây dựng đồ thị khá đơn giản: những tác giả đứng chung bài với nhau sẽ có cạnh nối với nhau.&lt;/p&gt;

&lt;p&gt;Xưa kia nhà toán học Michael Gurevich đã từng thử điều này với các nhà toán học, và hiện nay bài toán &lt;a href=&#34;https://research.facebook.com/blog/three-and-a-half-degrees-of-separation/&#34; target=&#34;_blank&#34;&gt;Six degree of Seperation&lt;/a&gt; đã nổi tiếng và quan tâm nhiều.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/QIiCNur.png&#34; alt=&#34;Vision Gang&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Nhìn hình ta có thể hình dung có 1 hội mafia cực lớn dây mơ rễ má với nhau. Và các team lẻ lẻ hơn thì bị nằm ngoài rìa, có 1 số team hoạt động khá độc lập (nằm giữa vùng trung tâm và vành đai). Đồng thời những chấm đỏ mỏng manh nằm ngoài vùng vành đai chính là các thánh một mình chống mafia, xin hoan nghênh các anh.&lt;/p&gt;

&lt;h1 id=&#34;chủ-đề-của-cvpr16&#34;&gt;Chủ đề của &lt;code&gt;CVPR16&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/9AxhgVP.png&#34; alt=&#34;Main topics&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Ban đầu mình dự định sử dụng &lt;code&gt;arvix-api&lt;/code&gt; để lấy keywords từ Bibtex tuy nhiên vì có cơ số bài hiện chưa có trên Arvix (mình sample 5 bài và cả 5 bài đều không được tìm thấy trên đó) nên không có cách để lấy chính xác keywords.&lt;/p&gt;

&lt;p&gt;Có 2 cách tiếp cận:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Dựa vào tiêu đề. Cách này sẽ nhanh hơn vì dữ liệu này đã có sẵn.&lt;/li&gt;
&lt;li&gt;Dựa vào nội dung. Cách làm tương đối đơn giản nhưng hơi mất thời gian: (1) download đống paper từ &lt;code&gt;cv-foundation&lt;/code&gt;, (2) dùng &lt;code&gt;pdf2text&lt;/code&gt; lưu text, (3) dùng 1 số thuật toán clustering để phân loại.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Cách thứ (2) tương đối dài hơi nên mình ưu tiên dùng cách thứ (1) trước. Một thuật toán để rút trích keywords khá nổi tiếng là &lt;a href=&#34;https://github.com/aneesha/RAKE/blob/master/rake.py&#34; target=&#34;_blank&#34;&gt;RAKE&lt;/a&gt;. Dưới đây là kết quả.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    deep convolutional neural networks
    convolutional neural networks
    recurrent neural networks
    deep neural networks
    salient object detection
    convolutional networks
    sparse coding
    object detection
    image segmentation
    action recognition
    semantic segmentation
    optical flow
    shot learning
    unsupervised learning
    activity recognition
    set registration
    person re
    image
    pose
    detection
    video
    learning

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;future-works&#34;&gt;Future Works&lt;/h1&gt;

&lt;p&gt;Hiện giờ minh đang tìm cách download toàn bộ pdf của bài năm nay để làm clustering và phân tích nội dung, đồng thời làm 1 tool search nho nhỏ. Ngoài ra hiện giờ mình đang tìm kiếm danh sách các bài các năm trước để có thêm 1 số phân tích hay ho hơn nữa (về trending, các bài được cite nhiều,).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Những kênh thông tin công nghệ</title>
      <link>http://dangkhoasdc.github.io/post/blog/it_news/</link>
      <pubDate>Sun, 23 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/blog/it_news/</guid>
      <description>

&lt;h4 id=&#34;đây-là-một-chủ-đề-được-mình-nói-kha-khá-nhiều-lần-tại-open-talk-ở-trường-đh-tự-nhiên-nói-quá-thôi-chứ-đi-có-2-lần-một-trong-những-thiếu-sót-lớn-của-sinh-viên-cntt-đó-là-không-nắm-kịp-tin-tức-công-nghệ-cũng-như-không-biết-thế-giới-đang-chạy-tới-đâu-rồi-chia-sẻ-dưới-đây-của-mình-chỉ-tập-trung-vào-các-mảng-mình-quan-tâm-nên-dĩ-nhiên-còn-rất-nhiều-thiếu-sót-những-lĩnh-vực-khá-tuy-nhiên-có-thể-tìm-các-kênh-thông-tin-thông-qua-một-số-thủ-thuật-mẹo-vặt&#34;&gt;Đây là một chủ đề được mình nói kha khá nhiều lần tại Open Talk ở trường ĐH Tự Nhiên (nói quá thôi chứ đi có 2 lần). Một trong những thiếu sót lớn của sinh viên CNTT đó là không nắm kịp tin tức công nghệ cũng như không biết thế giới đang chạy tới đâu rồi. Chia sẻ dưới đây của mình chỉ tập trung vào các mảng mình quan tâm nên dĩ nhiên còn rất nhiều thiếu sót những lĩnh vực khá. Tuy nhiên, có thể tìm các kênh thông tin thông qua một số thủ thuật, mẹo vặt.&lt;/h4&gt;

&lt;h2 id=&#34;chăm-đi-hội-thảo&#34;&gt;Chăm đi hội thảo&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://cdn.meme.am/instances/58698551.jpg&#34; alt=&#34;Barcamp: best place for getting gifts and clothes&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Dĩ nhiên là trừ mấy hội thảo Đa Cấp. Theo như kinh nghiệm lặn lội 4 năm ở giảng đường đại học, kinh qua không biết bao nhiêu hội thảo của IBM, M$, Nokia, blah blah. Mình vẫn còn ấn tượng lần đầu tiên hồi năm 1 đi dự buổi training về công nghệ Cloud của IBM, nhờ buổi đó mà đi về mình chả biết thêm gì cả. Nhưng vẫn còn nhớ cái cảnh xuống xe số 6 chỗ đường Sư Vạn Hạnh giao với An Dương Vương và đi bộ mệt nghỉ tới trường Ngoại Ngữ Tin Học . Buổi thứ hai là khi tham dự buổi phát động Imaging Cup. Phải công nhận buổi đó rất ấn tượng và khiến mình có động lực làm đại sứ Microsoft: &lt;a href=&#34;http://www.microsoft.com/vietnam/student/introduction.aspx&#34; target=&#34;_blank&#34;&gt;Microsoft Student Partner&lt;/a&gt;. Dù đã có cố gắng tham gia hồi năm 2, năm 3 gì đó nhưng bất thành. Không liên quan nhưng 1 thằng bạn trong lớp sau này thành MSP. Đến năm hai thì đi nhiều hơn, máu hơn, dù đôi lúc ngồi bên trong chả biết thiên hạ nói gì, nhưng quan trọng mình cũng định hình được chuyện gì đang xảy ra với làng công nghệ.&lt;/p&gt;

&lt;p&gt;Một số hội thảo khá hay ho ở TP.Hồ Chí Minh có thể kể đến như:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.facebook.com/BarCampSaigon&#34; target=&#34;_blank&#34;&gt;Barcamp&lt;/a&gt;: Phải đi vì là nơi qui tụ các thánh, ăn buffet được tặng áo. blah blah, đây cũng là event công nghệ khá lớn.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.facebook.com/MicrosoftDeveloper.Vietnam&#34; target=&#34;_blank&#34;&gt;Các buổi training của Microsoft&lt;/a&gt;: tập trung vào công nghệ của Microsoft.&lt;/li&gt;
&lt;li&gt;Google Developer Group: buổi ra mắt năm 2013 cực kì hoành tráng. Nhưng rồi có vẻ hơi chìm dần, nhưng nghe đồn đâu vẫn còn hoạt động.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.meetup.com/&#34; target=&#34;_blank&#34;&gt;Các nhóm lập trình trên MeetUp&lt;/a&gt;: Có thấy group về Javascript và PHP hoạt động khá dữ dội trên này.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;reddit&#34;&gt;Reddit&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://wp.streetwise.co/wp-content/uploads//2014/08/Reddit.png&#34; alt=&#34;Reddit&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Thật khó để nói Reddit là mạng xã hội như thế nào. Có thể hiểu đây là một hình thái của &lt;a href=&#34;http://vozforums.com/forumdisplay.php?f=17&#34; target=&#34;_blank&#34;&gt;Voz&lt;/a&gt; hay Webtretho phiên bản nước ngoài, tuy nhiên tầm hoạt động cũng như các chủ đề vô cùng rộng lớn. Có rất nhiều diễn đàn con trong này là những chia sẻ về công nghệ rất đáng quan tâm. Chỉ cần tạo một nick và subcribe những chủ đề mình thích, mỗi ngày sẽ có hàng tá thông tin hay ho. Ngoài ra, việc đọc bài trên Reddit còn giúp luyện tiếng Anh (chủ yếu slang và idiom ) cũng như học hỏi được từ các thành viên khác.&lt;/p&gt;

&lt;p&gt;Một số trang tiêu biểu mình follows:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.reddit.com/r/programming&#34; target=&#34;_blank&#34;&gt;/r/programming&lt;/a&gt;: trang này hầu như cập nhật những tin mới nhất về lập trình. Nhảm hài hay nghiêm túc đều có.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.reddit.com/r/dailyprogrammer/&#34; target=&#34;_blank&#34;&gt;/r/dailyprogramming&lt;/a&gt;: coding mỗi ngày. Trang này rất hay để mỗi ngày tập code một tí.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.reddit.com/r/coding&#34; target=&#34;_blank&#34;&gt;/r/coding&lt;/a&gt;: thuần tuý về coding.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.reddit.com/r/compsci&#34; target=&#34;_blank&#34;&gt;/r/compsci&lt;/a&gt;: tin tức trong lĩnh vực Khoa Học Máy Tính.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.reddit.com/r/webdev&#34; target=&#34;_blank&#34;&gt;/r/webdev&lt;/a&gt;: subreddit dành cho dân phát triển website.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.reddit.com/r/machinelearning&#34; target=&#34;_blank&#34;&gt;/r/machinelearning&lt;/a&gt;: Máy Học và các vấn đề liên quan.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.reddit.com/r/vim&#34; target=&#34;_blank&#34;&gt;/r/vim&lt;/a&gt;: editor ưu thích.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.reddit.com/r/programmingchallenges&#34; target=&#34;_blank&#34;&gt;/r/programmingchallenges&lt;/a&gt;: dành cho những thánh code.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.reddit.com/r/cpp&#34; target=&#34;_blank&#34;&gt;/r/cpp&lt;/a&gt;: ngôn ngữ C++ thần thánh.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.reddit.com/r/javascript&#34; target=&#34;_blank&#34;&gt;/r/javascript&lt;/a&gt;: trang tin về javascript.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.reddit.com/r/ProgrammerHumor/top/&#34; target=&#34;_blank&#34;&gt;/r/ProgrammerHumor&lt;/a&gt;: Hài hước theo cách của tụi lập trình viên.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;trang-tin-công-nghệ&#34;&gt;Trang tin công nghệ&lt;/h2&gt;

&lt;p&gt;Hiện nay có rất nhiều trang thông tin công nghệ có thể theo dõi, ở trong Việt Nam thì mình thấy có một số trang khá hay ho đến từ các tổ chức, công ty. Có thể kể đến như của &lt;a href=&#34;http://blog.siliconstraits.vn/&#34; target=&#34;_blank&#34;&gt;Silicon Strait Saigon&lt;/a&gt; trang này chuyên tin về iOS, Web và Design, chất lượng bài viết khá tốt. &lt;a href=&#34;https://tinhte.vn/&#34; target=&#34;_blank&#34;&gt;TinhTe.vn&lt;/a&gt; cập nhật các tin tức liên quan đến công nghệ, có cả máy ảnh, xe cộ, blah blah. Tuy nhiên điểm mình không hài lòng đó là chất lượng bài viết không quá tốt, không đào sâu, đặc biệt liên quan đến các chủ đề lập trình hay khoa học máy tính, tốt nhất là đọc để biết tin tức thế nào. Một phần nữa users thành phần trẻ trâu nhiều, hàm lượng thông tin chả có bao. &lt;a href=&#34;http://vinacode.net/&#34; target=&#34;_blank&#34;&gt;VinaCode&lt;/a&gt; cũng là một trong những trang chăm chỉ cập nhật bài viết, chủ yếu dịch từ nước ngoài, nhưng có gọi là có đầu tư. Một trang khác đó là &lt;a href=&#34;http://blog.itviec.com/&#34; target=&#34;_blank&#34;&gt;ITViec&lt;/a&gt;: rất nhiều thông tin bổ ích để xây dựng thương hiệu bản thân, mình cũng thấy chất lượng dịch thuật ở đây khá là chất.&lt;/p&gt;

&lt;p&gt;Một trang mới nổi hiện nay là &lt;a href=&#34;http://recode.net/&#34; target=&#34;_blank&#34;&gt;Re/Code&lt;/a&gt;: trang này cập nhật các thông tin công nghệ rất hay, bài viết cũng chất lượng.&lt;/p&gt;

&lt;p&gt;Một số trang cũng hay follow như:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.theverge.com/&#34; target=&#34;_blank&#34;&gt;The Verge&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mashable.com/&#34; target=&#34;_blank&#34;&gt;The Mashable&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.quora.com/&#34; target=&#34;_blank&#34;&gt;Quora&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;đứng-trên-vai-người-khổng-lồ&#34;&gt;Đứng trên vai người khổng lồ&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://wallpaperscraft.com/image/titanium_kousen_yasuo_art_mikasa_ackerman_girl_94711_640x1136.jpg&#34; alt=&#34;You know what I mean. btw, I love Mikasa&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Mình rất thích vế này. Những người đầu ngành, nhất là về lĩnh vực Công Nghệ thì thường hay chia sẻ tin tức, quan điểm, sản phẩm của mình ở các trang xã hội như Facebook, G+ (có khá nhiều giáo sư đầu ngành xài mạng này) và Twitter, một số khác còn dùng trang cá nhân (homepage) hay blog để chia sẻ kiến thức nữa. Ở Việt Nam mình thích nhất &lt;a href=&#34;http://www.procul.org/blog/&#34; target=&#34;_blank&#34;&gt;trang của các bậc tiền bối&lt;/a&gt;, bài viết rất chất lượng và có tính chuyên sâu. Nếu quan tâm đến máy học và các vấn đề về thị giác máy tính có thể quan tâm, theo dõi trang cá nhân của các nhân vật lừng lẫy sau:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.facebook.com/andrew.ng.96&#34; target=&#34;_blank&#34;&gt;Andrew Ng.&lt;/a&gt;: không cần nói cũng biết là ai.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.facebook.com/yann.lecun&#34; target=&#34;_blank&#34;&gt;Yann LeCun&lt;/a&gt;: Trưởng điều hành bộ phận AI Facebook Research.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://plus.google.com/+LinusTorvalds&#34; target=&#34;_blank&#34;&gt;Linus Tovalds&lt;/a&gt;: cha để Linux.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://research.facebook.com/&#34; target=&#34;_blank&#34;&gt;Facebook Research&lt;/a&gt;: Cập nhật các công trình nghiên cứu của Facebook.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Còn rất nhiều bậc cao nhân khác nữa. Đọc và tìm hiểu quan điểm về công nghệ của họ là một cách tốt nhất nâng cao hiểu biết của mình.&lt;/p&gt;

&lt;h2 id=&#34;blogs&#34;&gt;Blogs&lt;/h2&gt;

&lt;p&gt;Điểm khác biệt của blog là mang nhiều ý kiến chủ quan của người viết hơn, giọng văn và cách hành ngôn cũng cá nhân hoá hơn. Thông thường các bài viết ở đây khá vui và độc đáo, thực sự mình thích đọc bên blog nhiều hơn, phần nào đó thể hiện được quan điểm của tác giả, bài viết thường có đầu tư và chuyên sâu vào một mảng nào đó.&lt;/p&gt;

&lt;p&gt;Về mảng Thị Giác Máy Tính có &lt;a href=&#34;http://www.computervisionblog.com/&#34; target=&#34;_blank&#34;&gt;Computervision blog&lt;/a&gt; - bài viết rất chất.&lt;/p&gt;

&lt;p&gt;Có khá nhiều trang blog kinh điển của mà hầu như mọi programmer đều biết. Có thể kể đến như (1): &lt;a href=&#34;http://blog.codinghorror.com/&#34; target=&#34;_blank&#34;&gt;Coding Horror&lt;/a&gt;: đọc bài trong này level về công nghệ phần nào tăng lên rõ rệt.&lt;/p&gt;

&lt;p&gt;Một thánh nữa mà ngày xưa mình rất hay theo dõi khi còn xài Windows và code C# đó là &lt;a href=&#34;http://www.hanselman.com/blog/&#34; target=&#34;_blank&#34;&gt;Hanselman&lt;/a&gt;. Ngày xưa biết đến thánh nhờ bài viết &lt;a href=&#34;http://www.hanselman.com/blog/ScottHanselmans2014UltimateDeveloperAndPowerUsersToolListForWindows.aspx&#34; target=&#34;_blank&#34;&gt;các công cụ dành cho dev&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://jeremykun.com/&#34; target=&#34;_blank&#34;&gt;Jeremykun&lt;/a&gt;: những bài viết là sự kết hợp tuyệt vời của toán học và lập trình, rất đáng để dành thời gian đọc.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://thecodelesscode.com/contents&#34; target=&#34;_blank&#34;&gt;Codeless code&lt;/a&gt;: trang này viết theo kiểu “khó-hiểu-như-trong-kinh-thánh”, độ giải trí và suy ngẫm rất cao.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://lambda-the-ultimate.org/&#34; target=&#34;_blank&#34;&gt;Programming Languages weblog&lt;/a&gt;: trang này thì quá nổi tiếng rồi.&lt;/p&gt;

&lt;p&gt;Một số chuyên sâu hơn về các kỹ thuật trong lập trình, mình chỉ khoái mỗi C++ và Python, theo mình một số trang sau khá là hay:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.jetbrains.com/clion/&#34; target=&#34;_blank&#34;&gt;CLion blog&lt;/a&gt;: Các tin tức liên quan đến C++.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cpphints.com/&#34; target=&#34;_blank&#34;&gt;Cpp Hints&lt;/a&gt;: Phân tích các lỗi trong các dự án mã nguồn mở sử dụng C++.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.facebook.com/MeetingCpp?fref=nf&#34; target=&#34;_blank&#34;&gt;Meeting Cpp&lt;/a&gt;: cập nhật các bài viết về C++.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.pycoders.com/&#34; target=&#34;_blank&#34;&gt;Pycoder&lt;/a&gt;: cuối thứ 6 nào cũng dành thời gian đọc tin. Mục tiêu là trở thành Full Stack Devloper mà lị.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://javascriptweekly.com/&#34; target=&#34;_blank&#34;&gt;Javascript Weekly&lt;/a&gt;: trang này rất giàu thông tin, tuần nào cũng cập nhật về các tin tức liên quan đến Javascript và web dev.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Một số blog của các cao thủ võ lâm ở Việt Nam cũng thường xuyên cập nhật công nghệ và các kỹ thuật mới. Blog của &lt;a href=&#34;http://www.quan404.com/&#34; target=&#34;_blank&#34;&gt;Quan 404&lt;/a&gt; là một site điển hình. Tuy trang này khá mới, nhưng những bài viết khá là chất và bám sát các công nghệ hiện là state-of-the-art.&lt;/p&gt;

&lt;p&gt;Một số trang khá là vui mà mình cũng hay follow:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://xkcd.com/&#34; target=&#34;_blank&#34;&gt;XKCD&lt;/a&gt;: đơn giản đó là những gì lãng mạn, châm biếm, toán học và ngôn ngữ. Comic có vài hình mà độ hại não cao.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://phdcomics.com/comics.php&#34; target=&#34;_blank&#34;&gt;PHD Comics&lt;/a&gt;: ai làm research nhiều sẽ thấu hiểu những gì mà comic này đề cập, rất hài hước.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;tổng-kết&#34;&gt;Tổng kết&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://www.makemark.co.uk/wp-content/uploads/2011/05/infooverload_full.jpg&#34; alt=&#34;Information Overload&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Internet mở ra cho mọi người một cổng thông tin tuyệt vời. Nhưng đó cũng chính là vấn đề, đôi khi chúng ta bị “ngập ngụa” trong mớ thông tin mà không biết cái nào đáng dành thời gian để đọc. Điều cần thiết khi truy cập thông tin đó là xác định bản thân mình đang muốn tập trung vào mảng nào, tìm kiếm các nguồn kênh đáng tin cậy, đọc một cách đào sâu và nghiên cứu kỹ, đồng thời trao đổi, chia sẻ và đánh giá các bài viết. Điều đó giúp ta có thể không follow nhiều trang tin tức, nhưng kiến thức và thông tin của bản thân được trao dồi. Tập trung vào chất lượng hơn số lượng là một bước đi khôn ngoan trong kỷ nguyên số này.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Quy Trình Xin Tài Trợ NAFOSTED</title>
      <link>http://dangkhoasdc.github.io/post/blog/nafosted_travel_fund/</link>
      <pubDate>Sun, 23 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/blog/nafosted_travel_fund/</guid>
      <description>

&lt;p&gt;&lt;div class=&#34;entry&#34;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://phdcomics.com/comics/archive/phd102698s.gif&#34; alt=&#34;comics&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;tiêu-chí&#34;&gt;Tiêu chí&lt;/h2&gt;

&lt;p&gt;Để đảm bảo hồ sơ được duyệt, bài báo và hội nghị tham dự phải đạt một số tiêu chí mà Quỹ đưa ra:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Nhà khoa học đang thực hiện đề tài do Quỹ hỗ trợ, hoặc Nhà khoa học là người dưới 35 tuổi.&lt;/li&gt;
&lt;li&gt;Quỹ đánh giá hội nghị dựa trên lịch sử của hội nghị, uy tín của đơn vị tài trợ hội nghị, uy tính của các nhà khoa học khách mời hay uy tính của ban tổ chức.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ưu tiên&lt;/strong&gt;: Hội nghị được liệt kê trong danh sách của Thomson Reuters hoặc bảng xếp hạng của ERA.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ưu tiên&lt;/strong&gt;: Người xin tài trợ là keynote speaker, track chair/co-chair, hoặc được giải thưởng bài báo xuất sắc.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;quy-trình&#34;&gt;Quy trình&lt;/h2&gt;

&lt;p&gt;Tổng thời gian NAFOSTED duyệt, chấp nhận và xử lý hồ sơ trung bình mất từ 1-2 tháng. Hồ sơ xin tài trợ của NAFOSTED bao gồm:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Đơn đề nghị tài trợ có xác nhận của cơ quan, tổ chức nơi công tác.&lt;/li&gt;
&lt;li&gt;Thông báo của Ban tổ chức kèm theo địa chỉ trang web giới thiệu về hội nghị, hội thảo;&lt;/li&gt;
&lt;li&gt;Thư mời tham dự và trình bày báo cáo khoa học tại hội nghị, hội thảo;&lt;/li&gt;
&lt;li&gt;Báo cáo khoa học sẽ trình bày tại hội nghị, hội thảo;&lt;/li&gt;
&lt;li&gt;Lý lịch khoa học của người nộp đơn đề nghị tài trợ;&lt;/li&gt;
&lt;li&gt;Dự toán kinh phí đề nghị Quỹ tài trợ, trong đó nêu rõ các khoản chi phí được ban tổ chức hội nghị, hội thảo hoặc các tổ chức khác cam kết tài trợ - nếu có.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Tất cả tài liệu này phải được điền đầy đủ, có chữ ký của cá nhân và xác nhận của cơ quan đang làm việc/học tập, sau đó gửi đường bưu chính đến địa chỉ: &lt;strong&gt;Tầng 4, Số 39 Trần Hưng Đạo, P. Hàng Bài, Q. Hoàn Kiếm, Hà Nội.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Các tài liệu (1), (5) và (6) có &lt;a href=&#34;http://www.nafosted.gov.vn/vi/chuong-trinh-tai-tro/Ho-tro-nghien-cuu-khoa-hoc/Chuong-trinh-ho-tro-nghien-cuu-khoa-hoc-1/&#34; target=&#34;_blank&#34;&gt;mẫu từ website chính thức của Quỹ&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Tài liệu (3): trong thư mời phải đề cập rõ ràng đây công trình khoa học được công bố dạng báo cáo, không phải dạng poster. Quỹ còn bắt buộc trong thư mời phải đề cập đến chi tiết &lt;strong&gt;oral presentation&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Tài liệu (4): Gửi kèm email thông báo và các đánh giá của hội nghị.&lt;/p&gt;

&lt;p&gt;Khoảng một tuần sau khi gửi hồ sơ thì bên Quỹ sẽ liên lạc và yêu cầu cập nhật hoặc chỉnh sửa một số hồ sơ. Trong đó chủ yếu liên qua đến Dự Toán Kinh Phí (Tài liệu 6). Bên Quỹ sẽ thanh toán tiền vé máy bay, tuy nhiên người xin tài trợ có thể nhờ thay đổi chuyến bay hoặc thay đổi hãng bay để phù hợp hoặc cân đối các khoản chi phí. Người xin tài trợ có thể được Quỹ hỗ trợ tối đa trong 5 ngày, tuy nhiên nếu người xin tài trợ ở lại lâu hơn, thì những ngày còn lại sẽ không nằm trong phần hỗ trợ của Quỹ. Thông tin chi tiết về các khoản trong tài liệu này được trình bày cụ thể trong thông tư &lt;strong&gt;102/2012/TT-BTC&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Điểm lưu ý là toàn bộ tiền hỗ trợ được tính bằng đơn vị USD và sau đó khi quyết toán được quy đổi theo tỉ giá VND và USD. Kể cả khi tham dự hội nghị ở các nước không dùng đồng USD thì các khoản chi phí trong dự trù bắt buộc phải đổi sang USD.&lt;/p&gt;

&lt;p&gt;Trong trường hợp được hỗ trợ, NAFOSTED sẽ thanh toán trước tiền vé máy bay. Tất cả các khoản tiền còn lại sẽ được NAFOSTED quyết toán sau. Trong quá trình tham dự hội nghị, người báo cáo phải xin hoá đơn có con dấu (xanh hoặc đỏ) hoặc có chữ ký xác nhận của thư kí hội nghị.&lt;/p&gt;

&lt;p&gt;Khi hoàn tất chuyến báo cáo hội nghị, người báo cáo phải nộp lại hồ sơ (gửi đường bưu điện) các hồ sơ sau:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Vé lên máy bay (boarding pass).&lt;/li&gt;
&lt;li&gt;Hoá đơn của hội nghị.&lt;/li&gt;
&lt;li&gt;Chứng nhận tham dự hội nghị.&lt;/li&gt;
&lt;li&gt;Hợp đồng bảo hiểm.&lt;/li&gt;
&lt;li&gt;Bản photo Passport.&lt;/li&gt;
&lt;li&gt;Dự toán kinh phí được hiệu chính lại. Thông thường sẽ không khác so với bản trước đó nhưng có thể thay đổi liên quan đến tỉ giá hiện tại hoặc các chi phí phát sinh.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Sau khi gửi toàn bộ hồ sơ này đến Quỹ, Quỹ sẽ giải quyết và sẽ có thông báo danh sách được quyết toán của Quỹ. Trong khoảng 1 tuần kể từ sau khi có thông báo, tiền hỗ trợ sẽ được gửi vào tài khoản ngân hàng.&lt;/p&gt;

&lt;h2 id=&#34;kinh-nghiệm-cá-nhân&#34;&gt;Kinh nghiệm cá nhân&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Thương lượng về vé máy bay để có thể có vé rẻ hơn, thay đổi thời gian bay để có thể ở lại hội nghị lâu hơn.&lt;/li&gt;
&lt;li&gt;Khi xin giấy chứng nhận tham dự hội nghị và hoá đơn thì xin con dấu và &lt;strong&gt;kèm cả chữ ký của thư ký hội nghị&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Nộp đơn hội nghị trước 2 tháng để đảm bảo cập nhật kịp hồ sơ.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;nguồn-tham-khảo&#34;&gt;Nguồn tham khảo&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.nafosted.gov.vn/vi/chuong-trinh-tai-tro/Ho-tro-nghien-cuu-khoa-hoc/Chuong-trinh-ho-tro-nghien-cuu-khoa-hoc-1/&#34; target=&#34;_blank&#34;&gt;NAFOSTED&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.moit.gov.vn/vn/pages/VanBanDieuHanh.aspx?TypeVB=1&amp;amp;vID=11930&#34; target=&#34;_blank&#34;&gt;Thông tư 102/2012/TT-BTC&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Review Refactoring</title>
      <link>http://dangkhoasdc.github.io/post/blog/refactoring-review/</link>
      <pubDate>Sun, 23 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/blog/refactoring-review/</guid>
      <description>

&lt;p&gt;Mình quyết định đọc cuốn &lt;a href=&#34;https://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672&#34; target=&#34;_blank&#34;&gt;Refactoring: Improving the Design of Existing Code&lt;/a&gt; sau khi đọc xong cuốn &lt;em&gt;Design Pattern&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&#34;sơ-lược&#34;&gt;Sơ lược&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;http://d.gr-assets.com/books/1386925632l/44936.jpg&#34; alt=&#34;Refactoring: Improving the Design of Existing Code&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Mặc dù đã được nghe đến khái niệm này rất nhiều lần, tuy nhiên sau khi đọc xong cuốn sách, đối chiếu với những trải nghiệm của bản thân về các project trước đây. Mình hiểu:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Refactor là quá trình thao tác trên mã nguồn có sẵn nhằm gia tăng chất lượng mã nguồn nhưng vẫn giữ lại được các ràng buộc của hệ thống.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Như vậy, &lt;em&gt;refactor&lt;/em&gt; không phải quá trình tạo mới hoàn toàn một dự án hay một hệ thống nào cả, mà nhằm làm tăng &lt;em&gt;chất lượng&lt;/em&gt; của mã nguồn đó. &lt;em&gt;Chất lượng&lt;/em&gt; ở đây được đánh giá trên các độ đo khác nhau:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Khả năng mở rộng của mã nguồn.&lt;/li&gt;
&lt;li&gt;Khả năng dễ đọc và tìm lỗi.&lt;/li&gt;
&lt;li&gt;Khả năng thích ứng với lỗi (tính robustness)&lt;/li&gt;
&lt;li&gt;Hiệu suất của hệ thống.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ngoài việc làm gia tăng chất lượng của hệ thống, bên cạnh đó &lt;em&gt;refactor&lt;/em&gt; phải đảm bảo giữ lại được các ràng buộc mà trước đó hệ thống đã có. Ví dụ như:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Những APIs đã được phát hành của hệ thống, ta không nên &lt;em&gt;refactor&lt;/em&gt; và thay đổi luôn các APIs đó.&lt;/li&gt;
&lt;li&gt;Những &lt;em&gt;class&lt;/em&gt;, &lt;em&gt;functions&lt;/em&gt; liên hệ trực tiếp đến các modules khác trong hệ thống lớn hơn.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;những-kĩ-thuật-trong-refactor&#34;&gt;Những kĩ thuật trong refactor&lt;/h1&gt;

&lt;p&gt;Một phần quan trọng của cuốn sách không chỉ nói về định nghĩa của &lt;em&gt;refactor&lt;/em&gt; mà còn đề cập đến lí do vì sao cần &lt;em&gt;refactor&lt;/em&gt;, khi nào nên &lt;em&gt;refactor&lt;/em&gt;, những tác động nào ảnh hưởng đến quá trình &lt;em&gt;refactor&lt;/em&gt;, và đặc biệt là &lt;em&gt;xây dựng bộ test cho hệ thống&lt;/em&gt;. Trước giờ mình chủ yếu làm các hệ thống trong academic, việc xây dựng các bộ test không được chú trọng quá nhiều. Nhưng thực sự đọc xong cuốn sách mình nghĩ mình nên tập các viết các bộ test trước khi viết một function nào đó. Việc &lt;em&gt;tự tay&lt;/em&gt; viết các bộ test mang lại khá nhiều thuận lợi:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Giúp người thiết kế biết được giao diện tương tác API mà function mình đảm nhiệm.&lt;/li&gt;
&lt;li&gt;Hiểu được các ràng buộc về Input/Output và tham số.&lt;/li&gt;
&lt;li&gt;Thuận lợi cho việc refactor, các bộ test sẽ giúp ta kiểm tra xem việc vừa refactor xong có ảnh hưởng gì đến hệ thống hiện có không.&lt;/li&gt;
&lt;li&gt;Hình thành được outline của hệ thống trong quá trình xây dựng bộ test.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Cuốn sách được bố cục phần nào giống với bên &lt;em&gt;Design Pattern&lt;/em&gt;, cung cấp một lượng lớn &lt;em&gt;từ vựng&lt;/em&gt; về các kĩ thuật refactor. Với mỗi kĩ thuật được đề cập, tác giả nêu lên: động lực sử dụng, ví dụ minh họa, các lưu ý. Các kĩ thuật refactor được chia thành các category&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Thao tác trên các method trong 1 class.&lt;/li&gt;
&lt;li&gt;Thao tác trên các method giữa các class với nhau.&lt;/li&gt;
&lt;li&gt;Tổ chức dữ liệu.&lt;/li&gt;
&lt;li&gt;Đơn giản hóa các câu lệnh điều kiện.&lt;/li&gt;
&lt;li&gt;Đơn giản hóa các hàm.&lt;/li&gt;
&lt;li&gt;Tái tổ chức hệ thống class.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cuối cùng là những thao tác refactor ảnh hưởng đến các ràng buộc của hệ thống, đây là những thao tác sẽ ảnh hưởng lên đến việc tương tác giữa các hệ thống với nhau nên cần suy nghĩ cẩn trọng trước khi thực hiện.&lt;/p&gt;

&lt;p&gt;Phần cuối cùng là các công cụ refactor, mình nghĩ phần nào không cần nói nhiều vì trên các IDE nổi tiếng như &lt;em&gt;Visual Studio&lt;/em&gt;, &lt;em&gt;Eclipse&lt;/em&gt;, &lt;em&gt;IntelIJ&lt;/em&gt; thì các kĩ thuật refactor đã trở thành những tính năng khá quen thuộc. Việc refactor tự động giúp tránh xảy ra lỗi và giảm thời gian cho công việc này khá nhiều.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Nếu có hành động nào đó lặp đi lặp lại trên 5 lần. Tốt hơn là ta nên làm cách khiến nó thành tự động.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;bình-luận&#34;&gt;Bình luận&lt;/h1&gt;

&lt;p&gt;Đây là cuốn sách cuối cùng mình đọc liên quan đến công nghệ phần mềm trước khi đến với phần thử thách với mình nhiều hơn: Machine Learning và Computer Vision.&lt;/p&gt;

&lt;p&gt;Cuốn sách đặc biệt phù hợp với các bạn sinh viên năm 3, 4 sau khi đã học về lập trình hướng đối tượng cũng như đã trải qua một thời gian tiếp xúc với những mã nguồn, dự án có sẵn. Thời gian đọc có lẽ mất từ 5-7 ngày.&lt;/p&gt;

&lt;p&gt;Điều thú vị khi mình đọc đó là cảm giác:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;wtf?? đổi tên biến cũng được gọi là refactor wtf?? đổi tên hàm cũng vậy …&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Mình nghiệm ra, refactor không phải là cái gì đó quá cao siêu, có lẽ bạn nào lập trình cũng đã từng thực hiện một lần. Nhưng refactor như thế nào hiệu quả, tốn ít thời gian và công sức và hơn hết là biết cách refactor là một chuyện khác.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Refactoring&lt;/em&gt; là cuốn sách sẽ giải đáp những điều đó.&lt;/p&gt;

&lt;h1 id=&#34;future-works&#34;&gt;Future Works&lt;/h1&gt;

&lt;p&gt;Mình đã đọc xong cuốn &lt;em&gt;Design Patterns&lt;/em&gt; nhưng chưa biết review thế nào. Có lẽ cần nhiều thời gian hơn để có thể viết về các mẫu. Nhưng có lẽ mình không tập trung nhiều thời gian.&lt;/p&gt;

&lt;p&gt;Kế hoạch sắp đến: &lt;em&gt;Pattern Recognition and Machine Learning&lt;/em&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Review Start Wars series</title>
      <link>http://dangkhoasdc.github.io/post/blog/startwars-series-review/</link>
      <pubDate>Sun, 23 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/blog/startwars-series-review/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://www.blastr.com/sites/blastr/files/star_wars_vii-02.jpg&#34; alt=&#34;Star Wars: Biểu tượng của văn hoá POP&#34; /&gt; Mình đã giành một ngày cuối tuần và dịp nghỉ lễ để ngồi xem 3 phần của Star Wars: 4, 5 và 6. Đánh giá sơ bộ về bộ phim thì nếu đặt bản thân vào thời điểm bộ phim được ra mắt thì đúng là một kiệt tác. Giờ mình xem vẫn còn rất ấn tượng với kĩ xảo được thực hiện trong phim. Theo như mình biết về 3D và các hiệu ứng hình ảnh vào thời điểm đó để dựng nên những mô hình 3D phi thuyền hay các loài ở các hành tinh là điều không thể. Và đúng như vậy, hầu hết các &lt;a href=&#34;https://www.youtube.com/watch?v=mIlYk7KQe-s&#34; target=&#34;_blank&#34;&gt;hiệu ứng hình ảnh không đến từ đồ hoạ máy tính&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;cốt-truyện&#34;&gt;Cốt truyện&lt;/h1&gt;

&lt;p&gt;Cốt truyện của Star wars thực sự không quá hại não, kết cấu chặt chẽ với tình tiết trong phim luôn diễn ra liên tục khiến người xem hồi hộp theo dõi theo cuộc hành trình của các nhân vật. Tuy nhiên vì series này được sản xuất khá là lâu nên tốc độ phim tương đối chậm, đôi lúc dễ bị mất tập trung, nhưng nhìn chung rất cuốn hút. Mình nghĩ đây cũng là một điểm mạnh khiến cho bộ phim được cuồng đến vậy. Nội dung khó quá phức tạp và dành cho mọi lứa tuổi nên dễ đi vào lòng người. Kết hợp với các yếu tố giả tưởng, khoa học thì Star Wars xứng đáng là một hiện tượng của văn hoá Pop.&lt;/p&gt;

&lt;p&gt;Một điểm mạnh của dòng phim này có lẽ là việc &lt;a href=&#34;https://www.pinterest.com/visualoop/star-wars-infographics/&#34; target=&#34;_blank&#34;&gt;xây dựng vũ trụ&lt;/a&gt; với việc xây dựng câu chuyện là cuộc chiến trong toàn cõi thiên hà của bên Kháng Chiến chống lại Đế Quốc, người viết truyện và cả khán giả tha hồ chìm đắm vào trong thế giới sci-fi đầy mê hoặc này. Và như vậy sự phức tạp trong hệ thống hành tinh, thể chế, cuộc sống ở mỗi hệ thiên hà cũng vì thế trở nên đa dạng. Thử so sánh với một dòng &lt;em&gt;chiến tranh vũ trụ&lt;/em&gt; mà mình rất thích là StarCraft thì SC thì mới là câu chuyện xoay quanh &lt;a href=&#34;http://sea.battle.net/sc2/en/game/planet/&#34; target=&#34;_blank&#34;&gt;khu vực Koprulu&lt;/a&gt; và ba chủng tộc chính Terran, Zerg và Protoss. Trong khi đó trong 3 bộ phim Star Wars là ta đã thấy bao nhiêu chủng tộc với biết bao điều lý thú.&lt;/p&gt;

&lt;h1 id=&#34;nhân-vật&#34;&gt;Nhân Vật&lt;/h1&gt;

&lt;p&gt;Mình không thích đồng chí Luke, hoặc cũng có thể là do mình đã thấy rất nhiều nhân vật có cốt truyện na ná giống giống ở khắp các thế giới tưởng tượng như Frodo trong Chúa Tể Những Chiếc Nhẫn, Harry Potter… trong thần thoại Hy Lạp và của trong Dune (sẵn tiện Star Wars lấy cảm hứng từ Dune) thành thử ra mình không bất ngờ lắm với độ trẻ trâu của nhân vật và được buff niềm tin như vậy. Sẵn bàn về những hero, thực ra những hero này luôn có một &lt;em&gt;công thức&lt;/em&gt; được &lt;a href=&#34;https://www.youtube.com/watch?v=Hhk4N9A0oCA&#34; target=&#34;_blank&#34;&gt;xây dựng và một mẫu hình chung&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.themarysue.com/wp-content/uploads/2015/03/leia.jpg&#34; alt=&#34;Công chúa Leia&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Trong khi đó mình rất thích thích công chúa Leia và Han Solo. Và mình cá là những thánh cuồng scifi, thể loại viễn tưởng phiêu lưu thì Leia là mẫu con gái trong mộng. Một minh chứng rõ ràng còn ảnh hưởng cả đến văn hoá Pop là anh Ross nhà ta còn nói bạn gái mặc bộ &lt;a href=&#34;https://www.youtube.com/watch?v=9hLcsLFgLC8&#34; target=&#34;_blank&#34;&gt;bikini của Leia trong Return of The Jedi&lt;/a&gt;. Cả tác giả của Doreamon cũng lấy thỉnh thoảng lấy hình tượng nàng công chúa này nữa. Nàng công chúa trong Star Wars bản lĩnh, lãnh đạo quân Kháng Chiến chống lại Đê Quốc nhưng cũng có những khoảnh khắc rất đáng yêu. Han Solo thì là chàng cao bồi vũ trụ, luôn lạc quan trong những lúc khó khăn nhất. Tình cảm của hai người được xây dựng nhẹ nhàng, đáng yêu và liền mạch với câu chuyện.&lt;/p&gt;

&lt;p&gt;Các nhân vật khác đều có chiều sâu trong tính cách cũng như về cuộc đời như thầy Yoda và thầy Kenobi cũng như các nhân vật phản diện khác.&lt;/p&gt;

&lt;h1 id=&#34;tổng-kết&#34;&gt;Tổng kết&lt;/h1&gt;

&lt;p&gt;Đây là một seri rất đáng xem, giới thiệu cho khán giả về thế giới Star Wars vô cùng rộng lớn với những cuộc phiêu lưu đầy thú vị. Xem xong mới chỉ 3 tập nhưng mình đã hiểu vì sao khán giả khắp nơi lại cuồng đến vậy, nhà nhà người người đều &lt;a href=&#34;http://tuoitre.vn/tin/van-hoa-giai-tri/dien-anh/20151220/tong-thong-obama-cac-ban-a-toi-phai-di-xem-star-wars-day/1024117.html&#34; target=&#34;_blank&#34;&gt;bàn tán về Star Wars đến vậy&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Sử dụng Protocol Buffers trong C&#43;&#43; và Caffe</title>
      <link>http://dangkhoasdc.github.io/post/blog/protocol-buffers-caffe/</link>
      <pubDate>Sun, 23 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/blog/protocol-buffers-caffe/</guid>
      <description>

&lt;h5 id=&#34;protocol-buffers-protobuf-hay-pb-là-một-trong-những-thành-phần-quan-trọng-trong-thư-viện-caffe-http-caffe-berkeleyvision-org-bài-viết-dưới-đây-là-một-số-note-và-cách-sử-dụng-protocol-buffers-trong-ngôn-ngữ-c-mục-tiêu-ban-đầu-chủ-yếu-tìm-hiểu-xem-khả-năng-tuỳ-chỉnh-của-caffe-đến-đâu&#34;&gt;Protocol Buffers (ProtoBuf hay PB) là một trong những thành phần quan trọng trong thư viện &lt;a href=&#34;http://caffe.berkeleyvision.org/&#34; target=&#34;_blank&#34;&gt;Caffe&lt;/a&gt;. Bài viết dưới đây là một số note và cách sử dụng Protocol Buffers trong ngôn ngữ C++. Mục tiêu ban đầu chủ yếu tìm hiểu xem khả năng tuỳ chỉnh của Caffe đến đâu.&lt;/h5&gt;

&lt;h1 id=&#34;giới-thiệu&#34;&gt;Giới thiệu&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34; target=&#34;_blank&#34;&gt;Protocol Buffers&lt;/a&gt; là một cơ chế lưu trữ và thao tác dành cho dữ liệu có cấu trúc do Google phát triển. Protocol Buffers có thể so sánh giống như XML, tuy nhiên PB có một số ưu điểm (theo quảng cáo của Google): tiện hơn, nhẹ hơn (từ 3 đến 10 lần so với XML), thao tác đọc ghi nhanh hơn (20 đến 100 lần nhanh hơn so với XML) và dễ dàng hơn. Protocol Buffers cho phép người dùng thiết kế dữ liệu và sử dụng code tự động phát sinh để đọc ghi các dữ liệu đó.&lt;/p&gt;

&lt;h1 id=&#34;cơ-chế&#34;&gt;Cơ chế&lt;/h1&gt;

&lt;p&gt;Người dùng định nghĩa cấu trúc dữ liệu của mình trong file &lt;code&gt;.proto&lt;/code&gt;. Trong đó định nghĩa kiểu dữ liệu, ràng buộc của các thuộc tính cũng như cấu trúc (mảng hay giá trị scalar). Trình biên dịch PB sẽ dịch file &lt;code&gt;.proto&lt;/code&gt; thành một file mà ngôn ngữ lập trình đọc được (trong trường hợp C++ là file &lt;code&gt;.h&lt;/code&gt;) giúp lập trình viên thao tác trên dữ liệu được thiết kế trước đó. Và như vậy, thay vì tự thiết kế 1 dữ liệu bằng chính ngôn ngữ lập trình, và tốn thêm thời gian để viết các cơ chế đọc ghi, chuyển đổi dữ liệu hay chuyển từ định dạng này (text) sang định dạng khác (binary), ProtoBuf sẽ tự động sinh code cho những thao tác này.&lt;/p&gt;

&lt;h1 id=&#34;trong-caffe&#34;&gt;Trong Caffe&lt;/h1&gt;

&lt;p&gt;Protocol Buffers đóng vai trò khá quan trọng trong thư viện &lt;a href=&#34;https://github.com/BVLC/caffe&#34; target=&#34;_blank&#34;&gt;Caffe&lt;/a&gt;. Nếu không sử dụng PB thì Caffe trở thành một thư viện rất khó xài bởi nhiều lí do:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Không có tài liệu cụ thể để tuỳ chỉnh các layer hay tự thiết kế mạng cho riêng hệ thống. Vấn đề này được giải quyết đơn giản nhờ PB. PB cho phép cá c tác giả của Caffe tạo ra các dữ liệu dùng cho hệ thống này (Solver, Layer, Net, …). Những ai dùng Caffe chỉ cần bỏ chút thời gian để đọc lại đoạn thiết kế trong &lt;a href=&#34;https://github.com/BVLC/caffe/blob/master/src/caffe/proto/caffe.proto&#34; target=&#34;_blank&#34;&gt;file &lt;code&gt;proto&lt;/code&gt; này&lt;/a&gt; đã được comment khá đầy đủ và chi tiết. Nhờ việc open source phần này nên các nhóm nghiên cứu khác có khả năng custom bằng cách thêm các Layer hoặc thêm các hàm vàotrong hệ thống Caffe.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Khả năng không custom cao: việc tạo ra một kiến trúc mới khá dễ dàng nhờ vào PB. Việc thiết kế một mạng giờ đây giống như một trò xếp hình với các khối là những kiểu dữ liệu được thiết kế trong ProtoBuf [Hình 1]. Một ví dụ kinh điển là sử dụng Caffe để &lt;a href=&#34;http://caffe.berkeleyvision.org/gathered/examples/mnist.html&#34; target=&#34;_blank&#34;&gt;thiết kế mạng LeNet&lt;/a&gt;. Người nghiên cứu không phải quá nặng đầu hay nhũn não để viết code C++ hay Matlab hay Python hay Cuda để thiết kế mạng mà thay vào đó là viết một kiến trúc trong file &lt;code&gt;prototxt&lt;/code&gt; như thiết kế một cấu trúc XML hoặc JSON. Tác giả Caffe cũng không nhũn não khi ngồi parse từ file text sang kiểu dữ liệu của mình.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/chfn2ch.png&#34; alt=&#34;Mạng Deep Learning&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;cài-đặt&#34;&gt;Cài đặt&lt;/h1&gt;

&lt;p&gt;Clone mã nguồn của &lt;a href=&#34;https://github.com/google/protobuf&#34; target=&#34;_blank&#34;&gt;ProtoBuf tại Github&lt;/a&gt;, sau đó cài theo lệnh&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ./autogen.sh
    ./configure
    make
    make install

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;thiết-kế-dữ-liệu&#34;&gt;Thiết kế dữ liệu&lt;/h1&gt;

&lt;p&gt;Dữ liệu được thiết kế trong một file &lt;code&gt;proto&lt;/code&gt;. Dưới đây là ví dụ trong website của Google, mục đích để quản lý danh bạ điện thoại.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-protocol-buffers&#34;&gt;    package tutorial;

    message Person {
      required string name = 1;
      required int32 id = 2;
      optional string email = 3;

      enum PhoneType {
        MOBILE = 0;
        HOME = 1;
        WORK = 2;
      }

      message PhoneNumber {
        required string number = 1;
        optional PhoneType type = 2 [default = HOME];
      }

      repeated PhoneNumber phone = 4;
    }

    message AddressBook {
      repeated Person person = 1;
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Để biên dịch file này, ta gõ lệnh&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    protoc -I=$SRC_DIR --cpp_out=$DST_DIR $SRC_DIR/addressbook.proto
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Trong đó &lt;code&gt;$SRC_DIR&lt;/code&gt; là thư mục chứa mã nguồn, &lt;code&gt;$DST_DIR&lt;/code&gt; là thư mục chứa các code cpp mà ProtoBuf sẽ phát sinh, &lt;code&gt;addressbook.proto&lt;/code&gt; là file chứa dữ liệu danh bạ. Trước khi xem thử trong ProtoBuf viết cái chi chi, ta xem thử ProtoBuf đã phát sinh ra 2 file &lt;code&gt;addressbook.pb.cc&lt;/code&gt; và &lt;code&gt;addressbook.pb.h&lt;/code&gt;. Trong đó chứa tất cả phần định nghĩa và cài đặt của các Lớp đối tượng Person, PhoneNumber. Chính xác là ProtoBuf đã &lt;em&gt;làm giúp&lt;/em&gt; dev chuyện thiết kế lớp, viết phần truy xuất và chuyển đổi kiểu dữ liệu, thao tác các thuật tính (kiểm tra thuộc tính, getter và setter). Xong, ta quay lại phần thiết kế của ProtoBuf.&lt;/p&gt;

&lt;h1 id=&#34;cú-pháp&#34;&gt;Cú pháp&lt;/h1&gt;

&lt;p&gt;Trong bài viết mình chỉ giới thiệu rất vắn tắt về các từ khoá sử dụng trong ProtoBuf nhằm có thể tìm hiểu cơ chế thiết kế dữ liệu trong Caffe. Chi tiết hơn về cứ pháp ngôn ngữ này có thể tham khảo ở &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3&#34; target=&#34;_blank&#34;&gt;trang tài liệu của ProtoBuf&lt;/a&gt;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;package&lt;/code&gt;: tương đương với namespace trong C++.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;message&lt;/code&gt;: tương đương với Class trong C++.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int32&lt;/code&gt; ,&lt;code&gt;string&lt;/code&gt; , &lt;code&gt;enum&lt;/code&gt;: tương đương với các kiểu dữ liệu trong C++. Ngoài ra trong ProtoBuf còn có &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Các giá trị 1, 2, … đằng sau các khai báo: các tag phân biệt nhau trong một message.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Có 3 modifier như sau: &lt;code&gt;required&lt;/code&gt;, &lt;code&gt;optional&lt;/code&gt;, &lt;code&gt;repeated&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;a. &lt;code&gt;required&lt;/code&gt;: trường bắt buộc phải tồn tại trong 1 lớp.
b. &lt;code&gt;optional&lt;/code&gt;: trường có thể tồn tại hoặc không trong một lớp.
c. &lt;code&gt;repeated&lt;/code&gt;: trường là một mảng động (không có phần tử nào hoặc có 1 hay nhiều phần tử).&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;trong-caffe-1&#34;&gt;Trong Caffe&lt;/h2&gt;

&lt;p&gt;Bây giờ quay trở lại &lt;a href=&#34;https://github.com/BVLC/caffe/blob/master/src/caffe/proto/caffe.proto&#34; target=&#34;_blank&#34;&gt;file &lt;code&gt;proto&lt;/code&gt; của Caffe&lt;/a&gt; và dường như mọi thứ đã quá rõ ràng. Với mỗi hàm activation, hàm loss, các Layer (convolution, reshape, filter, …) và Blob (chứa dữ liệu) Caffe thiết kế các lớp chính là nơi chứa các tham số cho các hàm, layer và data này.&lt;/p&gt;

&lt;p&gt;Một điều khá thú vị đó là thư viện &lt;a href=&#34;https://www.tensorflow.org/&#34; target=&#34;_blank&#34;&gt;TensorFlow&lt;/a&gt; của Google cũng sử dụng ProtoBuf cho project của họ.&lt;/p&gt;

&lt;p&gt;Nếu như chú ý kĩ, trên website của Caffe không liệt kê toàn bộ các tham số có thể cấu hình cho các Layer trong thiết kế mạng. Có thể kể đến ở đây như &lt;a href=&#34;http://caffe.berkeleyvision.org/tutorial/data.html&#34; target=&#34;_blank&#34;&gt;Data Layer&lt;/a&gt;, trong tham số transform_data có &lt;code&gt;scale&lt;/code&gt;, &lt;code&gt;mean_file_size&lt;/code&gt;, &lt;code&gt;mirror&lt;/code&gt; và &lt;code&gt;crop_size&lt;/code&gt;; nhưng nếu xem trong phần định nghĩa của protobuf, ta thấy ngoài ra còn có &lt;code&gt;mean_file&lt;/code&gt;, &lt;code&gt;mean_value&lt;/code&gt;, &lt;code&gt;force_color&lt;/code&gt; và &lt;code&gt;force_gray&lt;/code&gt;, qua đó ta thấy được rõ ràng xem protobuf có lợi hơn là xem trong phần documents. Một điểm thuận lợi khác là file &lt;code&gt;caffe.proto&lt;/code&gt; được cập nhật liên tục so với document trên website.&lt;/p&gt;

&lt;p&gt;Lấy một ví dụ minh hoạ trong mạng &lt;a href=&#34;https://github.com/BVLC/caffe/tree/master/models/bvlc_alexnet&#34; target=&#34;_blank&#34;&gt;AlexNet&lt;/a&gt;. Có 2 file prototxt rất đáng quan tâm và hầu như ở các model được cung cấp sẵn đều có đó là: &lt;code&gt;train_val.prototxt&lt;/code&gt; và &lt;code&gt;solver.txt&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;train-val-prototxt&#34;&gt;train_val.prototxt&lt;/h3&gt;

&lt;p&gt;Đây là file chứa kiến trúc mạng của mô hình được cung cấp. Trong này định nghĩa toàn bộ kiến trúc (các tầng, tham số của mỗi tầng) cũng như định nghĩa dữ liệu đầu vào và output đầu ra cho mạng deep.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;    name: &amp;quot;AlexNet&amp;quot;
    layer {
      name: &amp;quot;data&amp;quot;
      type: &amp;quot;Data&amp;quot;
      top: &amp;quot;data&amp;quot;
      top: &amp;quot;label&amp;quot;
      include {
        phase: TRAIN
      }
      transform_param {
        mirror: true
        crop_size: 227
        mean_file: &amp;quot;data/ilsvrc12/imagenet_mean.binaryproto&amp;quot;
      }
      data_param {
        source: &amp;quot;examples/imagenet/ilsvrc12_train_lmdb&amp;quot;
        batch_size: 256
        backend: LMDB
      }
    }
    layer {
      name: &amp;quot;data&amp;quot;
      type: &amp;quot;Data&amp;quot;
      top: &amp;quot;data&amp;quot;
      top: &amp;quot;label&amp;quot;
      include {
        phase: TEST
      }
      transform_param {
        mirror: false
        crop_size: 227
        mean_file: &amp;quot;data/ilsvrc12/imagenet_mean.binaryproto&amp;quot;
      }
      data_param {
        source: &amp;quot;examples/imagenet/ilsvrc12_val_lmdb&amp;quot;
        batch_size: 50
        backend: LMDB
      }
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thành phần đầu tiên là &lt;code&gt;name&lt;/code&gt;, tên của mạng. Các phần tử tiếp theo là các &lt;code&gt;layer&lt;/code&gt;, tất cả các tham số liên quan đến layer đều nằm trong khối ngoặc &lt;code&gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;{&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;w&amp;quot;&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;}&amp;lt;/span&amp;gt;&lt;/code&gt;. Có 3 thành phần chắc chắn có của một layer:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt;: tên của layer. Caffe dựa vào tên layer để xác định xem layer đó ở đâu trong mạng.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type&lt;/code&gt;: chắc chắn rồi, Caffe cần biết đây là layer Input hay là layer Convolution hay là ReLu hay là Softmax.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;top/bottom&lt;/code&gt;: xác định xem layer hiện tại sẽ nằm trên layer nào và sẽ nằm dưới layer nào. Vì kiến trúc mạng kiểu xếp tầng thế này rất thuận tiện để thiết kế mạng CNN. Và điểm bất lợi đó là ta khó có thể thiết kế các mạng có cấu trúc phức tạp hơn, kiểu như đồ thì chẳng hạn.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ngoài 3 thuộc tính kể trên, mỗi layer sẽ có những tham số khác, phụ thuộc vào loại layer và tính chât của layer đó trong mạng.&lt;/p&gt;

&lt;h3 id=&#34;solver-prototxt&#34;&gt;solver.prototxt&lt;/h3&gt;

&lt;p&gt;Đây là tập tin chứa tham số trong quá trình train mạng deep và các tham số trong quá trình forward cũng như lan truyền ngược.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;    net: &amp;quot;models/bvlc_alexnet/train_val.prototxt&amp;quot;
    test_iter: 1000
    test_interval: 1000
    base_lr: 0.01
    lr_policy: &amp;quot;step&amp;quot;
    gamma: 0.1
    stepsize: 100000
    display: 20
    max_iter: 450000
    momentum: 0.9
    weight_decay: 0.0005
    snapshot: 10000
    snapshot_prefix: &amp;quot;models/bvlc_alexnet/caffe_alexnet_train&amp;quot;
    solver_mode: GPU
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ta dễ dàng thấy ở đây có &lt;code&gt;net&lt;/code&gt;: dẫn đến file chứa kiến trúc mạng. Một số tham số khá quen thuộc như: &lt;code&gt;momentum&lt;/code&gt;, &lt;code&gt;max_iter&lt;/code&gt;, có cả một thuộc tính nhằm set xem mạng sẽ chạy ở GPU hay CPU (&lt;code&gt;solver_mode&lt;/code&gt;). Cũng giống như các tham số ở &lt;code&gt;train_val.prototxt&lt;/code&gt;, tất cả các thông tin về cấu hình được đề cập trong file &lt;code&gt;caffe.proto&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;tổng-kết&#34;&gt;Tổng kết&lt;/h2&gt;

&lt;p&gt;Protobuf đóng vai trò quan trọng trong công cụ Caffe, giúp các nhà nghiên cứu có thể dễ dàng xây dựng, chỉnh sửa, cũng như chia sẻ kiến trúc mạng của mình với cộng đồng. Ngoài ra protobuf còn giúp nhà lập trình dễ dàng trong quá trình xây dựng hệ thống phần mềm cũng như mã nguồn. Đối với người dùng, việc xem xét, hiệu chỉnh trên file prototxt thuận lợi và tốn ít công sức hơn so với đọc từ code C++ hay kể cả matlab, cũng như có một “ngôn ngữ chung” cho thiết kế mạng deep.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>constexpr: Hằng biểu thức trong C&#43;&#43;11</title>
      <link>http://dangkhoasdc.github.io/post/blog/constexpr/</link>
      <pubDate>Sun, 23 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/blog/constexpr/</guid>
      <description>

&lt;h2 id=&#34;constexpr&#34;&gt;constexpr&lt;/h2&gt;

&lt;p&gt;Đầu tiên ta xem xét động lực của việc tạo ra từ khoá mới này. Điều mà C++11 muốn tạo ra chính là &lt;strong&gt;tăng tốc hiệu suất của chương trình viết bằng ngôn ngữ này&lt;/strong&gt;. Ta quay một chút về cú pháp &lt;code&gt;define&lt;/code&gt; bất hủ của C, ưu điểm của phương pháp tạo macro chính là hiệu suất nhanh, các hàm được tạo ra trong lúc biên dịch và không tốn bộ nhớ cũng như các lệnh nhảy trong hàm. C++ cũng có tham vọng vậy, và mục tiêu của C++ chính là nếu một biến/hàm có thể tính toán được trong thời gian biên dịch thì tính luôn tại thời điểm đó. Và như vậy trong quá trình chạy chương trình sẽ không mất thêm thời gian tính toán hàm/biến này. Done! Thời gian thực thi chương trình được nhanh hơn.&lt;/p&gt;

&lt;div class=&#34;panel-body&#34;&gt;Nhìn đi nhìn lại mới thấy ngôn ngữ C được thiết kế rất hay, tinh giản nhưng mạnh mẽ. Để giải quyết vấn đề loại bỏ define trong C mà C++ đã chế ra const, inline và tá lả tùng xèn các thứ khác. Tuy nhiên cái gì cũng có hai mặt của vấn đề, với các từ khoá const, inline, ... thì việc người lập trình đỡ nhọc hơn về phần code (hạn chế được các lệnh define) nhưng để sử dụng tốt các tính năng của C++ khiến người lập trình phải hiểu rõ tính năng mà ngôn ngữ đó cung cấp.&lt;/div&gt;

&lt;h2 id=&#34;tầm-hoạt-động&#34;&gt;Tầm hoạt động&lt;/h2&gt;

&lt;p&gt;Từ khoá &lt;code&gt;constexpr&lt;/code&gt; được sử dụng cho 3 đối tượng như sau:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Hàm.&lt;/li&gt;
&lt;li&gt;Biến.&lt;/li&gt;
&lt;li&gt;Hàm khởi tạo.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Trong đó, nếu từ khoá này được dùng cho khai báo đối tượng hoặc biến thì đối tượng hoặc biến đó được ngầm hiểu là &lt;code&gt;const&lt;/code&gt;. Trong trường hợp là hàm, thì hàm đó được ngầm hiểu là 1 hàm &lt;code&gt;inline&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Quay lại câu chuyện vì sao có 3 ẻm này.&lt;/p&gt;

&lt;p&gt;Từ khoá &lt;code&gt;constexpr&lt;/code&gt; có hàm nghĩa hoàn toàn khác với &lt;code&gt;const&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;: không được thay đổi giá trị.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;constexpr&lt;/code&gt;: thực thi tại thời điểm biên dịch.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt; là từ khoá yêu cầu trình biên dịch tính toán phép tính hay biểu thức tại thời điểm biên dịch, trong khi đó &lt;code&gt;const&lt;/code&gt; là công cụ giúp trình biên dịch nhắc nhở người dùng những biến nào không được thay đổi giá trị (nó chỉ nhắc nhở, có nghĩa là nếu ta muốn đổi cũng ok). &lt;code&gt;constexpr&lt;/code&gt; liên quan mật thiết tới khái niệm &lt;em&gt;biểu thức hằng&lt;/em&gt; (constant expression). Vậy constant expression là gì?&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Biểu thức hằng là biểu thức mà trình biên dịch có thể tính toán được&lt;/em&gt;. Điều đó có nghĩa biểu thức hằng không thể thực thi nếu các biến/ toán tử trong biểu thức chưa được biết trong thời gian biên dịch, và biểu thức này không gây ra tác dụng phụ (&lt;a href=&#34;http://programmers.stackexchange.com/a/40314&#34; target=&#34;_blank&#34;&gt;side effect&lt;/a&gt;). Thêm vào đó, biểu thức hằng phải được cấu thành từ các giá trị nguyên, các số thực và kiểu liệt kê (enumerator), hay các tổ hợp của 3 kiểu dữ liệu này (một trong những cách tổ hợp là tạo ra 1 đối tượng giữ các giá trị này: &lt;code&gt;constexpr constructor&lt;/code&gt; ra đời là vì lí do này).&lt;/p&gt;

&lt;p&gt;Trong quá trình viết mã, người lập trình sẽ có yêu cầu đặt tên biến cho giá trị của biểu thức hằng (&lt;code&gt;constexpr function&lt;/code&gt; ra đời) hoặc các dữ liệu có trong biểu thức, và đây chính là lí do mà &lt;code&gt;constexpr variable&lt;/code&gt; ra đời. Ngoài việc đặt tên, biểu thức hằng còn có kha khá công dụng khác nhau như:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Sử dụng trong khai báo kích thước mảng, nhãn trong lệnh switch, tham số trong &lt;code&gt;template&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Trong các hệ thống nhúng, các giá trị &lt;em&gt;chỉ đọc&lt;/em&gt; các chi phí thấp hơn so với giá trị dữ liệu động. Ngoài ra dữ liệu chỉ đọc tránh được các lỗi trong hệ thống.&lt;/li&gt;
&lt;li&gt;Trong các hệ thống đa luồng, biểu thức hằng tránh được hiện tượng &lt;a href=&#34;http://docs.oracle.com/cd/E19205-01/820-0619/geojs/index.html&#34; target=&#34;_blank&#34;&gt;data race&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Tăng hiệu suất chương trình.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;constexpr-variable&#34;&gt;constexpr variable&lt;/h2&gt;

&lt;p&gt;Khi khai báo constexpr thì biến đó được hiểu là const - tức không thể thay đổi nội dung trong quá trình thực thi chương trình. Nhưng khác với const ở chỗ: constexpr là hằng ở quá trình biên dịch, và còn const thì được qui định trong quá trình thực thi.&lt;/p&gt;

&lt;p&gt;Để trở khai báo một biến là &lt;em&gt;constexpr&lt;/em&gt;, biến đó phải thoả mãn một số điều kiện sau:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Kiểu của biến phải thuộc &lt;a href=&#34;http://en.cppreference.com/w/cpp/concept/LiteralType&#34; target=&#34;_blank&#34;&gt;kiểu Literal&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Khi khai báo là biến &lt;em&gt;constexpr&lt;/em&gt;, biến đó phải được định nghĩa ngay trong thời điểm đó.&lt;/li&gt;
&lt;li&gt;Tham số của hàm khởi tạo trong kiểu của biến này phải chứa: (1) kiểu literal, (2) biến &lt;em&gt;constexpr&lt;/em&gt;, (3) hàm.&lt;/li&gt;
&lt;li&gt;Hàm khởi tạo của biến được khai báo phải thoả các điều kiện của &lt;strong&gt;constexpr constructor&lt;/strong&gt; và trong Kiểu/Lớp đó phải có hàm khởi tạo là &lt;strong&gt;constexpr constructor&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;constexpr-function&#34;&gt;constexpr function&lt;/h2&gt;

&lt;p&gt;Để khai báo là một &lt;strong&gt;constexpr function&lt;/strong&gt;, hàm này phải thoả những điều kiện sau:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Không phải là hàm ảo (&lt;a href=&#34;http://stackoverflow.com/questions/2391679/why-do-we-need-virtual-methods-in-c&#34; target=&#34;_blank&#34;&gt;virtual funciton&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;Kiểu trả về phải là LiteralType.&lt;/li&gt;
&lt;li&gt;Mỗi tham số đầu vào của hàm phải thuộc kiểu LiteralType.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Hàm chỉ được chứa các lệnh sau:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;state_assert.&lt;/li&gt;
&lt;li&gt;Chỉ có duy nhất 1 lệnh &lt;code&gt;return&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Lệnh Null, lệnh không thực hiện gì.&lt;/li&gt;
&lt;li&gt;Lệnh khai báo &lt;code&gt;typedef&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Khai báo sử dụng &lt;code&gt;using&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;constexpr-constructor&#34;&gt;constexpr constructor&lt;/h2&gt;

&lt;p&gt;Hàm khởi tạo &lt;em&gt;constexpr&lt;/em&gt; được xây dựng nhằm phục vụ cho các biến &lt;em&gt;constexpr&lt;/em&gt;, vì hàm khởi tạo cũng là hàm nên nó có những yêu cầu buộc thoả mãn giống như &lt;em&gt;constexpr function&lt;/em&gt;, ngoài ra &lt;em&gt;constexpr constructor&lt;/em&gt; còn phải thoả mãn một số điều kiện:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Lớp chứa hàm khởi tạo &lt;em&gt;constexpr&lt;/em&gt; có hàm cha không phải là Lớp ảo.&lt;/li&gt;
&lt;li&gt;Không phải hàm khởi tạo function-try-block.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;ghi-chú&#34;&gt;Ghi chú&lt;/h2&gt;

&lt;p&gt;Các thông tin trên được lấy từ chuẩn C++11, tuy nhiên trong C++14 có những thay đổi lớn sẽ được cập nhật sau.&lt;/p&gt;

&lt;h2 id=&#34;tham-khảo&#34;&gt;Tham khảo&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://en.cppreference.com/w/cpp/language/constexpr&#34; target=&#34;_blank&#34;&gt;C++ Programm Language&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.com/C-Programming-Language-4th/dp/0321563840/ref=sr_1_3?ie=UTF8&amp;amp;qid=1441600777&amp;amp;sr=8-3&amp;amp;keywords=c+programming+language&#34; target=&#34;_blank&#34;&gt;Book: C++ Programming Language&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Review: The C&#43;&#43; Programming Languages</title>
      <link>http://dangkhoasdc.github.io/post/blog/review_cpp_proglang_book/</link>
      <pubDate>Mon, 10 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/blog/review_cpp_proglang_book/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://www.stroustrup.com/4thEnglish.JPG&#34; alt=&#34;C++ Programming Language&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Hồi năm 1 đại học, mình rất thích cuốn C Programming Language của K&amp;amp;C, dù cuốn sách khá là ít trang nhưng đầy tinh tuý và rất hấp dẫn. Đến tận bây giờ, khi đã tốt nghiệp ra trường, tức đã 4 năm được biết cuốn sách, đôi lúc mình vẫn muốn đọc lại. Một thời gian sau mình có đọc thêm một số sách có tựa: The XXX Programming Language nhưng chỉ thấy C++ là hay.&lt;/p&gt;

&lt;p&gt;Bản C++ Programming Language mới nhất cập nhật cách tính năng của C++11, vì vậy, đây là một cuốn rất cần thiết cho bất kì ai muốn tìm hiểu về phiên bản C++11 cũng như các phiên bản tiếp sau như C++14, C++17. Chính vì những tính năng hoàn toàn mới và những thay đổi kể từ C++03, bản cập nhật này thêm vào kha khá chương so với phiên bản 3 của cuốn sách.&lt;/p&gt;

&lt;h1 id=&#34;nhìn-chung&#34;&gt;Nhìn chung&lt;/h1&gt;

&lt;p&gt;Điều mình không thích nhất là bản 4 &lt;em&gt;đã bỏ phần câu hỏi và bài tập&lt;/em&gt; ra khỏi cuốn sách - điểm mà ngày xưa mình rất thích. Một điều nữa là cuốn sách khá là dày, một số phần khá hay, một số phần giống sách reference về ngôn ngữ lập trình. Mà điều đó lại không cần thiết lắm vì nếu cần tra cứu thì &lt;a href=&#34;http://en.cppreference.com/w/&#34; target=&#34;_blank&#34;&gt;cppreference&lt;/a&gt; hay &lt;a href=&#34;http://www.cplusplus.com/&#34; target=&#34;_blank&#34;&gt;cplusplus&lt;/a&gt; lại gần gũi và chi tiết hơn.&lt;/p&gt;

&lt;h1 id=&#34;part-i-introductory-material&#34;&gt;Part I: Introductory Material&lt;/h1&gt;

&lt;p&gt;Đây là phần rất hay của cuốn sách. Tác giả giúp người đọc hình dung được như thế nào là lập trình sử dụng ngôn ngữ C++. Vì sao điều này quan trọng? Theo như kinh nghiệm bản thân, rất nhiều người học lập trình bị lẫn lộn giữa C++ và C, và hơn thế nữa là sử dụng tư tưởng của Java hay C# khi lập trình C++. Thêm vào đó, phần I giới thiệu sơ lược về thư viện chuẩn - một thành phần rất quan trọng trong ngôn ngữ C++.&lt;/p&gt;

&lt;p&gt;Từ các ví dụ tính toán thông thường đến các sử dụng các cấu trúc dữ liệu, thiết kế hàm hay module cũng như thiết kế hướng đối tượng, chương cuối của phần I còn đề cập phần mới đó là tính toán song song.&lt;/p&gt;

&lt;h1 id=&#34;part-ii-basic-facilities&#34;&gt;Part II: Basic Facilities&lt;/h1&gt;

&lt;p&gt;Phần này đề cập đến các thành phần cơ bản trong ngôn ngữ C++. Cơ bản ở đây gồm có:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Các lệnh (lặp, điều kiện, …)&lt;/li&gt;
&lt;li&gt;Hàm.&lt;/li&gt;
&lt;li&gt;Cấu trúc mảng, con trỏ và reference.&lt;/li&gt;
&lt;li&gt;Structure và các cấu trúc liên quan như Enumeration, Union.&lt;/li&gt;
&lt;li&gt;Exception và namespace.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Các tính năng (1) và (2) có lẽ rất quen thuộc với những ai đã lập trình với các ngôn ngữ họ nhà C. Tuy nhiên, các tính năng (3), (4) và (5) lại khá quan trọng. Nằm vững phần này giúp việc tránh các lỗi rất ngỡ ngẩn vì nhầm lẫn khái niệm trong C++.&lt;/p&gt;

&lt;h1 id=&#34;part-iii-abstraction-mechnisms&#34;&gt;Part III: Abstraction Mechnisms&lt;/h1&gt;

&lt;p&gt;Phần này cực kì quan trọng và có lẽ là phần mình thấy hay nhất trong cuốn sách bởi lẽ:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Tác giả đề cập đến lập trình hướng đối tượng và các kĩ thuật liên quan.&lt;/li&gt;
&lt;li&gt;Tác giả nêu lên những vấn đề trong lập trình hướng đối tượng cũng như phát triển phần mềm. Tập trung vào phương pháp trong kiến trúc ngôn ngữ nhằm giúp lập trình viên giải quyết các vấn đề dễ dàng hơn.&lt;/li&gt;
&lt;li&gt;Các kĩ thuật trong phát triển phần mềm khá hay và thực tế.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Tuy nhiên, điều làm mình không thích lắm có lẽ ngay ở các C++ giải quyết các vấn đề. Đặc biệt là ở template, và mình cảm thấy càng về sau càng rắm rối. Và điểm này C++ rõ ràng không “tốt” trong thiết kế hơn Java. Về mặt “hướng đối tượng” có lẽ Java đảm nhiệm tốt hơn hẳn.&lt;/p&gt;

&lt;h1 id=&#34;part-iv-the-standard-library&#34;&gt;Part IV: the Standard Library&lt;/h1&gt;

&lt;p&gt;Phần “chán” nhất trong cuốn sách. Vì sao ư? Hầu như tác giả liệt kê toàn bộ các lớp, hàm, cũng như thiết kế trong thư viện chuẩn. Nếu đề cập một số thành phần quan trọng (container, algorithm hay string) thì không có gì đáng nói. Nhưng là toàn bộ thư viện chuẩn rất đồ sộ và việc đọc hết part này rất mệt, nó giống như đọc một cuốn từ điển vậy. Ưu điểm duy nhất mình thấy khi đọc phần này đó là phát hiện ra một số hàm mà mình không nghĩ là nó tồn tại (điển hình là convert từ string sang số và ngược lại). Chương mình nghĩ là quan trọng gồm:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Container.&lt;/li&gt;
&lt;li&gt;Algorithms.&lt;/li&gt;
&lt;li&gt;Threads and Tasks,&lt;/li&gt;
&lt;li&gt;(Optional) Memory: mặc dù khá quan trọng, nhưng mình nghĩ dùng unique_ptr hay weak_ptr vẫn có gì đó không ổn.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;tổng-kết&#34;&gt;Tổng kết&lt;/h1&gt;

&lt;p&gt;Đây là cuốn sách rất đáng đọc cho bạn này đang học/làm việc hay quan tâm về ngôn ngữ C++. Như chính Bjarne Stroustrup từng nói: “Lập trình C đau thương như thể bắn vào bàn chân mình; nhưng C++ còn khó hơn; đó là lúc bạn bắn bay cả đôi chân của mình” &lt;a href=&#34;https://en.wikiquote.org/wiki/Bjarne_Stroustrup&#34; target=&#34;_blank&#34;&gt;Nguồn&lt;/a&gt;, để tránh bản thân “đau thương” đến vậy thì C++ Programming Language chính là cuốn sách hướng dẫn sử dụng súng. Ngoài ra, một số chương còn đề cập đến phương pháp cũng như quá trình hình thành ngôn ngữ và các tính năng trong ngôn ngữ, đó cũng là những kiến thức rất hay trong viết phần mềm. Nhưng đây không phải là cuốn sách để đọc ngấu nghiến từ trang đầu tới trang cuối cùng. Theo kinh nghiệm của bản thân, có thể đọc một số phần tuỳ thuộc vào việc người đọc đang làm việc với C++ ở mức độ nào:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Đang học lập trình: Part 1 và Part 2 rất quan trọng, đọc xong 2 part là ở mức khá khi hiểu về C++ rồi.&lt;/li&gt;
&lt;li&gt;Đang học về lập trình hướng đối tượng: Part 3 buộc phải đọc, bỏ qua phần Template. Part 1 là optional nhưng khuyến khích đọc nếu trước đây bị lậm Java hay C# nhiều, Part 2 có thể không đọc.&lt;/li&gt;
&lt;li&gt;Người làm về C++: Part 3 và Part 4. Cho dù cppreference hay cplusplus có tiện đi chăng nữa thì trong sách này là văn bản chính thức và qui chuẩn về các hàm cũng như về thư viện STD.&lt;/li&gt;
&lt;li&gt;Expert về C++: đổi sách khác đọc. Xét về khía cạnh expert thì mình nghĩ cuốn sách này hơi chung chung và chưa đi sâu vào các vấn đề trong lập trình C++.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Review Algorithms (Princeton) - Coursera</title>
      <link>http://dangkhoasdc.github.io/post/blog/review_algs_princeton_coursera/</link>
      <pubDate>Mon, 08 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/blog/review_algs_princeton_coursera/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://algs4.cs.princeton.edu/cover.png&#34; alt=&#34;Algorithms, Princeton&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Đây là một trong những khoá rất đỉnh về lập trình, vì sao ư?&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Kiến thức được dạy vững chắc và có nhiều thông tin rất thú vị và bổ ích.&lt;/li&gt;
&lt;li&gt;Bài tập lập trình rất hay.&lt;/li&gt;
&lt;li&gt;Bài tập trắc nghiệm giúp người học hiểu rõ hơn về các thuật toán và cấu trúc dữ liệu trong bài giảng.&lt;/li&gt;
&lt;li&gt;Các câu hỏi phỏng vấn rất hay và sáng tạo.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Part 1 của khoá học cover các phần sau:&lt;/p&gt;

&lt;h2 id=&#34;union-find&#34;&gt;Union-Find&lt;/h2&gt;

&lt;p&gt;Cấu trúc dữ liệu này rất hay. Một phần nó hay là vì hồi đại học mình chưa được học cấu trúc này, cộng thêm nó cũng có kha khá ứng dụng trong thực tế (phần Interview Questions có vài câu hỏi khá thực tế). Vì phần này ngoài cấu trúc dữ liệu nên bài tập và phần lập trình không quá xoắn não.&lt;/p&gt;

&lt;h2 id=&#34;stacks-and-queues&#34;&gt;Stacks and Queues&lt;/h2&gt;

&lt;p&gt;Phần bài tập lập trình làm về cấu trúc Deque và RandomizedQueue, khá là thú vị. Phần thuật toán có giới thiệu giải thuật &lt;a href=&#34;https://en.wikipedia.org/wiki/Graham_scan&#34; target=&#34;_blank&#34;&gt;Graham scan&lt;/a&gt; - tìm tập bao lồi trong một tập các điểm. Phần này thì cũng không quá khó, thiên về lập trình và API là nhiều. Để được &lt;sup&gt;100&lt;/sup&gt;&amp;frasl;&lt;sub&gt;100&lt;/sub&gt; điểm lập trình thì cần tricky một chút cho phần RandomizedQueue.&lt;/p&gt;

&lt;h2 id=&#34;merge-sort-và-quicksort&#34;&gt;Merge sort và Quicksort&lt;/h2&gt;

&lt;p&gt;Hai thuật toán sort rất nổi tiếng, đồng thời tác giả có đề cập cả stable sort và các vấn đề liên quan. Ví dụ như tìm k phần tử nhỏ nhất (có thuật toán nào có thể run tốt hơn O(nlogn) không). Vì sao quick sort lại tốt hơn merge sort dù 2 ẻm này đều là O(nlogn), vì sao ta phải shuffle dữ liệu trước khi thực hiện quick sort, merge sort được sử dụng trong các thuật toán cần stable sort. Đồng thời bài giảng cũng đề cập đến các thuật toán sort được cài đặt sẵn trong các ngôn ngữ lập trình.&lt;/p&gt;

&lt;p&gt;Phần bài tập lập trình cũng hơi tricky, tui nhiên rất hay: đó là tìm những điểm collinear trong một mặt phẳng.&lt;/p&gt;

&lt;h2 id=&#34;priority-queue-và-symbol-table&#34;&gt;Priority Queue và Symbol Table&lt;/h2&gt;

&lt;p&gt;Học về heap sort và các vấn đề liên quan. Bài tập lập trình &lt;a href=&#34;https://en.wikipedia.org/wiki/15_puzzle&#34; target=&#34;_blank&#34;&gt;8-puzzle&lt;/a&gt;, một bài rất hay.&lt;/p&gt;

&lt;h2 id=&#34;balanced-search-trees&#34;&gt;Balanced Search Trees&lt;/h2&gt;

&lt;p&gt;Cây và các vấn đề liên quan đây cây cân bằng, điểm mình thấy hay nhất đó là được học về 2-3 tree, cây đỏ đen, B-tree. Đặc biệt là B-tree sử dụng trong cơ sở dữ liệu và hệ điều hành. Một phần khá hay khác là thuật toán sử dụng trong không gian, điển hình là &lt;a href=&#34;https://en.wikipedia.org/wiki/K-d_tree&#34; target=&#34;_blank&#34;&gt;kdtree&lt;/a&gt;. Bài tập lập trình là kdtree, quá là phê luôn.&lt;/p&gt;

&lt;p&gt;Bài tập trắc nghiệm trong phần này bao khó, vì phải chạy bằng tay cây đỏ đen.&lt;/p&gt;

&lt;h2 id=&#34;hash-tables&#34;&gt;Hash Tables&lt;/h2&gt;

&lt;p&gt;Học về hashing function, các cấu trúc dữ liệu trong hashing, birthday problem … blah blah. Một trong những ứng dụng của nó chính là cấu trúc dành cho véc tơ, ma trận thưa (&lt;a href=&#34;https://en.wikipedia.org/wiki/Sparse_array&#34; target=&#34;_blank&#34;&gt;sparce vector&lt;/a&gt;), nhờ khoá này mà khi dự một buổi meeting có liên quan đến Hashing thì mình không bị bỡ ngỡ bởi các khái niệm.&lt;/p&gt;

&lt;p&gt;Khoá học còn một phần nữa là Part 2, đề cập đến các chủ đề như:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Đồ thị.&lt;/li&gt;
&lt;li&gt;Cây.&lt;/li&gt;
&lt;li&gt;Maximum Flow và Minimum Cut.&lt;/li&gt;
&lt;li&gt;Regular Expression và Data Compression.&lt;/li&gt;
&lt;li&gt;Reductions và Linear Programming.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;tổng-kết&#34;&gt;Tổng kết&lt;/h2&gt;

&lt;p&gt;Một khoá &lt;em&gt;bắt buộc&lt;/em&gt; phải học với những ai theo nghiệp lập trình. Một trong những điểm cộng sáng giá đó là khoá học này không giảm độ khó so với khoá gốc ở Princeton (Như khoá Machine Learning của Andrew Ng. trên Course thì quá dễ so với khoá của ông ở Stanford). Không những được học về những cấu trúc dữ liệu và giải thuật kinh điển mà còn được học, sử dụng vào các ứng dụng thực tiễn, các bài toán còn nóng hổi cũng nhưng các giải thuật nâng cao. Bài tập lập trình rất hay và sáng tạo, điểm cộng đó là cho người học tự do với sự sáng tạo cũng như cách ra đề giúp người học động não.&lt;/p&gt;

&lt;h2 id=&#34;một-số-lưu-ý&#34;&gt;Một số lưu ý&lt;/h2&gt;

&lt;p&gt;Thầy dạy rất dễ buồn ngủ, để tránh hiện tượng này ta có thể:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Tăng tốc độ video lên 1.25 hoặc 1.5, việc này giúp não tránh bị nhàm chán.&lt;/li&gt;
&lt;li&gt;Viết note đầy đủ.&lt;/li&gt;
&lt;li&gt;Pause video, viết một đoạn code minh hoạ thuật toán hoặc search wiki về các thông tin thầy đề cập.&lt;/li&gt;
&lt;li&gt;Uống nước cho tinh thần thoải mái, tránh Red Bull và nước có ga.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Để theo hết được khoá học, thì đây là một số kinh nghiệm của bản thân:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Follow theo đúng deadline và lịch của khoá học. Tốt nhất là dành 2 ngày để nghe video, vì thường 1 tuần sẽ có 2 nội dung học. Một bài thường có thời lượng 60-70 phút, tốt nhất nên dành 2 tiếng trong ngày để nghe video, ghi chép và tìm hiểu. Dành khoảng 10 phút giải lao trong mỗi 45 phút học bài.&lt;/li&gt;
&lt;li&gt;Dành một tuần cho bài tập lập trình và bài tập trắc nghiệm.&lt;/li&gt;
&lt;li&gt;Dành một ngày trong tuần sau đó để ôn lại bài, làm lại bài tập hoặc nộp lại bài lập trình.&lt;/li&gt;
&lt;li&gt;Thông thường khi bài lập trình rất khó để đạt &lt;sup&gt;100&lt;/sup&gt;&amp;frasl;&lt;sub&gt;100&lt;/sub&gt; ngay từ lần submit đầu tiên, tuy nhiên để đạt trên 80 thì không khó. Cố gắng nắm bắt thật kĩ đề bài, thiết kế API và mã giả trước, được kĩ checklist cũng như hint được tiết lộ. Chịu khó Google về bài tập, thường chủ đề của bài tập là những bài toán/vấn đề nổi tiếng trong Khoa Học Máy Tính.&lt;/li&gt;
&lt;li&gt;Tham gia diễn đàn, ta sẽ được an ủi phần nào khi có kha khá đứa cũng đang nổi điên với bài tập như mình.&lt;/li&gt;
&lt;li&gt;Bài tập trắc nghiệm: đọc lại slides, với các bài tập thuật toán thì cần chạy chính xác từng lệnh trong thuật toán đó bằng tay. Các bài tập về mệnh đề rất mẹo, cần đọc kĩ câu hỏi và xem kĩ lại video.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>
