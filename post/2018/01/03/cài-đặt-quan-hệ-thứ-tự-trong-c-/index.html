<!DOCTYPE html>
<html
  lang="vi"
  prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb#"
>
  <head>
    <meta charset="utf-8" />

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="HandheldFriendly" content="True" />
<meta name="MobileOptimized" content="320" />
<meta name="viewport" content="width=device-width, initial-scale=1" />


<link rel="apple-touch-icon" sizes="180x180" href="http://dangkhoasdc.github.io//apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://dangkhoasdc.github.io//favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="http://dangkhoasdc.github.io//favicon-16x16.png">
<link rel="manifest" href="http://dangkhoasdc.github.io//site.webmanifest">
<link rel="mask-icon" href="http://dangkhoasdc.github.io//safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">



<meta name="keywords" content="programming,
C&#43;&#43;,
">

<meta property="og:title" content="Cài đặt quan hệ thứ tự trong C&#43;&#43;" />
<meta property="og:description" content="Bài viết dưới đây mô tả một giải pháp để cài đặt các quan hệ giữa các cấu trúc dữ liệu (CTDL) khác nhau trong C&#43;&#43;. Ứng dụng của quan hệ giữa các đối tượng đóng vai trò quan trọng trong các thuật toán, dưới đây có thể nêu lên 1 số ví dụ:
 Total Order (Quan hệ thứ tự): Đây là một trong những quan hệ quen thuộc nhất, có vai trò quan trọng trong các thuật toán sắp xếp." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://dangkhoasdc.github.io/post/2018/01/03/c%C3%A0i-%C4%91%E1%BA%B7t-quan-h%E1%BB%87-th%E1%BB%A9-t%E1%BB%B1-trong-c-/" />
<meta property="article:published_time" content="2018-01-03T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-01-03T00:00:00+00:00" /><meta property="og:site_name" content="Blog" />

<meta property="og:site_name" content="Blog" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Cài đặt quan hệ thứ tự trong C&#43;&#43;"/>
<meta name="twitter:description" content="Bài viết dưới đây mô tả một giải pháp để cài đặt các quan hệ giữa các cấu trúc dữ liệu (CTDL) khác nhau trong C&#43;&#43;. Ứng dụng của quan hệ giữa các đối tượng đóng vai trò quan trọng trong các thuật toán, dưới đây có thể nêu lên 1 số ví dụ:
 Total Order (Quan hệ thứ tự): Đây là một trong những quan hệ quen thuộc nhất, có vai trò quan trọng trong các thuật toán sắp xếp."/>


<meta itemprop="name" content="Cài đặt quan hệ thứ tự trong C&#43;&#43;">
<meta itemprop="description" content="Bài viết dưới đây mô tả một giải pháp để cài đặt các quan hệ giữa các cấu trúc dữ liệu (CTDL) khác nhau trong C&#43;&#43;. Ứng dụng của quan hệ giữa các đối tượng đóng vai trò quan trọng trong các thuật toán, dưới đây có thể nêu lên 1 số ví dụ:
 Total Order (Quan hệ thứ tự): Đây là một trong những quan hệ quen thuộc nhất, có vai trò quan trọng trong các thuật toán sắp xếp.">
<meta itemprop="datePublished" content="2018-01-03T00:00:00+00:00" />
<meta itemprop="dateModified" content="2018-01-03T00:00:00+00:00" />
<meta itemprop="wordCount" content="1349">



<meta itemprop="keywords" content="programming,C&#43;&#43;," />



    <title>Cài đặt quan hệ thứ tự trong C&#43;&#43; || Blog</title>
    <link rel="canonical" href="http://dangkhoasdc.github.io/post/2018/01/03/c%C3%A0i-%C4%91%E1%BA%B7t-quan-h%E1%BB%87-th%E1%BB%A9-t%E1%BB%B1-trong-c-/" />

    

    <link rel="stylesheet" href="/css/reboot.css" />
<link rel="stylesheet" href="/css/style.css" />
<link rel="stylesheet" href="/css/syntax.css" />



<script type="text/javascript" src="/js/main.js" defer></script>

<link href="https://fonts.googleapis.com/css?family=Lora&display=swap" rel="stylesheet">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
  </head>
  <body
  class=" look-sheet-bkg"
  lang="vi">
  <div class="nav-bkg">
    <nav class="content-container pagewide-bar-padding">
      <span class="divider">/ </span>
      <a href="http://dangkhoasdc.github.io/" >Blog</a>
      <span class="divider">/ </span>
  <a href="http://dangkhoasdc.github.io/post">Posts</a>
      <ul class="list-unstyled right-links">

          <li>
            <a href="/en/post/">
              <span class="post-title">English version</span>
            </a>
          </li>

</ul>

    </nav>
  </div>
  <article
    id="main"
    class="content-container look-sheet article-pad-v "
    itemscope
    itemtype="https://schema.org/Article" >
  <meta itemprop="author" content="" />
  <meta itemprop="publisher" content="" />
  <meta itemprop="image" content="" />
  <h1 itemprop="name" id="title">Cài đặt quan hệ thứ tự trong C&#43;&#43;</h1>
  <meta itemprop="headline" content="Cài đặt quan hệ thứ tự trong C&#43;&#43;" />
  
  <div class="post-tags">
  
    <a href="http://dangkhoasdc.github.io/tags/programming/">#programming</a>&nbsp;
  
    <a href="http://dangkhoasdc.github.io/tags/c&#43;&#43;/">#C&#43;&#43;</a>&nbsp;
  
  </div>
  
  
    
      <div class="post-date"><span itemprop="datePublished">January 3, 2018</span></div>
      <meta itemprop="dateModified" content="January 3, 2018"/>
    
  
  
  <div itemprop="articleBody" id="content" class="article-body margin-top-2em">
    <p>Bài viết dưới đây mô tả một giải pháp để cài đặt các quan hệ giữa các cấu trúc
dữ liệu (CTDL) khác nhau trong C++. Ứng dụng của quan hệ giữa các đối tượng đóng vai
trò quan trọng trong các thuật toán, dưới đây có thể nêu lên 1 số ví dụ:</p>
<ul>
<li>Total Order (Quan hệ thứ tự): Đây là một trong những quan hệ quen thuộc nhất,
có vai trò quan trọng trong các thuật toán sắp xếp.</li>
<li>Equivalence relation (Quan hệ tương đương): được sử dụng trong các thuật toán
hashing.</li>
</ul>
<p>Tuy nhiên trong bài này thay vì đề cập trực tiếp đến quan hệ thứ tự (Total Order),
ta thử sử dụng quan hệ tổng quát hơn chút <strong>weak order</strong>. Điều khác biệt duy nhất
của Weak Order so với Total Order nằm ở chỗ weak order không có tính đối xứng.
Và trong &ldquo;thực tế đời sống&rdquo;, Weak Order chính là dấu <code>&lt;</code>.</p>
<p>Vậy có điều gì khó khăn khi phải cài đặt dấu <code>&lt;</code> này? Giả sử ta có một hàm như
sau:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">bool</span> f(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> lhs, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> rhs) { <span style="color:#66d9ef">return</span> lsh<span style="color:#f92672">&lt;</span>rhs; }

</code></pre></div><p>Giả sử ta viết một thư viện trong đó chứa hàm <code>f</code> và mong muốn bất kì ai sử
dụng cũng phải cài đặt dấu <code>&lt;</code> cho CTDL của mình. Bởi đôi khi, dấu <code>&lt;</code> mặc
định của C++ chưa chắc mang ngữ nghĩa đúng, hay bất kì một CTDL tự tạo nào
không chứa dấu <code>&lt;</code> cũng gặp lỗi. Vậy nếu có cơ chế nào giúp trình biên dịch
phát hiện được LTV quên cài đặt dấu này. Cụ thể hơn ta, muốn có:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">bool</span> f(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> lhs, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> rhs) {
    <span style="color:#75715e">// Error if T does not have `&lt;` operator
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// otherwise
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> lsh<span style="color:#f92672">&lt;</span>rhs;
}

</code></pre></div><p>Trong C++11, ta có 1 cơ chế khá giống như vậy:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">bool</span> f(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> lhs, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> rhs) {
    <span style="color:#66d9ef">static_assert</span>(has_less_operator<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>value, <span style="color:#e6db74">&#34;Please implement &lt; operator&#34;</span>);
    <span style="color:#66d9ef">return</span> lsh<span style="color:#f92672">&lt;</span>rhs;
}

</code></pre></div><p>Kỹ thuật sử dụng <code>struct&lt;T&gt;::value</code> được gọi là <a href="https://accu.org/index.php/journals/442">type traits</a>,
được sử dụng rất
phổ biến trong STL, metaprogramming, các thư viện như BOOST, dlib. Tiếp, <code>::value</code>
ở đây phải là static, không có gì phải bàn. Đồng thời, <code>::value</code> trả về yes/no
khi lớp T chứa/ hoặc không chứa <code>&lt;</code>, nên kiểu phải là <code>bool</code>. Do giá trị này được
kiểm tra lúc trình biên
dịch thực thi, nên hẳn là <code>constexpr</code>. Xong tạm thời ta có 1 cài đặt:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">has_less_operator</span>{
    <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
        <span style="color:#75715e">// stuff
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">bool</span> value <span style="color:#f92672">=</span> <span style="color:#75715e">// and other stuff;
</span><span style="color:#75715e"></span>};
</code></pre></div><p>Và giờ đến phần khoai nhất khi cài đặt. Ta buộc phải gán &ldquo;cái gì đó&rdquo; vào <code>value</code>,
nhưng ngay tại thời điểm cài đặt ta còn không biết nó có giá trị gì, và hoàn toàn
phụ thuật vào CTDL <code>T</code> nào đó do LTV khác viết. Hay nói một cách khác, chính giá
trị boolean cũng bị tham số hóa theo kiểu. May mắn thay, STL có hỗ trợ vụ này:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;type_traits&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">typedef</span> true_type yes;
<span style="color:#66d9ef">typedef</span> false_type no;

</code></pre></div><p>Lúc này ta có thể viết :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">bool</span> value <span style="color:#f92672">=</span> is_same<span style="color:#f92672">&lt;</span>yes, <span style="color:#75715e">/* X */</span><span style="color:#f92672">&gt;::</span>value;
</code></pre></div><p>Như vậy <code>value</code> sẽ phụ thuộc vào <code>is_same&lt;yes, X&gt;::value</code>. Vấn đề X ở đây là gì?
Ta xem trong STL, <code>is_same</code> nhận 2 datatype làm input. Vậy X chính là 1 datatype
khác. Nhưng cụ thể hơn nó có thể là yes/no để <code>value</code> trở thành yes/no.</p>
<p>Tới đây là một đoạn cực kì fancy, nhưng mình không biết giải thích trước thế nào
nhưng trước hết cứ viết ra đã:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">bool</span> value <span style="color:#f92672">=</span> is_same<span style="color:#f92672">&lt;</span>yes,
                                    <span style="color:#66d9ef">decltype</span>(test<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">nullptr</span>))
                                    <span style="color:#f92672">&gt;::</span>value;
</code></pre></div><p><code>decltype</code> trả về kiểu dữ liệu <code>return type</code> của hàm <code>test</code> và ta cố tình đưa
toàn bộ cài đặt vào trong <code>test</code> này. Bởi toán tử <code>&lt;</code> trong C++ yêu cầu 1 tham
số đầu vào nên ta để 1 tham số hàm <code>test</code> làm dummy. Như vậy ta biết chắc chắn
<code>test&lt;T&gt;</code> trả về 1 trong 2 kiểu dữ liệu : <code>yes</code> hoặc <code>no</code> như được typedef phía
trên. Đồng thời, ta biết rằng mặc định mọi kiểu dữ liệu <code>T</code> sẽ trả về <code>no</code>.</p>
<p>Tức ta có :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">static</span> no test(...);
</code></pre></div><p>Xong cho phần sai. Giờ làm thế nào để trả về <code>yes</code> khi dữ liệu thực sự đã cài
đặt <code>&lt;</code>. Ta có 1 hàm test thứ 2:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> P<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">auto</span> test (P <span style="color:#f92672">*</span>p)
    <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">decltype</span>(declval<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>()<span style="color:#f92672">&lt;</span>(<span style="color:#f92672">*</span>p), yes());
</code></pre></div><p>WTF =))) Điều gì đang xảy ra ở đây? Nhờ một khái niệm <a href="https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">SFINAE</a>,
chúng ta được chứng kiến sự điên rồ của C++.</p>
<p>Hãy phân tích câu lệnh trên.
Phần <code>template&lt;typename T&gt; static</code> không có gì khác với <code>test</code> của <code>no</code>. Kết
quả trả về là <code>auto</code> để &ldquo;nhường&rdquo; phần quyết định cho <code>decltype</code>. <code>decltype</code> làm
chuyện như sau, nếu biểu thức <code>declval&lt;T&gt;()&lt;(*p), yes()</code> biên dịch được thì
<code>auto</code> sẽ trở thành <code>yes</code> nhờ vào &ldquo;comma-separated list&rdquo;: trả về kết quả của term
cuối cùng trong list. Vậy vấn đề nằm ở <code>declval</code>. Hàm nào giúp ta gọi được
<code>&lt;</code> mà không cần thông qua constructor. Chính xác hơn <code>declval&lt;T&gt;()</code> là
template function với tham số kiểu dữ liệu <code>T</code>, trả về kiểu reference X nào đó,
nhờ đó ta gọi được <code>&lt;(*p)</code>: chính là phép <code>&lt;</code> thần thánh của chúng ta. Nếu như
không tồn tại <code>&lt;</code>, biểu thức này fail nhưng sẽ không bị báo lỗi biên dịch mà thay
vào đó trình biên dịch gán <code>test</code> cho <code>static no test(...)</code>.</p>
<p>Tổng kết lại ta có code như sau:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;type_traits&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>true_type yes;
<span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>false_type no;

<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">has_less_operator</span> {
    <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> P<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">auto</span> test(P <span style="color:#f92672">*</span>p) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">decltype</span>(std<span style="color:#f92672">::</span>declval<span style="color:#f92672">&lt;</span>P<span style="color:#f92672">&gt;</span>()<span style="color:#f92672">&lt;</span>(<span style="color:#f92672">*</span>p), yes());
    <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">static</span> no test(...);


    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">bool</span> value <span style="color:#f92672">=</span> is_same<span style="color:#f92672">&lt;</span>
                                    yes,
                                    <span style="color:#66d9ef">decltype</span>(test<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">nullptr</span>))
                               <span style="color:#f92672">&gt;::</span>value;
};

<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">bool</span> f(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> lsh, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> rhs) {
    <span style="color:#66d9ef">static_assert</span>(has_less_operator<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>value, <span style="color:#e6db74">&#34;Please implement &lt;&#34;</span>);
    <span style="color:#66d9ef">return</span> lsh<span style="color:#f92672">&lt;</span>rhs;
}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">s1</span> {
    <span style="color:#66d9ef">int</span> i;
    s1(<span style="color:#66d9ef">int</span> _i)<span style="color:#f92672">:</span> i(_i) {  }
    <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;</span>(<span style="color:#66d9ef">const</span> s1<span style="color:#f92672">&amp;</span> other) <span style="color:#66d9ef">const</span> {
        <span style="color:#66d9ef">return</span> i <span style="color:#f92672">&lt;</span> other.i;
    }
};

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">s2</span> {
    <span style="color:#66d9ef">int</span> i;
    s2(<span style="color:#66d9ef">int</span> _i)<span style="color:#f92672">:</span> i(_i) {  }
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span><span style="color:#f92672">*</span> argv[])
{
    s1 a(<span style="color:#ae81ff">10</span>);
    s1 b(<span style="color:#ae81ff">20</span>);
    f(a, b);
    <span style="color:#75715e">/* s2 c(10), d(20); */</span>
    <span style="color:#75715e">/* f(c, d); */</span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

</code></pre></div><p>Nếu ta uncomment s2 và f bên dưới, ta có thông báo lỗi như sau:</p>
<pre><code>a.cpp: In instantiation of ‘bool f(const T&amp;, const T&amp;) [with T = s2]’:
a.cpp:47:11:   required from here
a.cpp:24:5: error: static assertion failed: Please implement &lt;
     static_assert(has_less_operator&lt;T&gt;::value, &quot;Please implement &lt;&quot;);
     ^~~~~~~~~~~~~
</code></pre><p>Thông báo cực kì dễ hiểu. Với việc sử dụng một số IDE thông minh, thậm chí thông
báo lỗi sẽ được thông báo ngay lúc cài đặt <code>s2</code> và gọi <code>f</code>. Quan trọng hơn,
nhờ đó ta có thể viết mã theo &ldquo;Design by Contract&rdquo; hay theo phong cách interface
của Java và C++. Sắp tới C++ sẽ giới thiệu khái niệm <code>concept</code> và theo tác
giả của C++ là sẽ giải quyết vấn đề suốt 35 năm qua của Generic Programming
(<a href="https://developers.slashdot.org/story/17/01/23/003247/c-creator-wants-to-solve-35-year-old-generic-programming-issues-with-concepts">link</a>).</p>
<h1 id="các-toán-tử-khác">Các toán tử khác</h1>
<p>Sau khi cài đặt toán tử <code>&lt;</code>, thông thường ta sẽ có nhu cầu cài đặt các toán
tử so sánh khác như <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>. May mắn thay ta có thể quy đổi các toán tử
này dễ dàng thông qua <code>&lt;</code>:</p>
<ul>
<li><code>&gt;</code>: chính là <code>rhs&lt;lsh</code>.</li>
<li><code>&lt;=</code>: là <code>!(rhs&lt;lsh)</code>.</li>
<li><code>&gt;=</code>: <code>!(lhs&lt;rhs)</code>.</li>
</ul>
<p>Trong thâm ta ta có cảm giác rằng thể nào cũng có rất nhiều CTDL ta cài đặt
kiểu này: chỉ cần định nghĩa <code>&lt;</code> và 3 toán tử còn lại tự nội suy. Nhờ vào kỹ
thuật <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">Curiously recurring template pattern</a>,
ta có một code khá gọn:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">order</span> {
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;</span>( <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> rhs) <span style="color:#66d9ef">const</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&gt;</span>( <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> rhs) <span style="color:#66d9ef">const</span>
        {<span style="color:#66d9ef">return</span> rhs<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;&gt;</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>);}
    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&gt;=</span>( <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> rhs) <span style="color:#66d9ef">const</span>
        {<span style="color:#66d9ef">return</span> <span style="color:#f92672">!</span>((<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>)<span style="color:#f92672">&lt;</span>rhs); }
    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;=</span>( <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> rhs) <span style="color:#66d9ef">const</span>
        {<span style="color:#66d9ef">return</span> <span style="color:#f92672">!</span>(rhs<span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;&gt;</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>));}
};
</code></pre></div><p>Như vậy chỉ cần kế thừa <code>order</code> và cài đặt <code>&lt;</code>, ta sẽ có luôn 3 toán tử còn lại.
Điều duy nhất mình ức chê là phải sử dụng <code>static_cast</code>.</p>

  </div>
</article>

  


  
    <div class="nav-bkg-50 content-container-narrow-pad bottom-links text-0p75">
      <nav class="flex-row">
      
      <a href="http://dangkhoasdc.github.io/post/2017/12/27/ng%C6%B0%E1%BB%9Di-vi%E1%BB%87t-trong-khoa-h%E1%BB%8Dc-m%C3%A1y-t%C3%ADnh/" class="flex-row v-center no-underline"  style="max-width:45%;">
        <span class="text-1p5">←</span>&nbsp;<span class="re-underline">Previous: Người Việt trong Khoa học Máy Tính</span>
      </a>
      
      
        <a href="http://dangkhoasdc.github.io/post/2018/01/04/m%E1%BB%99t-s%E1%BB%91-bi%E1%BA%BFn-th%E1%BB%83-quicksort/" class="flex-row v-center no-underline" style="max-width: 45%;">
        <span class="re-underline">Next: Một số biến thể Quicksort</span>&nbsp;<span class="text-1p5">→</span>
        </a>
      
      </nav>
    </div>
  
  <footer>
    </footer>
    </body>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js" integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
onload='renderMathInElement(document.body,{
  delimiters: [
      {left: "$$", right: "$$", display: true},
      {left: "\\[", right: "\\]", display: true},
      {left: "$", right: "$", display: false},
      {left: "\\(", right: "\\)", display: false}
  ]});'></script>

  </html>
  

  </body>
</html>
