<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming on Dang-Khoa&#39;s blog </title>
    <link>http://dangkhoasdc.github.io/tags/programming/</link>
    <description>Recent content in Programming on Dang-Khoa&#39;s blog </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Dang-Khoa</copyright>
    <lastBuildDate>Mon, 25 Sep 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="/tags/programming/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Đọc &#34;Nghệ Thuật Lập Trình&#34; (TAoCP)</title>
      <link>http://dangkhoasdc.github.io/post/taocp/howto/</link>
      <pubDate>Mon, 25 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/taocp/howto/</guid>
      <description>

&lt;p&gt;Phải thành thật, mình là fanboy của Donald Knuth. Có thể có rất nhiều giáo sư có
tầm ảnh hưởng lớn đến các hướng mà mình quan tâm (khoa học máy tính/ trí tuệ
nhân tạo hay thị giác máy tính) như Hinton, Li Fei-Fei, Zisserman, Pascal Fua.
Nhưng có rất ít nhà khoa học mà mình dành trọn thời gian để có thể tìm hiểu và
&amp;ldquo;cuồng&amp;rdquo; như Donald Knuth. Và mong ước của mình từ khi bước chân vào giảng đường
đại học, theo đuổi đam mê với Khoa Học Máy Tính, rằng mình sẽ chinh phục cuốn
&amp;ldquo;Kinh Thánh&amp;rdquo; này. Đó là một cuộc hành trình, và còn thử thách hơn cả tất cả
những hành trình mình từng trải nghiệm.&lt;/p&gt;

&lt;p&gt;Ngày sinh nhật vào năm đầu tiên đi làm, mình đã tự thưởng cho bản thân bản &lt;a href=&#34;https://www.amazon.com/Computer-Programming-Volumes-1-4A-Boxed/dp/0321751043/ref=sr_1_1?ie=UTF8&amp;amp;qid=1506337149&amp;amp;sr=8-1&amp;amp;keywords=the+art+of+computer+programming&#34; target=&#34;_blank&#34;&gt;full
set của bộ
sách&lt;/a&gt;
.  Trước giờ mình chỉ dùng với mục đích tham khảo là chính. Nhưng vừa sau đợt
sinh nhật 24 của mình, mình quyết định phải &amp;ldquo;chinh phục&amp;rdquo; bằng được cuốn sách.
Mà theo plan của mình Volume 1 sẽ tốn tầm &amp;hellip; 1-2 năm. Và có lẽ, mình sẽ mất
chừng chục năm để chinh phục Volume 4A 😆. Chưa kể, phần 4B cực kì khó nhằn
vì có cả Satistiability trong đó. Có lẽ riêng Volume 4 không thôi thì đã trở
thành tượng đài mất rồi.&lt;/p&gt;

&lt;h1 id=&#34;taocp-liệu-có-khó-đọc&#34;&gt;TAoCP liệu có khó đọc?&lt;/h1&gt;

&lt;p&gt;Theo mình thì không. Nhiều người khi nhìn vào cuốn sách với hàng đống công thức
toán và những bài tập khó nhằng cũng như code mã máy MIX khiến họ nghĩ đây là
một cuốn sách rất khó đọc. Nhưng ngay từ đoạn giới thiệu, Don Knuth đã hướng dẫn
cách đọc và ông đã chỉ rõ những vấn đề mà người đọc thắc mắc.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Với MIX - mình đồng ý quan điểm của Don Knuth, nếu ông viết chương trình theo
C/C++ hay Java hay Python, một thời gian sau chắc chắn nó sẽ có vấn đề. Kể cả
những ngôn ngữ bậc cao càng khiến ta khó phân tích chính xác số lượng tính
toán trong thuật toán đó. Mà theo phân tích của Knuth, đó phải là những phân
tích chính xác. Ngôn ngữ của MIX cũng rất dễ đọc, không đến nối rắc rối như
mọi người tưởng. Đồng thời, việc đọc code bằng mã máy khuyến khích người đọc
&amp;ldquo;vọc&amp;rdquo; với thuật toán được ghi. Thêm nữa, &amp;ldquo;ngôn ngữ bậc cao&amp;rdquo; mà Knuth dùng
chính là tiếng Anh.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Trong biểu đồ sử dụng sách của mình, Knuth có nói rằng nếu các công thức toán
&amp;ldquo;is all Greek to you&amp;rdquo; ta chỉ cần xem qua và nắm được kết quả cơ bản mà
phần đó đề cập, và hầu như các kết quả đó được nói ở đầu mục hoặc cuối mục.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Với bài tập của TAoCP, Knuth đề xuất hệ thống phân loại. Hơn hết, hệ thống
này nhằm giúp cho người đọc, với thời lượng cho phép của mình, lựa chọn và
làm những bài bản thân nghĩ là phù hợp. Bởi thật sự những bài với độ khó lớn
hơn 45, dù là không dính đến toán, M hay HM đều cần rất nhiều thời gian
nghiên cứu. Bản thân mình nghĩ nếu giải được những bài đó thì có thể hoàn
thành được PhD của Computer Science rồi. Nhưng mình vẫn nghĩ người đọc nên
xem qua các câu hỏi này,  &lt;strong&gt;vì nó chính là biên giới tri thức trong khoa học
máy tính.&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Knuth nêu rõ trong cuốn sách của mình, mục đích của cuốn sách phục vụ: (1) là
tài liệu tham khảo chính xác và chi tiết về phân tích thuật toán, (2) là một
sách giáo khoa  &lt;strong&gt;tự học&lt;/strong&gt;  dành cho những người đam mê về thuật toán cũng như Khoa
Học Máy Tính. Nếu bạn mua TAoCP chỉ với giá trị tham khảo thì đó hoàn toàn là
mục đích chính xác của bộ sách: mình đặc biệt thích phần tra khảo về lịch sử.
Đúng ra, Don Knuth rất quan tâm đến lịch sử của Khoa Học Máy Tính, đó là lí
do vì sao trong sách đề cập các thông tin lịch sử lại chi tiết đến như vậy.
Nhưng ngoài ra, phần bài tập lẫn lời giải, mà thường chiếm đến &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt; cuốn sách,
nói lên rằng Knuth mong mỏi cuốn sách này sẽ là một tài liệu học tốt dành cho
mọi người.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Kế hoạch của mình rất đơn giản: Chinh phục TAoCP đồng thời giúp mọi người dễ
dàng tiếp cận với tài liệu quý giá này. Quá nhiều bạn đọc dường như sợ tiếp cận
cuốn sách bởi những &amp;ldquo;myth&amp;rdquo; vừa nêu, đồng thời, chinh phục TAoCP là một hành
trình thực sự thú vị. Mình đã học được rất nhiều điều thông qua cuốn sách. Những
ngày đầu đại học khi lần đầu cầm trong tay Volume 1, mình mới thực sự hiểu
&amp;ldquo;computer science&amp;rdquo; là một khoa học đầy hấp dẫn, và nó cũng rất &amp;ldquo;art&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Mình đồng ý với quan điểm của Knuth, người làm về phân tích thuật toán hạnh phúc
gấp đôi những ngành khác: họ chiêm nghiệm được những công thức toán phức tạp để
tính toán độ phức tạp, phân tích thuật toán, đồng thời họ cảm nhận được tính
hiệu quả của thuật toán đó trong thực tế. Ta chắc chắn không cần bận tâm đến câu
&amp;ldquo;học toán để làm gì&amp;rdquo;, bởi khi tiếp cận với phân tích thuật toán, ta cảm nhận
ngay được ích lợi của toán học, thuật toán cũng như vẻ đẹp của thuật toán khi ta
cài đặt và sử dụng trong thực tiễn.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;một-chút-về-dự-án-này&#34;&gt;Một chút về dự án này&lt;/h1&gt;

&lt;p&gt;Ngoài những chi tiết ở trên, một phần khiến TAoCP khó đọc ở chỗ thông tin được
Knuth viết tương đối cô đặc. Chính vì lẽ đó mà đôi khi có những phần tương đối
khó hiểu đối với những bạn tìm hiểu về khoa học máy tính và chưa có nhiều kiến
thức trước đó. Mục tiêu của project này nhằm giúp các bạn dễ tiếp cận hơn với
sách, đồng thời giải thích các phần bài tập, bởi mình thấy Knuth viết phần
Solutions cực kì gọn, và đôi khi cũng không biết là từ đâu lại có những đáp số
đó. Ngoài ra, tìm hiểu về TAoCP cũng chính là tìm hiểu các thuật toán kinh điển,
các bài toán làm trên nền tảng của Khoa Học Máy Tính cũng như đây là nguồn tài
liệu rất quý giá để mài dũa &amp;ldquo;algorithmic thinking&amp;rdquo;. Một lý do nữa khiến mình có
hứng thú để làm đó là hiện nay tuy có khá nhiều blog, repo trên Github note lại
TAoCP nhưng chưa có ai viết đầy đủ, hoặc chi tiết.&lt;/p&gt;

&lt;p&gt;Loạt bài viết cùa mình yêu cầu người đọc đã đọc qua trước chương hoặc phần mình
đề cập trong bài viết, trong các bài viết mình sẽ chú trọng đến các chi tiết
sau:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Các chi tiết tương đối khó hiểu.&lt;/li&gt;
&lt;li&gt;Phần bài tập.&lt;/li&gt;
&lt;li&gt;Các state-of-the-art hiện nay.&lt;/li&gt;
&lt;li&gt;Các thông tin lý thú liên quan đến chủ đề đó.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Mình có tích hợp plugin Hypothesis giúp các bạn có thể highlight, viết note trên
blog của mình, đồng thời phần comment để mọi người thuận tiện trao đổi với nhau
cũng như giúp mình update các lỗi có trong bài viết.&lt;/p&gt;

&lt;h1 id=&#34;kinh-nghiệm-cá-nhân&#34;&gt;Kinh nghiệm cá nhân&lt;/h1&gt;

&lt;p&gt;Một số kinh nghiệm bản thân khi mình đọc TAoCP, thực ra đến tận bây giờ bản thân
mình mới dành thời gian với cuốn sách, trước đây mình chủ yếu dùng tham khảo là
chính:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Luôn có giấy và bút bên cạnh để có thể:

&lt;ul&gt;
&lt;li&gt;Chạy &amp;ldquo;chay&amp;rdquo; các thuật toán.&lt;/li&gt;
&lt;li&gt;Làm bài tập.&lt;/li&gt;
&lt;li&gt;Hiểu công thức đang muốn nói điều gì.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Có một sổ tay ghi chú. Một số chỗ Knuth viết rất cô đọng và mình nghĩ chỉ có
cách ghi note lại mới thực sự nhớ và hiểu được.&lt;/li&gt;
&lt;li&gt;Thử implement thuật toán bằng một ngôn ngữ ưa thích. Quan điểm của mình thì
C hoặc C++ là phù hợp nhất. C thì có thể gần với mục đích nhất,
trong khi đó C++ sẽ tiện hơn.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;một-chút-về-phần-preface-volume-i&#34;&gt;Một chút về phần Preface (Volume I)&lt;/h1&gt;

&lt;p&gt;Tuy chỉ là phần lời nói đầu, nhưng tác giả đã đề cập đến khá nhiều câu chuyện
hay ho mà mình có thể tóm lượt như sau:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Thuở xa xưa khi Khoa học máy tính mới hình thành, có 3 ngành chính thịnh hành
lúc bấy giờ: numerical analysis, artificial intelligent và language theory.
Chính Knuth là người đã khai sinh ra nhánh &amp;ldquo;analysis of algorithms&amp;rdquo;. Trước đó
đã có các công trình của Alan Turing, Jon von Neumann tuy nhiên đó là những
nghiên cứu rời rạc và không có một hệ thống hoàn chỉnh.&lt;/li&gt;
&lt;li&gt;Trong phần preface, Knuth đề cập rằng những phân tích của mình &amp;ldquo;non-numerical&amp;rdquo;
bởi vì nó quan tâm - đến các đối tượng rời rạc nhiều hơn.
Nếu chọn &amp;ldquo;nonnumerical analysis&amp;rdquo; thì nó - hơi mang tính tiêu cực
(có lẽ do tiền tố &amp;ldquo;non&amp;rdquo; trong đó). Trong khi đó &amp;ldquo;programming techniques&amp;rdquo; thì
lại quá chuyên về 1 phần trong lĩnh vực. Đó là lí do mà ông chọn từ
&amp;ldquo;analysis of algorithms&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Việc chọn mã máy MIX cũng được ông phân tích khá rõ trong phần này.
Nó thực sự những lý do đó - hoàn toán thuyết phục. Mình nghĩ một ngôn ngữ gần
nhất ông có thể dùng đó là &amp;ldquo;C&amp;rdquo;. Nhưng nếu như vậy ông phải định nghĩa số chỉ
thị cho từng câu lệnh trong &amp;ldquo;C&amp;rdquo;, điều này mình nghĩ không đơn giản lắm.&lt;/li&gt;
&lt;li&gt;Người đồng hành với ông trong cuốn sách này có &amp;ldquo;Robert W. Floyd&amp;rdquo;,
ông chính là tác giả thuật toán&amp;rdquo;Floyd-Warshall&amp;rdquo;, thuật toán phát hiện
vòng trong danh sách liên kết cũng như những đóng góp tiêu biểu của ông
trong &amp;ldquo;program verificaition&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ghi-chú&#34;&gt;Ghi chú&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Một bài nói của Don Knuth về mối quan tâm của ông với
lịch sử khoa học máy tính: [ &lt;a href=&#34;https://youtu.be/gAXdDEQveKw&#34; target=&#34;_blank&#34;&gt;link&lt;/a&gt; ]&lt;/li&gt;
&lt;li&gt;Phỏng vấn Don Knuth. Có khá nhiều chi tiết thú vị về suốt cuộc đời làm
nghiên cứu của ông (Ông mất chỉ 1 - tiếng để hoàn thành luận án
tiến sĩ của mình). [ &lt;a href=&#34;https://youtu.be/vUJ01nRE7r0&#34; target=&#34;_blank&#34;&gt;link&lt;/a&gt; ].
Mình sẽ có một bài tóm tắt về cuộc phỏng vấn đầy hấp dẫn này.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Matlab</title>
      <link>http://dangkhoasdc.github.io/post/matlab/</link>
      <pubDate>Mon, 18 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/matlab/</guid>
      <description>

&lt;h1 id=&#34;general&#34;&gt;General&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Show the information of a variable. It is very useful when we the code takes
so much memory: &lt;code&gt;whos &amp;lt;variable name&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Sum of squared of elements: &lt;code&gt;sumsqr(X)&lt;/code&gt;. Use &lt;code&gt;sum(sum(A.^2, 1))&lt;/code&gt; instead
if you want to use less memory.&lt;/li&gt;
&lt;li&gt;Memory optimizations tips and tricks:
[&lt;a href=&#34;http://undocumentedmatlab.com/blog/internal-matlab-memory-optimizations&#34; target=&#34;_blank&#34;&gt;Undocumented Matlab&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;Use column-based representation instead of the row-based one. For example, to
represent a list of items from 1 to 5, use &lt;code&gt;[1 2 3 4 5]&lt;/code&gt; (not &lt;code&gt;[1; 2; 3; 4; 5]&lt;/code&gt;).
It becomes convient because MATLAB supports &lt;code&gt;foreach&lt;/code&gt;-like statement:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-matlab&#34;&gt;for element = list
    % &amp;lt;statements&amp;gt;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If &lt;code&gt;list&lt;/code&gt; is a matrix, the above statement will assign each column of &lt;code&gt;list&lt;/code&gt; to
&lt;code&gt;element&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;code-optimization&#34;&gt;Code Optimization&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Replace &lt;code&gt;isempty(find(&amp;lt;expr&amp;gt;))&lt;/code&gt; by &lt;code&gt;isempty(find(&amp;lt;expr&amp;gt;, 1))&lt;/code&gt; to
improve performance.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;libraries&#34;&gt;Libraries&lt;/h1&gt;

&lt;h2 id=&#34;vlfeat&#34;&gt;VLFeat&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Use &lt;code&gt;vl_imreadjpeg&lt;/code&gt; instead of &lt;code&gt;imread&lt;/code&gt;. It could speed up reading image files.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Bài toán chuyển ngày sang thứ</title>
      <link>http://dangkhoasdc.github.io/post/sakamoto_method/</link>
      <pubDate>Sat, 16 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/sakamoto_method/</guid>
      <description>

&lt;p&gt;Đôi khi có những thuật toán chỉ khiến bạn thốt lên: &amp;ldquo;xuất sắc, thông minh vãi cả đxx&amp;rdquo;
Bài toán: Cho ngày, tháng, năm bất kì theo lịch Gregorian (lịch hiện nay), cho biết hôm đó rơi vào thứ mấy, tương ứng 0 -&amp;gt; Chủ Nhật, 1 -&amp;gt; Thứ Hai &amp;hellip;
Tôi đang muốn nói tới phương pháp của Sakamoto được đề xuất năm 1992. (Code theo chuẩn K&amp;amp;R C).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;dayofweek(y, m, d) {
    static int t[] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};
    y -= m &amp;lt; 3;
    return (y + y/4 - y/100 + y/400 + t[m-1] + d) % 7;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quá đơn giản, quá thông minh. Nhưng hiểu được 3 dòng code này ta mới cảm nhận được tác giả &amp;ldquo;ranh&amp;rdquo; đến mức nào. Giả sử gọi ngày 1 tháng 1 trong 1 năm bất kì làm mốc, để biết được ngày 1 tháng tiếp theo rơi vào đâu, ta có 31 = 7*4+3. Tức là ngày 1 tháng 2 rơi sau 3 ngày so với &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1&lt;/sub&gt; (Nếu ngày &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1&lt;/sub&gt; là thứ Hai thì &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; sẽ là thứ 5). &lt;code&gt;t[]&lt;/code&gt; chính là offset cho ngày đầu tiên của tháng so với ngày &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1&lt;/sub&gt;, như vậy ta có &lt;code&gt;t[] = {0, 3, 3, 6, 1, 4, 6, 2, 5, 0, 3, 5}&lt;/code&gt; (Hơi khác so với code). Chuyện tiếp theo là cộng offset đó với ngày (d-1) - khoảng cách từ ngày muốn tính đến đầu tháng , xong module cho 7 là ra được.&lt;/p&gt;

&lt;p&gt;Tuy nhiên đây mới là trong 1 năm. Bởi vì 1 năm (ko nhuận) có 365 = 52*7+1. Tức là cứ mỗi năm trôi qua là có thêm 1 ngày dôi ra, vậy ta có năm &lt;code&gt;y&lt;/code&gt;, ta phải cộng thêm &lt;code&gt;y&lt;/code&gt; ngày dôi ra đó. Nhưng đây mới là tính những năm không nhuận.&lt;/p&gt;

&lt;p&gt;Những năm nhuận, ta lại phải thêm cái ngày &lt;sup&gt;29&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; vào trong, tức là nó sẽ thêm 1 ngày nữa, trong &lt;code&gt;y&lt;/code&gt; năm? nếu có &lt;code&gt;y&lt;/code&gt; năm nhuận thì sẽ có thêm &lt;code&gt;x&lt;/code&gt; ngày được dồn vậy, $x = y/4 - y/100 + y/400$ (công thức tuy nhìn giống Inclusion-Exclusion Principle nhưng rốt cuộc ứ phải). Đơn giản là: những năm nhuận là năm (1) chia hết cho 4 nhưng không chia hết cho 100 hoặc (2) chia hết cho 400.&lt;/p&gt;

&lt;p&gt;Nhưng vẫn còn vấn đề, cái ngày thêm vào của năm nhuận là ngày &lt;sup&gt;29&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;, tức là nếu năm đó là năm nhuận nhưng ngày và tháng thuộc tháng 1 hoặc 2 thì ta không được tính vào (ví dụ 10/1/2016). Tác giả giải quyết siêu đơn giản : &lt;code&gt;y -= m &amp;lt; 3&lt;/code&gt;. Cứ hễ input tháng 1, 2 thì đẩy về năm trước đó. Và lúc đó thì năm nhuận sẽ hết nhuận.&lt;/p&gt;

&lt;p&gt;Nhưng vẫn còn vấn đề, rốt cuộc toán tử đó áp dụng cho cả những năm không nhuận. Tức tháng 1, 2 năm nào cũng bị đẩy về trước đó 1 năm. Lúc này mảng &lt;code&gt;t[]&lt;/code&gt; lại được dùng bằng cách bù cho tháng 1, 2, ta cộng 1 vào &lt;code&gt;t[0]&lt;/code&gt; và &lt;code&gt;t[1]&lt;/code&gt; và giữ nguyên các &lt;code&gt;t[]&lt;/code&gt; còn lại Sau đó chuyển -1 trong &lt;code&gt;d-1&lt;/code&gt; vào offset, lúc đó ta sẽ được mảng &lt;code&gt;t[]&lt;/code&gt; như trong code gốc.&lt;/p&gt;

&lt;p&gt;Ta còn một vấn đề là xác định ngày ban đầu để làm mốc và độ lệch &lt;code&gt;c&lt;/code&gt; của ngày gốc đó so với ngày Chủ Nhật với &lt;code&gt;index = 0&lt;/code&gt;. Nhưng bằng kiểm chứng, người ta phát hiện ra &lt;code&gt;c = 0&lt;/code&gt;. Wow. 😲&lt;/p&gt;

&lt;p&gt;Một thuật toán hay và đẹp, không chỉ tận dụng khả năng của ngôn ngữ lập trình, mà mỗi câu lệnh thể hiện được sự thông minh và khéo léo của tác giả.&lt;/p&gt;

&lt;p&gt;Bonus Problem: Chứng minh tính đúng của thuật toán bằng quy nạp.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Determination_of_the_day_of_the_week&#34; target=&#34;_blank&#34;&gt;Wiki: Determination of the day of the week&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://groups.google.com/forum/#!msg/comp.lang.c/GPA5wwrVnVw/hi2wB0TXGkAJ&#34; target=&#34;_blank&#34;&gt;Source&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Lập Trình Hướng Đối Tượng Trong Python</title>
      <link>http://dangkhoasdc.github.io/post/oop-python/</link>
      <pubDate>Mon, 20 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/oop-python/</guid>
      <description>

&lt;p&gt;Bài viết tập trung các thủ thuật khi sử dụng kỹ thuật Hướng Đối Tượng trong Python. Thực ra trong Python, các khái niệm về hướng đối tượng đã được giản lược nhiều. Thêm vào đó, lại không có những khái niệm phức tạp như access modifier, destructor, &amp;hellip; Việc xây dựng các class cũng vì thế đơn giản hơn.&lt;/p&gt;

&lt;h2 id=&#34;không-multiple-constructors&#34;&gt;Không multiple constructors&lt;/h2&gt;

&lt;p&gt;Nhưng ta có thể sử dụng &lt;code&gt;optical argument&lt;/code&gt; như một thế mạnh và thay thế cho multiple constructor.&lt;/p&gt;

&lt;h2 id=&#34;không-access-modifier&#34;&gt;Không access modifier&lt;/h2&gt;

&lt;p&gt;Đồng nghĩa với việc không có &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt; hay là &lt;code&gt;protected&lt;/code&gt; gì cả. Ngay cả việc thêm &lt;code&gt;__&lt;/code&gt; vào trước properties hay method cũng không giải quyết được vấn đề. Với mỗi thuộc tính &lt;code&gt;__p&lt;/code&gt; của lớp &lt;code&gt;A&lt;/code&gt; đơn giản là được đổi tên thành &lt;code&gt;_A__p&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;tạo-property&#34;&gt;Tạo property&lt;/h2&gt;

&lt;p&gt;Nếu được, tạo thành method thay thế. Còn không có thể sử dụng decorator &lt;code&gt;@property&lt;/code&gt; trước method để đổi thành property.&lt;/p&gt;

&lt;h2 id=&#34;đa-kế-thừa&#34;&gt;Đa kế thừa&lt;/h2&gt;

&lt;p&gt;Tránh vấn đề này càng tốt. Tham khảo &lt;a href=&#34;https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem&#34; target=&#34;_blank&#34;&gt;tại đây&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;các-thuộc-tính-và-method-static&#34;&gt;Các thuộc tính và method static&lt;/h2&gt;

&lt;p&gt;Mình không nghĩ là cần thuộc tính hay method static cho lắm. Nếu có thể cài thuộc tính/method static thì thay vào đó có thể đặt bên ngoài class và xếp trong cùng module. Nhưng vậy có thể truy cập các thuộc tính, hàm thông qua module thay vì class, và mình thấy hầu như không khác nhau là mấy.&lt;/p&gt;

&lt;h2 id=&#34;gọi-constructor-từ-lớp-cha&#34;&gt;Gọi constructor từ lớp cha&lt;/h2&gt;

&lt;p&gt;Đây là một vấn đề khá nan giải trong trường hợp đa kế thừa. Giả sử ta có lớp A, lớp B và C. Trong đó lớp C kế thừa vừa lớp A và lớp B. Vấn đề là làm thế nào để gọi A, B trong hàm khởi tạo, và làm thế nào để biết lớp cha nào được gọi trước.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class A(object):
    def __init__(self):
        super(A, self).__init__()
        print &amp;quot;entering A&amp;quot;
        print &amp;quot;leaving A&amp;quot;

class B(object):
    def __init__(self):
        super(B, self).__init__()
        print &amp;quot;entering B&amp;quot;
        print &amp;quot;leaving B&amp;quot;

class C(A,B):
    def __init__(self):
        print &amp;quot;entering c&amp;quot;
        super(C, self).__init__()
        print &amp;quot;leaving c&amp;quot;


if __name__ == &#39;__main__&#39;:
    c = C()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Có một số điều khá thú vị xoay quanh điều này sau khi ta thử nghiệm hoán vị trình tự kế thừa, trình tự định nghĩa lớp:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Trong mỗi hàm phải khai báo &lt;code&gt;super(ClassName, self).__init__()&lt;/code&gt; thì việc gọi các hàm khởi tạo từ các lớp cha mới thực hiện được.&lt;/li&gt;
&lt;li&gt;Không phụ thuộc vào trình tự kế thừa.&lt;/li&gt;
&lt;li&gt;Trình tự hàm khởi tạo được gọi dựa them alphabet.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;practices&#34;&gt;Practices&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Để kiểm tra một biến có phải là 1 thể hiện của lớp không, sử dụng hàm &lt;code&gt;isinstance&lt;/code&gt;, tuy nhiên khuyến khích không xài. Vì Python là Duck Type mà.&lt;/li&gt;
&lt;li&gt;Khai báo một thứ na ná struct trong C/C++:
{% highlight python %}
class ClassName:
pass
{% endhighlight%}&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Sau đó thì có thể tha hồ thêm thuộc tính nào vào cũng được.&lt;/p&gt;

&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/2/tutorial/classes.html&#34; target=&#34;_blank&#34;&gt;https://docs.python.org/2/tutorial/classes.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;P.s: Các chủ đề hại não và nâng cao có thể được đề cập là Iterators, Generators, &amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kinh Nghiệm Viết Tài Liệu Khoa Học</title>
      <link>http://dangkhoasdc.github.io/post/viet-luan-van/</link>
      <pubDate>Thu, 09 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/viet-luan-van/</guid>
      <description>

&lt;p&gt;Sau thời gian đắng lòng vì cái luận văn và phải lên bờ xuống ruộng với nhiều tình huống éo le cây me. Cũng thêm vào đó, sau cái sự vụ này rút ra được nhiều kinh nghiệm xương máu hơn bao giờ hết. Hiện giờ công việc dù vấn đang ngập mặt, nhưng có vẻ thư thả hơn, kèm theo đó kết quả thực nghiệm khá tốt, công việc trên lab cũng dần ổn định khiến tinh thần phấn chấn và có nhiều kế hoạch loạn xị ngầu hơn trong thời gian tới. Nhưng vẫn muốn viết tí tí cho vui.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://dangkhoasdc.github.io/img/thankyou.jpg&#34; alt=&#34;Thank you&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;dùng-phần-mềm-phiên-bản-ổn-định&#34;&gt;Dùng phần mềm phiên bản ổn định&lt;/h2&gt;

&lt;p&gt;Mình đã phải lên bờ xuống ruộng với Mac Office 2016 Preview. Dù giao diện rất đẹp, UI&amp;amp;UX tốt hơn so với bản trước đó. Nhưng điều đắng lòng là mình không thể chèn công thức toán sử dụng MathType vô được. Chưa kể là một phần mềm khác để quản lý tài liệu tham khảo cũng không thể cài trên WORD 2016. Nên dù sao đi nữa, trong những công việc quan trọng và các phần mềm cần thiết không phải lúc nào cũng update lên hàng xịn là tốt.&lt;/p&gt;

&lt;h2 id=&#34;tự-động-hoá-các-công-việc-đánh-số&#34;&gt;Tự động hoá các công việc đánh số&lt;/h2&gt;

&lt;p&gt;Trong này bao gồm cả: đánh số trang, đánh chỉ mục hình ảnh, chỉ mục bảng biểu và chương. Điểm thuận lợi có thể kể đến như:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Không phải nhức não khi phải cập nhật lại chỉ mục khi thay đổi nội dung. Với những thành phần có sẵn trong Word, chỉ cần Ctrl+A và F9 hay F11 là nó đã tự động cập nhật lại rồi.&lt;/li&gt;
&lt;li&gt;Dễ dàng trỏ đến các phần tử này mà không mất thời gian. Nếu tự chèn thì không làm được trò này rồi.&lt;/li&gt;
&lt;li&gt;Quản lý các thành phần (công thức, tài liệu tham khảo, hình ảnh) khá là dễ dàng. Định nghĩa style của nó cũng dễ hơn nữa.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dĩ nhiên, lúc đầu xài thì cảm thấy khá là nhọc, vì không quen là chính. Nhưng đó là điều rất nên làm.&lt;/p&gt;

&lt;p&gt;Mình có một số kinh nghiệm có thể kể đến như&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Với công thức, luôn dùng hệ thống đánh số của MathType. Và như vậy, mỗi khi kết chương hay kết mục, phải chèn kí tự ngắt chương hoặc mục của MathType vô. Khi muốn tham chiếu đến 1 công thức nào đó cũng phải chèn bằng lệnh của MathType.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Với trích dẫn khoa học, một công cụ hay ho mà mình tìm được đó là Mendeley Desktop ( &lt;a href=&#34;https://www.mendeley.com/download-mendeley-desktop/&#34; target=&#34;_blank&#34;&gt;Download&lt;/a&gt; ). Nó có thể tìm kiếm tài liệu, lưu lại thông tin và cho phép chèn tham khảo, chèn danh mục tham khảo với nhiều định dạng khác nhau. Nó còn hỗ trợ Refman nên việc lấy citation từ Google Scholar về và chén vô cũng rất dễ, công cụ này hoạt động khá là thông minh nên xài khá thoải mái. Hầu như mình không cần phải lo lắng về chuyện trích dẫn nữa. Một tính năng bá đạo của nó là có thể lấy được thông tin bài báo bằng cách import vào file pdf. &lt;em&gt;so cool&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;nếu-được-sử-dụng-latex&#34;&gt;Nếu được, sử dụng Latex&lt;/h2&gt;

&lt;p&gt;Latex có lẽ là công cụ tốt nhất để biên tập các tài liệu khoa học.  Hệ thống biên soạn công thức phong phú, khả năng quản lý các thành phần, đánh số, &amp;hellip; nhất quán và dễ dùng. Tuy nhiên  công cụ này khá là đồ sộ, hiểu nó là một ngôn ngữ cũng được nữa. Nên chính điều đó khiến cho giai đoạn đầu của việc dùng Latex khá là khó khăn. Tuy nhiên với một số text editor có  snippet  thì việc nhớ các cú pháp chèn hình hay công thức không còn quá khó khăn nữa. Mình chỉ ngại mỗi Latex là khi phải debug những lỗi khi viết, mất rất nhiều thời gian và không phải lúc nào cũng theo ý mình được. Vì lẽ đó mà mình xài Word 2011 cho an toàn.&lt;/p&gt;

&lt;h2 id=&#34;định-nghĩa-tất-cả-style-trước-khi-viết&#34;&gt;Định nghĩa tất cả style trước khi viết&lt;/h2&gt;

&lt;p&gt;Khi buộc phải viết theo một định dạng nào đó, chuyện đầu tiên khi mở một văn bản mới là định nghĩa hết tất cả stule dùng trong đó, từ Heading 1, Heading 2,  TOC, đánh số,&amp;hellip; Điều này tạo sự nhất quán trong quá trình viết, không phải đợi tới lúc viết xong mới làm chuyện này sẽ mất thời gian và xuất hiện một số lỗi ngoài ý muốn.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ghi chú hướng dẫn cài đặt OpenCV</title>
      <link>http://dangkhoasdc.github.io/post/opencv-tips/</link>
      <pubDate>Mon, 01 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/opencv-tips/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;I don&amp;rsquo;t need sex, because OpenCV and XCode (LLVM) f*ck me whole day.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Một ngày đầy kinh khủng với OpenCV cài trên MAC OSX, đây là mới cài để xài cho Python, Qt và C++, chưa đá động đến CUDA hay OpenNI hay trên iOS nữa, vậy mà nó đã khiến mình tốn nguyên 1 ngày kinh khủng.&lt;/p&gt;

&lt;p&gt;Bài này, mình viết dưới dạng tutorial nâng cao. Tức là không còn style &lt;em&gt;step by step&lt;/em&gt; nữa, thay vào đó chỉ hướng dẫn sơ lược cũng như các trick cần nhớ để dễ cài hơn. Và lần này là hướng dẫn cài cho cross-platform. Để sure rằng đụng trên OS nào mình sẽ không còn bị ngán. (Yeah!!)&lt;/p&gt;

&lt;h1 id=&#34;ghi-chú&#34;&gt;Ghi chú&lt;/h1&gt;

&lt;p&gt;Một số ghi chú mà mình đã rút được một cách đầy xương máu, đầy kinh dị. Theo mình nhớ, cách đây 4 năm lần đầu cài OpenCV mình cũng đã mất gần 2 ngày, giờ cài trên MAC OSX mất tầm 1 ngày. Hú hồn.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Best pratice: Tập sử dụng CMAKE hoặc Makefile. Cả 2 đều rất được việc khi config lúc build opencv hay lúc chạy chương trình. Dù muốn hay không, thì CMake vẫn là interface trên cả 3 nền tảng. Chính vì điều đó nên phải biết &amp;hellip; tập mà xài. Ưu điểm có thể kể đến như sau:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Config được cấu hình của OpenCV. Điều này những bản build sẵn không làm được.&lt;/li&gt;
&lt;li&gt;Cấu hình phù hợp với máy. CMake sẽ tự động tìm các package và cố gắng config khi có thể.&lt;/li&gt;
&lt;li&gt;Dễ sử dụng, nếu dùng CMake GUI thì rất dễ dùng.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sau mỗi lẫn thay đổi cấu hình trên CMake thì nhấn Configure lại để CMake cập nhật.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Với bản MAC OSX, nên chọn compiler là Unix Makefile, mọi lựa chọn khác tớ đều không chịu trách nhiệm.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Chuyện kinh dị đêm khuya, chọn compiler là XCode. Khi build các source khác ( 1 tool rút trích đặc trưng chẳng hạn), thế là nó
dính ngay lỗi &lt;code&gt;undefined symbols for architecture x86_64&lt;/code&gt;, lỗi này khắc phục bằng cách thêm flags &lt;em&gt;-lstdc++&lt;/em&gt; vô trình biên dịch,
nhưng đắng lòng tiếp theo là sau khi compile thì hàng mớ lỗi xảy đến vì sự khác nhau trong hệ thống standard library của XCode và
GNU. Lúc đó, chắc chắn chả ai còn hứng thú để mà sửa lỗi tiếp.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Nên có 1 sổ ghi chú, hoặc note ghi lại quá trình cài đặt, không là fail dài dài. Mà thậm chí là cứ làm lặp đi lặp lại mọi thứ.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;cài-đặt&#34;&gt;Cài đặt&lt;/h1&gt;

&lt;p&gt;Trong phần này gồm các bước cài đặt OpenCV sử dụng CMake. Dùng mà thấy mình cứ như là &lt;em&gt;hacker&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Tải source OpenCV về.
a. Tải từ website.
b. Tải từ github.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Giải nén và tạo thư mục &lt;code&gt;build&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir build
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Mở CMake, chọn đường dẫn đến.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Nhấn Configure và chọn compiler tương ứng.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Bên Linux, theo mình nhớ là GNU.&lt;/li&gt;
&lt;li&gt;Bên Windows, khuyến khích chọn Visual Studio. Tuy nhiên, số phiên bản của VS khác với số năm của Visual Studio (Tức là Visual Studio 2013 thì không phải có v13).&lt;/li&gt;
&lt;li&gt;Sau bao đau thương, MAC OS X thì chọn Unix Makefile.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Trong lúc nó run, thì tranh thủ đọc về sự khác nhau của &lt;a href=&#34;http://stackoverflow.com/questions/2649334/difference-between-static-and-shared-libraries&#34; target=&#34;_blank&#34;&gt;static lib và shared lib&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Config các tham số cấu hình, mình thì quan tâm đến vài thứ sau: Qt, Python, Cuda. &lt;em&gt;Vì hôm nữa chắc sẽ có 1 tut khác liên quan đến mấy cái này&lt;/em&gt;. Để ý output coi có báo lõi gì không.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Nhấn &lt;code&gt;Configure&lt;/code&gt; đến bao giờ trên phần tham số không còn đỏ nữa thì thôi. Lúc đó nhấn &lt;code&gt;build&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Build OpenCV thôi.
a. Với các bé họ nhà Unix (Mac OSX, Linux &amp;hellip;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd path/to/build/dir
make -j4 # jk với k là số thread để chạy
sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;b. Với các bé nhà Windows:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://dangkhoahome.blogspot.sg/2012/03/huong-dan-cai-at-opencv-23-231-trong.html&#34; target=&#34;_blank&#34;&gt;Chịu khó xem lại bài post cũ của mình, mình sẽ update bản mới trong thời gian đến&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;UPDATE 1&lt;/em&gt;: Vẫn chưa cài được Opencv 3 lên trên python sau bao nhiêu nỗ lực thực hiện với MAC OS X. Mình sẽ cài đặt nó lên trên Linux để test xem sao.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;UPDATE 2&lt;/em&gt;: Chắc hôm nào sẽ viết tutorial trên cả 3 nền tảng step-by-step.&lt;/p&gt;

&lt;p&gt;P/S: Bạn nào muốn share bài của mình thì vô tư, nhưng nhớ ghi rõ nguồn.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Spams Lib và Những Tâm Sự</title>
      <link>http://dangkhoasdc.github.io/post/spams-lib/</link>
      <pubDate>Wed, 25 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>http://dangkhoasdc.github.io/post/spams-lib/</guid>
      <description>&lt;p&gt;Không còn gì sung sướng hơn sau 2 ngày ngồi cài cái khỉ gió &lt;em&gt;sparse coding lib cho python&lt;/em&gt;, link cái thằng khỉ gió nó ở đây: &lt;a href=&#34;http://spams-devel.gforge.inria.fr/downloads.html&#34; target=&#34;_blank&#34;&gt;Spams lib&lt;/a&gt;. Mặc dù đã cố gắng nhưng phải mất mấy tiếng đồng hồ mình mới xong được cu cậu này.&lt;/p&gt;

&lt;p&gt;Sau đây là một số kinh nghiệm xương máu mình có thể rút ra như sau:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Không giống như cu Linux hay các bản distro của nó. Trên Mac có 2 cái package manager: MacPorts và HomeBrew. Mà 2 cái này nó lại đẻ ra một số chuyện linh ta linh tinh:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Chúng cài đặt các phần mềm ở những chỗ khác nhau, như cu MacPorts nhét trong &lt;em&gt;/opt/local/bin/&lt;/em&gt;, cu kia thì kinh dị hơn, nhét trong &lt;em&gt;/usr/local/Cellar/&lt;/em&gt; làm mình chả biết đường nào mà lần.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tất cả các đồng chí trên đều đưa đường dẫn đến $PATH, và rồi hầm bà lằng các conflict xuất hiện khiến mình muốn điên đầu.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Bài học tổng kết: chỉ nên xài 1 trong 2 cu&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Không nên tin tưởng hàng của Apple cho lắm, cu cậu chế ra các thứ quá là điên:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Trình biên dịch của Apple chế ra một số options mà ta phải kể đến như cái &lt;code&gt;-arch&lt;/code&gt; chết dịch, ngoài ra còn có cu warning &lt;code&gt;-Wshorten64-to-32&lt;/code&gt;. Python tự generate ra những option dựa trên hệ điều hành đang dùng, khổ một cái, cái compiler mình dùng lại không support cho mấy cái chuyện đó.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Ngoài ra, clang của Apple còn không hỗ trợ cả OpenMP, mà cái này bắt buộc phải có trong cái sparse coding lib này. Đại khái nó cứ luẩn quẩn.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Chưa hết, trong &lt;code&gt;setup.py&lt;/code&gt; cu này để option mặc định là &lt;code&gt;-m32&lt;/code&gt;, tức là sử dụng kiến trúc 32bit. Máy mình lại là 64bit. Sửa lại thì được nhưng lại phải chọn kiến trúc trong file thực thi của python.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Đại khái là xoắn. Giờ thì mình đã biết cách giải quyết:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Cài &lt;strong&gt;python&lt;/strong&gt; từ trang chủ.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Xác định đường dẫn chính thức của nó, mò xem nó ở đâu và add vô trong $PATH.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sử dụng &lt;strong&gt;Superpack&lt;/strong&gt; để cài các gói liên quan trong scipy. &lt;a href=&#34;https://github.com/fonnesbeck/ScipySuperpack&#34; target=&#34;_blank&#34;&gt;link nó đây&lt;/a&gt;. Trong này thì lưu ý cái biên $PIP, sửa lại cho phù hợp với cái máy của mình.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Đối với cu numpy và scipy thì cài đặt thông qua pip.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>
